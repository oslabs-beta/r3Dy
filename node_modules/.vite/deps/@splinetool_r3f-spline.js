import {
  AxesHelper,
  Box2,
  Box3,
  Box3Helper,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  BufferGeometryLoader,
  Camera,
  CameraHelper,
  Color,
  ConeGeometry,
  CubeReflectionMapping,
  CubeRefractionMapping,
  CubeTexture,
  CubeUVReflectionMapping,
  CubicBezierCurve,
  CubicBezierCurve3,
  CurvePath,
  CylinderGeometry,
  DirectionalLight,
  DirectionalLightHelper,
  DodecahedronGeometry,
  EllipseCurve,
  Euler,
  EventDispatcher,
  FileLoader,
  Float32BufferAttribute,
  Fog,
  Group,
  HemisphereLight,
  IcosahedronGeometry,
  LatheGeometry,
  Light,
  Line3,
  LineBasicMaterial,
  LineCurve,
  LineCurve3,
  LineSegments,
  LinearEncoding,
  LinearSRGBColorSpace,
  Loader,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  Object3D,
  OrthographicCamera,
  Path,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PointLight,
  PointLightHelper,
  QuadraticBezierCurve,
  Quaternion,
  Ray,
  Raycaster,
  SRGBColorSpace,
  Scene,
  ShaderLib,
  ShaderMaterial,
  Shape,
  ShapeUtils,
  Sphere,
  SphereGeometry,
  SplineCurve,
  SpotLight,
  SpotLightHelper,
  Texture,
  TorusKnotGeometry,
  Triangle,
  Uint32BufferAttribute,
  UniformsLib,
  UniformsUtils,
  Vector2,
  Vector3,
  Vector4,
  VideoTexture,
  sRGBEncoding,
  useGraph,
  useLoader
} from "./chunk-F5N6VGLE.js";
import "./chunk-YN3MIK7E.js";
import "./chunk-4EOJPDL2.js";

// node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
function mergeGeometries(geometries, useGroups = false) {
  const isIndexed = geometries[0].index !== null;
  const attributesUsed = new Set(Object.keys(geometries[0].attributes));
  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
  const attributes = {};
  const morphAttributes = {};
  const morphTargetsRelative = geometries[0].morphTargetsRelative;
  const mergedGeometry = new BufferGeometry();
  let offset = 0;
  for (let i = 0; i < geometries.length; ++i) {
    const geometry = geometries[i];
    let attributesCount = 0;
    if (isIndexed !== (geometry.index !== null)) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
      return null;
    }
    for (const name in geometry.attributes) {
      if (!attributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
        return null;
      }
      if (attributes[name] === void 0)
        attributes[name] = [];
      attributes[name].push(geometry.attributes[name]);
      attributesCount++;
    }
    if (attributesCount !== attributesUsed.size) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes.");
      return null;
    }
    if (morphTargetsRelative !== geometry.morphTargetsRelative) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries.");
      return null;
    }
    for (const name in geometry.morphAttributes) {
      if (!morphAttributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries.");
        return null;
      }
      if (morphAttributes[name] === void 0)
        morphAttributes[name] = [];
      morphAttributes[name].push(geometry.morphAttributes[name]);
    }
    if (useGroups) {
      let count;
      if (isIndexed) {
        count = geometry.index.count;
      } else if (geometry.attributes.position !== void 0) {
        count = geometry.attributes.position.count;
      } else {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute");
        return null;
      }
      mergedGeometry.addGroup(offset, count, i);
      offset += count;
    }
  }
  if (isIndexed) {
    let indexOffset = 0;
    const mergedIndex = [];
    for (let i = 0; i < geometries.length; ++i) {
      const index = geometries[i].index;
      for (let j = 0; j < index.count; ++j) {
        mergedIndex.push(index.getX(j) + indexOffset);
      }
      indexOffset += geometries[i].attributes.position.count;
    }
    mergedGeometry.setIndex(mergedIndex);
  }
  for (const name in attributes) {
    const mergedAttribute = mergeAttributes(attributes[name]);
    if (!mergedAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " attribute.");
      return null;
    }
    mergedGeometry.setAttribute(name, mergedAttribute);
  }
  for (const name in morphAttributes) {
    const numMorphTargets = morphAttributes[name][0].length;
    if (numMorphTargets === 0)
      break;
    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
    mergedGeometry.morphAttributes[name] = [];
    for (let i = 0; i < numMorphTargets; ++i) {
      const morphAttributesToMerge = [];
      for (let j = 0; j < morphAttributes[name].length; ++j) {
        morphAttributesToMerge.push(morphAttributes[name][j][i]);
      }
      const mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);
      if (!mergedMorphAttribute) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " morphAttribute.");
        return null;
      }
      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
    }
  }
  return mergedGeometry;
}
function mergeAttributes(attributes) {
  let TypedArray;
  let itemSize;
  let normalized;
  let gpuType = -1;
  let arrayLength = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (attribute.isInterleavedBufferAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.");
      return null;
    }
    if (TypedArray === void 0)
      TypedArray = attribute.array.constructor;
    if (TypedArray !== attribute.array.constructor) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
      return null;
    }
    if (itemSize === void 0)
      itemSize = attribute.itemSize;
    if (itemSize !== attribute.itemSize) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
      return null;
    }
    if (normalized === void 0)
      normalized = attribute.normalized;
    if (normalized !== attribute.normalized) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
      return null;
    }
    if (gpuType === -1)
      gpuType = attribute.gpuType;
    if (gpuType !== attribute.gpuType) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.");
      return null;
    }
    arrayLength += attribute.array.length;
  }
  const array = new TypedArray(arrayLength);
  let offset = 0;
  for (let i = 0; i < attributes.length; ++i) {
    array.set(attributes[i].array, offset);
    offset += attributes[i].array.length;
  }
  const result = new BufferAttribute(array, itemSize, normalized);
  if (gpuType !== void 0) {
    result.gpuType = gpuType;
  }
  return result;
}
function mergeBufferGeometries(geometries, useGroups = false) {
  console.warn("THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().");
  return mergeGeometries(geometries, useGroups);
}

// node_modules/three/examples/jsm/loaders/DRACOLoader.js
var _taskCache = /* @__PURE__ */ new WeakMap();
var DRACOLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.decoderPath = "";
    this.decoderConfig = {};
    this.decoderBinary = null;
    this.decoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    };
    this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(path) {
    this.decoderPath = path;
    return this;
  }
  setDecoderConfig(config) {
    this.decoderConfig = config;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer) => {
      this.parse(buffer, onLoad, onError);
    }, onProgress, onError);
  }
  parse(buffer, onLoad, onError) {
    this.decodeDracoFile(buffer, onLoad, null, null, SRGBColorSpace).catch(onError);
  }
  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace) {
    const taskConfig = {
      attributeIDs: attributeIDs || this.defaultAttributeIDs,
      attributeTypes: attributeTypes || this.defaultAttributeTypes,
      useUniqueIDs: !!attributeIDs,
      vertexColorSpace
    };
    return this.decodeGeometry(buffer, taskConfig).then(callback);
  }
  decodeGeometry(buffer, taskConfig) {
    const taskKey = JSON.stringify(taskConfig);
    if (_taskCache.has(buffer)) {
      const cachedTask = _taskCache.get(buffer);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer.byteLength === 0) {
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
      }
    }
    let worker;
    const taskID = this.workerNextTaskID++;
    const taskCost = buffer.byteLength;
    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
      worker = _worker;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = { resolve, reject };
        worker.postMessage({ type: "decode", id: taskID, taskConfig, buffer }, [buffer]);
      });
    }).then((message) => this._createGeometry(message.geometry));
    geometryPending.catch(() => true).then(() => {
      if (worker && taskID) {
        this._releaseTask(worker, taskID);
      }
    });
    _taskCache.set(buffer, {
      key: taskKey,
      promise: geometryPending
    });
    return geometryPending;
  }
  _createGeometry(geometryData) {
    const geometry = new BufferGeometry();
    if (geometryData.index) {
      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
    }
    for (let i = 0; i < geometryData.attributes.length; i++) {
      const result = geometryData.attributes[i];
      const name = result.name;
      const array = result.array;
      const itemSize = result.itemSize;
      const attribute = new BufferAttribute(array, itemSize);
      if (name === "color") {
        this._assignVertexColorSpace(attribute, result.vertexColorSpace);
        attribute.normalized = array instanceof Float32Array === false;
      }
      geometry.setAttribute(name, attribute);
    }
    return geometry;
  }
  _assignVertexColorSpace(attribute, inputColorSpace) {
    if (inputColorSpace !== SRGBColorSpace)
      return;
    const _color = new Color();
    for (let i = 0, il = attribute.count; i < il; i++) {
      _color.fromBufferAttribute(attribute, i).convertSRGBToLinear();
      attribute.setXYZ(i, _color.r, _color.g, _color.b);
    }
  }
  _loadLibrary(url, responseType) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.decoderPath);
    loader.setResponseType(responseType);
    loader.setWithCredentials(this.withCredentials);
    return new Promise((resolve, reject) => {
      loader.load(url, resolve, void 0, reject);
    });
  }
  preload() {
    this._initDecoder();
    return this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
    const librariesPending = [];
    if (useJS) {
      librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
    } else {
      librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
      librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
    }
    this.decoderPending = Promise.all(librariesPending).then((libraries) => {
      const jsContent = libraries[0];
      if (!useJS) {
        this.decoderConfig.wasmBinary = libraries[1];
      }
      const fn2 = DRACOWorker.toString();
      const body = [
        "/* draco decoder */",
        jsContent,
        "",
        "/* worker */",
        fn2.substring(fn2.indexOf("{") + 1, fn2.lastIndexOf("}"))
      ].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([body]));
    });
    return this.decoderPending;
  }
  _getWorker(taskID, taskCost) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskCosts = {};
        worker2._taskLoad = 0;
        worker2.postMessage({ type: "init", decoderConfig: this.decoderConfig });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "decode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a, b) {
          return a._taskLoad > b._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskCosts[taskID] = taskCost;
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  _releaseTask(worker, taskID) {
    worker._taskLoad -= worker._taskCosts[taskID];
    delete worker._callbacks[taskID];
    delete worker._taskCosts[taskID];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((worker) => worker._taskLoad));
  }
  dispose() {
    for (let i = 0; i < this.workerPool.length; ++i) {
      this.workerPool[i].terminate();
    }
    this.workerPool.length = 0;
    if (this.workerSourceURL !== "") {
      URL.revokeObjectURL(this.workerSourceURL);
    }
    return this;
  }
};
function DRACOWorker() {
  let decoderConfig;
  let decoderPending;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        decoderConfig = message.decoderConfig;
        decoderPending = new Promise(function(resolve) {
          decoderConfig.onModuleLoaded = function(draco) {
            resolve({ draco });
          };
          DracoDecoderModule(decoderConfig);
        });
        break;
      case "decode":
        const buffer = message.buffer;
        const taskConfig = message.taskConfig;
        decoderPending.then((module2) => {
          const draco = module2.draco;
          const decoder = new draco.Decoder();
          try {
            const geometry = decodeGeometry(draco, decoder, new Int8Array(buffer), taskConfig);
            const buffers = geometry.attributes.map((attr) => attr.array.buffer);
            if (geometry.index)
              buffers.push(geometry.index.array.buffer);
            self.postMessage({ type: "decode", id: message.id, geometry }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          } finally {
            draco.destroy(decoder);
          }
        });
        break;
    }
  };
  function decodeGeometry(draco, decoder, array, taskConfig) {
    const attributeIDs = taskConfig.attributeIDs;
    const attributeTypes = taskConfig.attributeTypes;
    let dracoGeometry;
    let decodingStatus;
    const geometryType = decoder.GetEncodedGeometryType(array);
    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);
    } else {
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    }
    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
      throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
    }
    const geometry = { index: null, attributes: [] };
    for (const attributeName in attributeIDs) {
      const attributeType = self[attributeTypes[attributeName]];
      let attribute;
      let attributeID;
      if (taskConfig.useUniqueIDs) {
        attributeID = attributeIDs[attributeName];
        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
      } else {
        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
        if (attributeID === -1)
          continue;
        attribute = decoder.GetAttribute(dracoGeometry, attributeID);
      }
      const attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);
      if (attributeName === "color") {
        attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;
      }
      geometry.attributes.push(attributeResult);
    }
    if (geometryType === draco.TRIANGULAR_MESH) {
      geometry.index = decodeIndex(draco, decoder, dracoGeometry);
    }
    draco.destroy(dracoGeometry);
    return geometry;
  }
  function decodeIndex(draco, decoder, dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * 4;
    const ptr = draco._malloc(byteLength);
    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
    draco._free(ptr);
    return { array: index, itemSize: 1 };
  }
  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
    const numComponents = attribute.num_components();
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(draco, attributeType);
    const ptr = draco._malloc(byteLength);
    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
    draco._free(ptr);
    return {
      name: attributeName,
      array,
      itemSize: numComponents
    };
  }
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
    }
  }
}

// node_modules/@splinetool/loader/build/SplineLoader.js
var d0 = Object.create;
var Ql = Object.defineProperty;
var u0 = Object.getOwnPropertyDescriptor;
var p0 = Object.getOwnPropertyNames;
var f0 = Object.getPrototypeOf;
var m0 = Object.prototype.hasOwnProperty;
var qs = (n, r) => () => (r || n((r = { exports: {} }).exports, r), r.exports);
var h0 = (n, r) => {
  for (var e in r)
    Ql(n, e, { get: r[e], enumerable: true });
};
var y0 = (n, r, e, t) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let o of p0(r))
      !m0.call(n, o) && o !== e && Ql(n, o, { get: () => r[o], enumerable: !(t = u0(r, o)) || t.enumerable });
  return n;
};
var Ws = (n, r, e) => (e = n != null ? d0(f0(n)) : {}, y0(r || !n || !n.__esModule ? Ql(e, "default", { value: n, enumerable: true }) : e, n));
var Km = qs((Cc, Xm) => {
  (function(n, r) {
    typeof Cc == "object" ? Xm.exports = r() : typeof define == "function" && define.amd ? define(r) : n.Alea = r();
  })(Cc, function() {
    "use strict";
    return n.importState = function(e) {
      var t = new n();
      return t.importState(e), t;
    }, n;
    function n() {
      return function(e) {
        var t = 0, o = 0, i = 0, s = 1;
        e.length == 0 && (e = [+/* @__PURE__ */ new Date()]);
        var l = r();
        t = l(" "), o = l(" "), i = l(" ");
        for (var c = 0; c < e.length; c++)
          t -= l(e[c]), t < 0 && (t += 1), o -= l(e[c]), o < 0 && (o += 1), i -= l(e[c]), i < 0 && (i += 1);
        l = null;
        var u = function() {
          var a = 2091639 * t + s * 23283064365386963e-26;
          return t = o, o = i, i = a - (s = a | 0);
        };
        return u.next = u, u.uint32 = function() {
          return u() * 4294967296;
        }, u.fract53 = function() {
          return u() + (u() * 2097152 | 0) * 11102230246251565e-32;
        }, u.version = "Alea 0.9", u.args = e, u.exportState = function() {
          return [t, o, i, s];
        }, u.importState = function(a) {
          t = +a[0] || 0, o = +a[1] || 0, i = +a[2] || 0, s = +a[3] || 0;
        }, u;
      }(Array.prototype.slice.call(arguments));
    }
    function r() {
      var e = 4022871197, t = function(o) {
        o = o.toString();
        for (var i = 0; i < o.length; i++) {
          e += o.charCodeAt(i);
          var s = 0.02519603282416938 * e;
          e = s >>> 0, s -= e, s *= e, e = s >>> 0, s -= e, e += s * 4294967296;
        }
        return (e >>> 0) * 23283064365386963e-26;
      };
      return t.version = "Mash 0.9", t;
    }
  });
});
var th = qs((Za, eh) => {
  (function(n, r) {
    typeof Za == "object" && typeof eh < "u" ? r(Za) : typeof define == "function" && define.amd ? define(["exports"], r) : r((n = typeof globalThis < "u" ? globalThis : n || self).SVDJS = {});
  })(Za, function(n) {
    "use strict";
    n.SVD = function(r, e, t, o, i) {
      if (e = e === void 0 || e, t = t === void 0 || t, i = 1e-64 / (o = o || Math.pow(2, -52)), !r)
        throw new TypeError("Matrix a is not defined");
      var s, l, c, u, a, d, p, f, m, h, y, g, v = r[0].length, b = r.length;
      if (b < v)
        throw new TypeError("Invalid matrix: m < n");
      for (var w = [], S = [], P = [], _ = e === "f" ? b : v, x = h = p = 0; x < b; x++)
        S[x] = new Array(_).fill(0);
      for (x = 0; x < v; x++)
        P[x] = new Array(v).fill(0);
      var C, T = new Array(v).fill(0);
      for (x = 0; x < b; x++)
        for (s = 0; s < v; s++)
          S[x][s] = r[x][s];
      for (x = 0; x < v; x++) {
        for (w[x] = p, m = 0, c = x + 1, s = x; s < b; s++)
          m += Math.pow(S[s][x], 2);
        if (m < i)
          p = 0;
        else
          for (f = (d = S[x][x]) * (p = d < 0 ? Math.sqrt(m) : -Math.sqrt(m)) - m, S[x][x] = d - p, s = c; s < v; s++) {
            for (m = 0, l = x; l < b; l++)
              m += S[l][x] * S[l][s];
            for (d = m / f, l = x; l < b; l++)
              S[l][s] = S[l][s] + d * S[l][x];
          }
        for (T[x] = p, m = 0, s = c; s < v; s++)
          m += Math.pow(S[x][s], 2);
        if (m < i)
          p = 0;
        else {
          for (f = (d = S[x][x + 1]) * (p = d < 0 ? Math.sqrt(m) : -Math.sqrt(m)) - m, S[x][x + 1] = d - p, s = c; s < v; s++)
            w[s] = S[x][s] / f;
          for (s = c; s < b; s++) {
            for (m = 0, l = c; l < v; l++)
              m += S[s][l] * S[x][l];
            for (l = c; l < v; l++)
              S[s][l] = S[s][l] + m * w[l];
          }
        }
        h < (y = Math.abs(T[x]) + Math.abs(w[x])) && (h = y);
      }
      if (t)
        for (x = v - 1; 0 <= x; x--) {
          if (p !== 0) {
            for (f = S[x][x + 1] * p, s = c; s < v; s++)
              P[s][x] = S[x][s] / f;
            for (s = c; s < v; s++) {
              for (m = 0, l = c; l < v; l++)
                m += S[x][l] * P[l][s];
              for (l = c; l < v; l++)
                P[l][s] = P[l][s] + m * P[l][x];
            }
          }
          for (s = c; s < v; s++)
            P[x][s] = 0, P[s][x] = 0;
          P[x][x] = 1, p = w[x], c = x;
        }
      if (e) {
        if (e === "f")
          for (x = v; x < b; x++) {
            for (s = v; s < b; s++)
              S[x][s] = 0;
            S[x][x] = 1;
          }
        for (x = v - 1; 0 <= x; x--) {
          for (c = x + 1, p = T[x], s = c; s < _; s++)
            S[x][s] = 0;
          if (p !== 0) {
            for (f = S[x][x] * p, s = c; s < _; s++) {
              for (m = 0, l = c; l < b; l++)
                m += S[l][x] * S[l][s];
              for (d = m / f, l = x; l < b; l++)
                S[l][s] = S[l][s] + d * S[l][x];
            }
            for (s = x; s < b; s++)
              S[s][x] = S[s][x] / p;
          } else
            for (s = x; s < b; s++)
              S[s][x] = 0;
          S[x][x] = S[x][x] + 1;
        }
      }
      for (o *= h, l = v - 1; 0 <= l; l--)
        for (var N = 0; N < 50; N++) {
          for (C = false, c = l; 0 <= c; c--) {
            if (Math.abs(w[c]) <= o) {
              C = true;
              break;
            }
            if (Math.abs(T[c - 1]) <= o)
              break;
          }
          if (!C) {
            for (a = 0, u = c - (m = 1), x = c; x < l + 1 && (d = m * w[x], w[x] = a * w[x], !(Math.abs(d) <= o)); x++)
              if (p = T[x], T[x] = Math.sqrt(d * d + p * p), a = p / (f = T[x]), m = -d / f, e)
                for (s = 0; s < b; s++)
                  y = S[s][u], g = S[s][x], S[s][u] = y * a + g * m, S[s][x] = -y * m + g * a;
          }
          if (g = T[l], c === l) {
            if (g < 0 && (T[l] = -g, t))
              for (s = 0; s < v; s++)
                P[s][l] = -P[s][l];
            break;
          }
          for (h = T[c], d = (((y = T[l - 1]) - g) * (y + g) + ((p = w[l - 1]) - (f = w[l])) * (p + f)) / (2 * f * y), p = Math.sqrt(d * d + 1), d = ((h - g) * (h + g) + f * (y / (d < 0 ? d - p : d + p) - f)) / h, x = c + (m = a = 1); x < l + 1; x++) {
            if (p = w[x], y = T[x], f = m * p, p *= a, g = Math.sqrt(d * d + f * f), d = h * (a = d / (w[x - 1] = g)) + p * (m = f / g), p = -h * m + p * a, f = y * m, y *= a, t)
              for (s = 0; s < v; s++)
                h = P[s][x - 1], g = P[s][x], P[s][x - 1] = h * a + g * m, P[s][x] = -h * m + g * a;
            if (g = Math.sqrt(d * d + f * f), d = (a = d / (T[x - 1] = g)) * p + (m = f / g) * y, h = -m * p + a * y, e)
              for (s = 0; s < b; s++)
                y = S[s][x - 1], g = S[s][x], S[s][x - 1] = y * a + g * m, S[s][x] = -y * m + g * a;
          }
          w[c] = 0, w[l] = d, T[l] = h;
        }
      for (x = 0; x < v; x++)
        T[x] < o && (T[x] = 0);
      return { u: S, q: T, v: P };
    }, n.VERSION = "1.1.1", Object.defineProperty(n, "__esModule", { value: true });
  });
});
var Uy = qs((El) => {
  (function() {
    "use strict";
    var n = function() {
      this.init();
    };
    n.prototype = { init: function() {
      var a = this || r;
      return a._counter = 1e3, a._html5AudioPool = [], a.html5PoolSize = 10, a._codecs = {}, a._howls = [], a._muted = false, a._volume = 1, a._canPlayEvent = "canplaythrough", a._navigator = typeof window < "u" && window.navigator ? window.navigator : null, a.masterGain = null, a.noAudio = false, a.usingWebAudio = true, a.autoSuspend = true, a.ctx = null, a.autoUnlock = true, a._setup(), a;
    }, volume: function(a) {
      var d = this || r;
      if (a = parseFloat(a), d.ctx || u(), typeof a < "u" && a >= 0 && a <= 1) {
        if (d._volume = a, d._muted)
          return d;
        d.usingWebAudio && d.masterGain.gain.setValueAtTime(a, r.ctx.currentTime);
        for (var p = 0; p < d._howls.length; p++)
          if (!d._howls[p]._webAudio)
            for (var f = d._howls[p]._getSoundIds(), m = 0; m < f.length; m++) {
              var h = d._howls[p]._soundById(f[m]);
              h && h._node && (h._node.volume = h._volume * a);
            }
        return d;
      }
      return d._volume;
    }, mute: function(a) {
      var d = this || r;
      d.ctx || u(), d._muted = a, d.usingWebAudio && d.masterGain.gain.setValueAtTime(a ? 0 : d._volume, r.ctx.currentTime);
      for (var p = 0; p < d._howls.length; p++)
        if (!d._howls[p]._webAudio)
          for (var f = d._howls[p]._getSoundIds(), m = 0; m < f.length; m++) {
            var h = d._howls[p]._soundById(f[m]);
            h && h._node && (h._node.muted = a ? true : h._muted);
          }
      return d;
    }, stop: function() {
      for (var a = this || r, d = 0; d < a._howls.length; d++)
        a._howls[d].stop();
      return a;
    }, unload: function() {
      for (var a = this || r, d = a._howls.length - 1; d >= 0; d--)
        a._howls[d].unload();
      return a.usingWebAudio && a.ctx && typeof a.ctx.close < "u" && (a.ctx.close(), a.ctx = null, u()), a;
    }, codecs: function(a) {
      return (this || r)._codecs[a.replace(/^x-/, "")];
    }, _setup: function() {
      var a = this || r;
      if (a.state = a.ctx && a.ctx.state || "suspended", a._autoSuspend(), !a.usingWebAudio)
        if (typeof Audio < "u")
          try {
            var d = new Audio();
            typeof d.oncanplaythrough > "u" && (a._canPlayEvent = "canplay");
          } catch {
            a.noAudio = true;
          }
        else
          a.noAudio = true;
      try {
        var d = new Audio();
        d.muted && (a.noAudio = true);
      } catch {
      }
      return a.noAudio || a._setupCodecs(), a;
    }, _setupCodecs: function() {
      var a = this || r, d = null;
      try {
        d = typeof Audio < "u" ? new Audio() : null;
      } catch {
        return a;
      }
      if (!d || typeof d.canPlayType != "function")
        return a;
      var p = d.canPlayType("audio/mpeg;").replace(/^no$/, ""), f = a._navigator ? a._navigator.userAgent : "", m = f.match(/OPR\/([0-6].)/g), h = m && parseInt(m[0].split("/")[1], 10) < 33, y = f.indexOf("Safari") !== -1 && f.indexOf("Chrome") === -1, g = f.match(/Version\/(.*?) /), v = y && g && parseInt(g[1], 10) < 15;
      return a._codecs = { mp3: !!(!h && (p || d.canPlayType("audio/mp3;").replace(/^no$/, ""))), mpeg: !!p, opus: !!d.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""), ogg: !!d.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), oga: !!d.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), wav: !!(d.canPlayType('audio/wav; codecs="1"') || d.canPlayType("audio/wav")).replace(/^no$/, ""), aac: !!d.canPlayType("audio/aac;").replace(/^no$/, ""), caf: !!d.canPlayType("audio/x-caf;").replace(/^no$/, ""), m4a: !!(d.canPlayType("audio/x-m4a;") || d.canPlayType("audio/m4a;") || d.canPlayType("audio/aac;")).replace(/^no$/, ""), m4b: !!(d.canPlayType("audio/x-m4b;") || d.canPlayType("audio/m4b;") || d.canPlayType("audio/aac;")).replace(/^no$/, ""), mp4: !!(d.canPlayType("audio/x-mp4;") || d.canPlayType("audio/mp4;") || d.canPlayType("audio/aac;")).replace(/^no$/, ""), weba: !!(!v && d.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), webm: !!(!v && d.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), dolby: !!d.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""), flac: !!(d.canPlayType("audio/x-flac;") || d.canPlayType("audio/flac;")).replace(/^no$/, "") }, a;
    }, _unlockAudio: function() {
      var a = this || r;
      if (!(a._audioUnlocked || !a.ctx)) {
        a._audioUnlocked = false, a.autoUnlock = false, !a._mobileUnloaded && a.ctx.sampleRate !== 44100 && (a._mobileUnloaded = true, a.unload()), a._scratchBuffer = a.ctx.createBuffer(1, 1, 22050);
        var d = function(p) {
          for (; a._html5AudioPool.length < a.html5PoolSize; )
            try {
              var f = new Audio();
              f._unlocked = true, a._releaseHtml5Audio(f);
            } catch {
              a.noAudio = true;
              break;
            }
          for (var m = 0; m < a._howls.length; m++)
            if (!a._howls[m]._webAudio)
              for (var h = a._howls[m]._getSoundIds(), y = 0; y < h.length; y++) {
                var g = a._howls[m]._soundById(h[y]);
                g && g._node && !g._node._unlocked && (g._node._unlocked = true, g._node.load());
              }
          a._autoResume();
          var v = a.ctx.createBufferSource();
          v.buffer = a._scratchBuffer, v.connect(a.ctx.destination), typeof v.start > "u" ? v.noteOn(0) : v.start(0), typeof a.ctx.resume == "function" && a.ctx.resume(), v.onended = function() {
            v.disconnect(0), a._audioUnlocked = true, document.removeEventListener("touchstart", d, true), document.removeEventListener("touchend", d, true), document.removeEventListener("click", d, true), document.removeEventListener("keydown", d, true);
            for (var b = 0; b < a._howls.length; b++)
              a._howls[b]._emit("unlock");
          };
        };
        return document.addEventListener("touchstart", d, true), document.addEventListener("touchend", d, true), document.addEventListener("click", d, true), document.addEventListener("keydown", d, true), a;
      }
    }, _obtainHtml5Audio: function() {
      var a = this || r;
      if (a._html5AudioPool.length)
        return a._html5AudioPool.pop();
      var d = new Audio().play();
      return d && typeof Promise < "u" && (d instanceof Promise || typeof d.then == "function") && d.catch(function() {
        console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
      }), new Audio();
    }, _releaseHtml5Audio: function(a) {
      var d = this || r;
      return a._unlocked && d._html5AudioPool.push(a), d;
    }, _autoSuspend: function() {
      var a = this;
      if (!(!a.autoSuspend || !a.ctx || typeof a.ctx.suspend > "u" || !r.usingWebAudio)) {
        for (var d = 0; d < a._howls.length; d++)
          if (a._howls[d]._webAudio) {
            for (var p = 0; p < a._howls[d]._sounds.length; p++)
              if (!a._howls[d]._sounds[p]._paused)
                return a;
          }
        return a._suspendTimer && clearTimeout(a._suspendTimer), a._suspendTimer = setTimeout(function() {
          if (!!a.autoSuspend) {
            a._suspendTimer = null, a.state = "suspending";
            var f = function() {
              a.state = "suspended", a._resumeAfterSuspend && (delete a._resumeAfterSuspend, a._autoResume());
            };
            a.ctx.suspend().then(f, f);
          }
        }, 3e4), a;
      }
    }, _autoResume: function() {
      var a = this;
      if (!(!a.ctx || typeof a.ctx.resume > "u" || !r.usingWebAudio))
        return a.state === "running" && a.ctx.state !== "interrupted" && a._suspendTimer ? (clearTimeout(a._suspendTimer), a._suspendTimer = null) : a.state === "suspended" || a.state === "running" && a.ctx.state === "interrupted" ? (a.ctx.resume().then(function() {
          a.state = "running";
          for (var d = 0; d < a._howls.length; d++)
            a._howls[d]._emit("resume");
        }), a._suspendTimer && (clearTimeout(a._suspendTimer), a._suspendTimer = null)) : a.state === "suspending" && (a._resumeAfterSuspend = true), a;
    } };
    var r = new n(), e = function(a) {
      var d = this;
      if (!a.src || a.src.length === 0) {
        console.error("An array of source files must be passed with any new Howl.");
        return;
      }
      d.init(a);
    };
    e.prototype = { init: function(a) {
      var d = this;
      return r.ctx || u(), d._autoplay = a.autoplay || false, d._format = typeof a.format != "string" ? a.format : [a.format], d._html5 = a.html5 || false, d._muted = a.mute || false, d._loop = a.loop || false, d._pool = a.pool || 5, d._preload = typeof a.preload == "boolean" || a.preload === "metadata" ? a.preload : true, d._rate = a.rate || 1, d._sprite = a.sprite || {}, d._src = typeof a.src != "string" ? a.src : [a.src], d._volume = a.volume !== void 0 ? a.volume : 1, d._xhr = { method: a.xhr && a.xhr.method ? a.xhr.method : "GET", headers: a.xhr && a.xhr.headers ? a.xhr.headers : null, withCredentials: a.xhr && a.xhr.withCredentials ? a.xhr.withCredentials : false }, d._duration = 0, d._state = "unloaded", d._sounds = [], d._endTimers = {}, d._queue = [], d._playLock = false, d._onend = a.onend ? [{ fn: a.onend }] : [], d._onfade = a.onfade ? [{ fn: a.onfade }] : [], d._onload = a.onload ? [{ fn: a.onload }] : [], d._onloaderror = a.onloaderror ? [{ fn: a.onloaderror }] : [], d._onplayerror = a.onplayerror ? [{ fn: a.onplayerror }] : [], d._onpause = a.onpause ? [{ fn: a.onpause }] : [], d._onplay = a.onplay ? [{ fn: a.onplay }] : [], d._onstop = a.onstop ? [{ fn: a.onstop }] : [], d._onmute = a.onmute ? [{ fn: a.onmute }] : [], d._onvolume = a.onvolume ? [{ fn: a.onvolume }] : [], d._onrate = a.onrate ? [{ fn: a.onrate }] : [], d._onseek = a.onseek ? [{ fn: a.onseek }] : [], d._onunlock = a.onunlock ? [{ fn: a.onunlock }] : [], d._onresume = [], d._webAudio = r.usingWebAudio && !d._html5, typeof r.ctx < "u" && r.ctx && r.autoUnlock && r._unlockAudio(), r._howls.push(d), d._autoplay && d._queue.push({ event: "play", action: function() {
        d.play();
      } }), d._preload && d._preload !== "none" && d.load(), d;
    }, load: function() {
      var a = this, d = null;
      if (r.noAudio) {
        a._emit("loaderror", null, "No audio support.");
        return;
      }
      typeof a._src == "string" && (a._src = [a._src]);
      for (var p = 0; p < a._src.length; p++) {
        var f, m;
        if (a._format && a._format[p])
          f = a._format[p];
        else {
          if (m = a._src[p], typeof m != "string") {
            a._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
            continue;
          }
          f = /^data:audio\/([^;,]+);/i.exec(m), f || (f = /\.([^.]+)$/.exec(m.split("?", 1)[0])), f && (f = f[1].toLowerCase());
        }
        if (f || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), f && r.codecs(f)) {
          d = a._src[p];
          break;
        }
      }
      if (!d) {
        a._emit("loaderror", null, "No codec support for selected audio sources.");
        return;
      }
      return a._src = d, a._state = "loading", window.location.protocol === "https:" && d.slice(0, 5) === "http:" && (a._html5 = true, a._webAudio = false), new t(a), a._webAudio && i(a), a;
    }, play: function(a, d) {
      var p = this, f = null;
      if (typeof a == "number")
        f = a, a = null;
      else {
        if (typeof a == "string" && p._state === "loaded" && !p._sprite[a])
          return null;
        if (typeof a > "u" && (a = "__default", !p._playLock)) {
          for (var m = 0, h = 0; h < p._sounds.length; h++)
            p._sounds[h]._paused && !p._sounds[h]._ended && (m++, f = p._sounds[h]._id);
          m === 1 ? a = null : f = null;
        }
      }
      var y = f ? p._soundById(f) : p._inactiveSound();
      if (!y)
        return null;
      if (f && !a && (a = y._sprite || "__default"), p._state !== "loaded") {
        y._sprite = a, y._ended = false;
        var g = y._id;
        return p._queue.push({ event: "play", action: function() {
          p.play(g);
        } }), g;
      }
      if (f && !y._paused)
        return d || p._loadQueue("play"), y._id;
      p._webAudio && r._autoResume();
      var v = Math.max(0, y._seek > 0 ? y._seek : p._sprite[a][0] / 1e3), b = Math.max(0, (p._sprite[a][0] + p._sprite[a][1]) / 1e3 - v), w = b * 1e3 / Math.abs(y._rate), S = p._sprite[a][0] / 1e3, P = (p._sprite[a][0] + p._sprite[a][1]) / 1e3;
      y._sprite = a, y._ended = false;
      var _ = function() {
        y._paused = false, y._seek = v, y._start = S, y._stop = P, y._loop = !!(y._loop || p._sprite[a][2]);
      };
      if (v >= P) {
        p._ended(y);
        return;
      }
      var x = y._node;
      if (p._webAudio) {
        var C = function() {
          p._playLock = false, _(), p._refreshBuffer(y);
          var A = y._muted || p._muted ? 0 : y._volume;
          x.gain.setValueAtTime(A, r.ctx.currentTime), y._playStart = r.ctx.currentTime, typeof x.bufferSource.start > "u" ? y._loop ? x.bufferSource.noteGrainOn(0, v, 86400) : x.bufferSource.noteGrainOn(0, v, b) : y._loop ? x.bufferSource.start(0, v, 86400) : x.bufferSource.start(0, v, b), w !== 1 / 0 && (p._endTimers[y._id] = setTimeout(p._ended.bind(p, y), w)), d || setTimeout(function() {
            p._emit("play", y._id), p._loadQueue();
          }, 0);
        };
        r.state === "running" && r.ctx.state !== "interrupted" ? C() : (p._playLock = true, p.once("resume", C), p._clearTimer(y._id));
      } else {
        var T = function() {
          x.currentTime = v, x.muted = y._muted || p._muted || r._muted || x.muted, x.volume = y._volume * r.volume(), x.playbackRate = y._rate;
          try {
            var A = x.play();
            if (A && typeof Promise < "u" && (A instanceof Promise || typeof A.then == "function") ? (p._playLock = true, _(), A.then(function() {
              p._playLock = false, x._unlocked = true, d ? p._loadQueue() : p._emit("play", y._id);
            }).catch(function() {
              p._playLock = false, p._emit("playerror", y._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), y._ended = true, y._paused = true;
            })) : d || (p._playLock = false, _(), p._emit("play", y._id)), x.playbackRate = y._rate, x.paused) {
              p._emit("playerror", y._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
              return;
            }
            a !== "__default" || y._loop ? p._endTimers[y._id] = setTimeout(p._ended.bind(p, y), w) : (p._endTimers[y._id] = function() {
              p._ended(y), x.removeEventListener("ended", p._endTimers[y._id], false);
            }, x.addEventListener("ended", p._endTimers[y._id], false));
          } catch (R) {
            p._emit("playerror", y._id, R);
          }
        };
        x.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" && (x.src = p._src, x.load());
        var N = window && window.ejecta || !x.readyState && r._navigator.isCocoonJS;
        if (x.readyState >= 3 || N)
          T();
        else {
          p._playLock = true, p._state = "loading";
          var O = function() {
            p._state = "loaded", T(), x.removeEventListener(r._canPlayEvent, O, false);
          };
          x.addEventListener(r._canPlayEvent, O, false), p._clearTimer(y._id);
        }
      }
      return y._id;
    }, pause: function(a) {
      var d = this;
      if (d._state !== "loaded" || d._playLock)
        return d._queue.push({ event: "pause", action: function() {
          d.pause(a);
        } }), d;
      for (var p = d._getSoundIds(a), f = 0; f < p.length; f++) {
        d._clearTimer(p[f]);
        var m = d._soundById(p[f]);
        if (m && !m._paused && (m._seek = d.seek(p[f]), m._rateSeek = 0, m._paused = true, d._stopFade(p[f]), m._node))
          if (d._webAudio) {
            if (!m._node.bufferSource)
              continue;
            typeof m._node.bufferSource.stop > "u" ? m._node.bufferSource.noteOff(0) : m._node.bufferSource.stop(0), d._cleanBuffer(m._node);
          } else
            (!isNaN(m._node.duration) || m._node.duration === 1 / 0) && m._node.pause();
        arguments[1] || d._emit("pause", m ? m._id : null);
      }
      return d;
    }, stop: function(a, d) {
      var p = this;
      if (p._state !== "loaded" || p._playLock)
        return p._queue.push({ event: "stop", action: function() {
          p.stop(a);
        } }), p;
      for (var f = p._getSoundIds(a), m = 0; m < f.length; m++) {
        p._clearTimer(f[m]);
        var h = p._soundById(f[m]);
        h && (h._seek = h._start || 0, h._rateSeek = 0, h._paused = true, h._ended = true, p._stopFade(f[m]), h._node && (p._webAudio ? h._node.bufferSource && (typeof h._node.bufferSource.stop > "u" ? h._node.bufferSource.noteOff(0) : h._node.bufferSource.stop(0), p._cleanBuffer(h._node)) : (!isNaN(h._node.duration) || h._node.duration === 1 / 0) && (h._node.currentTime = h._start || 0, h._node.pause(), h._node.duration === 1 / 0 && p._clearSound(h._node))), d || p._emit("stop", h._id));
      }
      return p;
    }, mute: function(a, d) {
      var p = this;
      if (p._state !== "loaded" || p._playLock)
        return p._queue.push({ event: "mute", action: function() {
          p.mute(a, d);
        } }), p;
      if (typeof d > "u")
        if (typeof a == "boolean")
          p._muted = a;
        else
          return p._muted;
      for (var f = p._getSoundIds(d), m = 0; m < f.length; m++) {
        var h = p._soundById(f[m]);
        h && (h._muted = a, h._interval && p._stopFade(h._id), p._webAudio && h._node ? h._node.gain.setValueAtTime(a ? 0 : h._volume, r.ctx.currentTime) : h._node && (h._node.muted = r._muted ? true : a), p._emit("mute", h._id));
      }
      return p;
    }, volume: function() {
      var a = this, d = arguments, p, f;
      if (d.length === 0)
        return a._volume;
      if (d.length === 1 || d.length === 2 && typeof d[1] > "u") {
        var m = a._getSoundIds(), h = m.indexOf(d[0]);
        h >= 0 ? f = parseInt(d[0], 10) : p = parseFloat(d[0]);
      } else
        d.length >= 2 && (p = parseFloat(d[0]), f = parseInt(d[1], 10));
      var y;
      if (typeof p < "u" && p >= 0 && p <= 1) {
        if (a._state !== "loaded" || a._playLock)
          return a._queue.push({ event: "volume", action: function() {
            a.volume.apply(a, d);
          } }), a;
        typeof f > "u" && (a._volume = p), f = a._getSoundIds(f);
        for (var g = 0; g < f.length; g++)
          y = a._soundById(f[g]), y && (y._volume = p, d[2] || a._stopFade(f[g]), a._webAudio && y._node && !y._muted ? y._node.gain.setValueAtTime(p, r.ctx.currentTime) : y._node && !y._muted && (y._node.volume = p * r.volume()), a._emit("volume", y._id));
      } else
        return y = f ? a._soundById(f) : a._sounds[0], y ? y._volume : 0;
      return a;
    }, fade: function(a, d, p, f) {
      var m = this;
      if (m._state !== "loaded" || m._playLock)
        return m._queue.push({ event: "fade", action: function() {
          m.fade(a, d, p, f);
        } }), m;
      a = Math.min(Math.max(0, parseFloat(a)), 1), d = Math.min(Math.max(0, parseFloat(d)), 1), p = parseFloat(p), m.volume(a, f);
      for (var h = m._getSoundIds(f), y = 0; y < h.length; y++) {
        var g = m._soundById(h[y]);
        if (g) {
          if (f || m._stopFade(h[y]), m._webAudio && !g._muted) {
            var v = r.ctx.currentTime, b = v + p / 1e3;
            g._volume = a, g._node.gain.setValueAtTime(a, v), g._node.gain.linearRampToValueAtTime(d, b);
          }
          m._startFadeInterval(g, a, d, p, h[y], typeof f > "u");
        }
      }
      return m;
    }, _startFadeInterval: function(a, d, p, f, m, h) {
      var y = this, g = d, v = p - d, b = Math.abs(v / 0.01), w = Math.max(4, b > 0 ? f / b : f), S = Date.now();
      a._fadeTo = p, a._interval = setInterval(function() {
        var P = (Date.now() - S) / f;
        S = Date.now(), g += v * P, g = Math.round(g * 100) / 100, v < 0 ? g = Math.max(p, g) : g = Math.min(p, g), y._webAudio ? a._volume = g : y.volume(g, a._id, true), h && (y._volume = g), (p < d && g <= p || p > d && g >= p) && (clearInterval(a._interval), a._interval = null, a._fadeTo = null, y.volume(p, a._id), y._emit("fade", a._id));
      }, w);
    }, _stopFade: function(a) {
      var d = this, p = d._soundById(a);
      return p && p._interval && (d._webAudio && p._node.gain.cancelScheduledValues(r.ctx.currentTime), clearInterval(p._interval), p._interval = null, d.volume(p._fadeTo, a), p._fadeTo = null, d._emit("fade", a)), d;
    }, loop: function() {
      var a = this, d = arguments, p, f, m;
      if (d.length === 0)
        return a._loop;
      if (d.length === 1)
        if (typeof d[0] == "boolean")
          p = d[0], a._loop = p;
        else
          return m = a._soundById(parseInt(d[0], 10)), m ? m._loop : false;
      else
        d.length === 2 && (p = d[0], f = parseInt(d[1], 10));
      for (var h = a._getSoundIds(f), y = 0; y < h.length; y++)
        m = a._soundById(h[y]), m && (m._loop = p, a._webAudio && m._node && m._node.bufferSource && (m._node.bufferSource.loop = p, p && (m._node.bufferSource.loopStart = m._start || 0, m._node.bufferSource.loopEnd = m._stop, a.playing(h[y]) && (a.pause(h[y], true), a.play(h[y], true)))));
      return a;
    }, rate: function() {
      var a = this, d = arguments, p, f;
      if (d.length === 0)
        f = a._sounds[0]._id;
      else if (d.length === 1) {
        var m = a._getSoundIds(), h = m.indexOf(d[0]);
        h >= 0 ? f = parseInt(d[0], 10) : p = parseFloat(d[0]);
      } else
        d.length === 2 && (p = parseFloat(d[0]), f = parseInt(d[1], 10));
      var y;
      if (typeof p == "number") {
        if (a._state !== "loaded" || a._playLock)
          return a._queue.push({ event: "rate", action: function() {
            a.rate.apply(a, d);
          } }), a;
        typeof f > "u" && (a._rate = p), f = a._getSoundIds(f);
        for (var g = 0; g < f.length; g++)
          if (y = a._soundById(f[g]), y) {
            a.playing(f[g]) && (y._rateSeek = a.seek(f[g]), y._playStart = a._webAudio ? r.ctx.currentTime : y._playStart), y._rate = p, a._webAudio && y._node && y._node.bufferSource ? y._node.bufferSource.playbackRate.setValueAtTime(p, r.ctx.currentTime) : y._node && (y._node.playbackRate = p);
            var v = a.seek(f[g]), b = (a._sprite[y._sprite][0] + a._sprite[y._sprite][1]) / 1e3 - v, w = b * 1e3 / Math.abs(y._rate);
            (a._endTimers[f[g]] || !y._paused) && (a._clearTimer(f[g]), a._endTimers[f[g]] = setTimeout(a._ended.bind(a, y), w)), a._emit("rate", y._id);
          }
      } else
        return y = a._soundById(f), y ? y._rate : a._rate;
      return a;
    }, seek: function() {
      var a = this, d = arguments, p, f;
      if (d.length === 0)
        a._sounds.length && (f = a._sounds[0]._id);
      else if (d.length === 1) {
        var m = a._getSoundIds(), h = m.indexOf(d[0]);
        h >= 0 ? f = parseInt(d[0], 10) : a._sounds.length && (f = a._sounds[0]._id, p = parseFloat(d[0]));
      } else
        d.length === 2 && (p = parseFloat(d[0]), f = parseInt(d[1], 10));
      if (typeof f > "u")
        return 0;
      if (typeof p == "number" && (a._state !== "loaded" || a._playLock))
        return a._queue.push({ event: "seek", action: function() {
          a.seek.apply(a, d);
        } }), a;
      var y = a._soundById(f);
      if (y)
        if (typeof p == "number" && p >= 0) {
          var g = a.playing(f);
          g && a.pause(f, true), y._seek = p, y._ended = false, a._clearTimer(f), !a._webAudio && y._node && !isNaN(y._node.duration) && (y._node.currentTime = p);
          var v = function() {
            g && a.play(f, true), a._emit("seek", f);
          };
          if (g && !a._webAudio) {
            var b = function() {
              a._playLock ? setTimeout(b, 0) : v();
            };
            setTimeout(b, 0);
          } else
            v();
        } else if (a._webAudio) {
          var w = a.playing(f) ? r.ctx.currentTime - y._playStart : 0, S = y._rateSeek ? y._rateSeek - y._seek : 0;
          return y._seek + (S + w * Math.abs(y._rate));
        } else
          return y._node.currentTime;
      return a;
    }, playing: function(a) {
      var d = this;
      if (typeof a == "number") {
        var p = d._soundById(a);
        return p ? !p._paused : false;
      }
      for (var f = 0; f < d._sounds.length; f++)
        if (!d._sounds[f]._paused)
          return true;
      return false;
    }, duration: function(a) {
      var d = this, p = d._duration, f = d._soundById(a);
      return f && (p = d._sprite[f._sprite][1] / 1e3), p;
    }, state: function() {
      return this._state;
    }, unload: function() {
      for (var a = this, d = a._sounds, p = 0; p < d.length; p++)
        d[p]._paused || a.stop(d[p]._id), a._webAudio || (a._clearSound(d[p]._node), d[p]._node.removeEventListener("error", d[p]._errorFn, false), d[p]._node.removeEventListener(r._canPlayEvent, d[p]._loadFn, false), d[p]._node.removeEventListener("ended", d[p]._endFn, false), r._releaseHtml5Audio(d[p]._node)), delete d[p]._node, a._clearTimer(d[p]._id);
      var f = r._howls.indexOf(a);
      f >= 0 && r._howls.splice(f, 1);
      var m = true;
      for (p = 0; p < r._howls.length; p++)
        if (r._howls[p]._src === a._src || a._src.indexOf(r._howls[p]._src) >= 0) {
          m = false;
          break;
        }
      return o && m && delete o[a._src], r.noAudio = false, a._state = "unloaded", a._sounds = [], a = null, null;
    }, on: function(a, d, p, f) {
      var m = this, h = m["_on" + a];
      return typeof d == "function" && h.push(f ? { id: p, fn: d, once: f } : { id: p, fn: d }), m;
    }, off: function(a, d, p) {
      var f = this, m = f["_on" + a], h = 0;
      if (typeof d == "number" && (p = d, d = null), d || p)
        for (h = 0; h < m.length; h++) {
          var y = p === m[h].id;
          if (d === m[h].fn && y || !d && y) {
            m.splice(h, 1);
            break;
          }
        }
      else if (a)
        f["_on" + a] = [];
      else {
        var g = Object.keys(f);
        for (h = 0; h < g.length; h++)
          g[h].indexOf("_on") === 0 && Array.isArray(f[g[h]]) && (f[g[h]] = []);
      }
      return f;
    }, once: function(a, d, p) {
      var f = this;
      return f.on(a, d, p, 1), f;
    }, _emit: function(a, d, p) {
      for (var f = this, m = f["_on" + a], h = m.length - 1; h >= 0; h--)
        (!m[h].id || m[h].id === d || a === "load") && (setTimeout(function(y) {
          y.call(this, d, p);
        }.bind(f, m[h].fn), 0), m[h].once && f.off(a, m[h].fn, m[h].id));
      return f._loadQueue(a), f;
    }, _loadQueue: function(a) {
      var d = this;
      if (d._queue.length > 0) {
        var p = d._queue[0];
        p.event === a && (d._queue.shift(), d._loadQueue()), a || p.action();
      }
      return d;
    }, _ended: function(a) {
      var d = this, p = a._sprite;
      if (!d._webAudio && a._node && !a._node.paused && !a._node.ended && a._node.currentTime < a._stop)
        return setTimeout(d._ended.bind(d, a), 100), d;
      var f = !!(a._loop || d._sprite[p][2]);
      if (d._emit("end", a._id), !d._webAudio && f && d.stop(a._id, true).play(a._id), d._webAudio && f) {
        d._emit("play", a._id), a._seek = a._start || 0, a._rateSeek = 0, a._playStart = r.ctx.currentTime;
        var m = (a._stop - a._start) * 1e3 / Math.abs(a._rate);
        d._endTimers[a._id] = setTimeout(d._ended.bind(d, a), m);
      }
      return d._webAudio && !f && (a._paused = true, a._ended = true, a._seek = a._start || 0, a._rateSeek = 0, d._clearTimer(a._id), d._cleanBuffer(a._node), r._autoSuspend()), !d._webAudio && !f && d.stop(a._id, true), d;
    }, _clearTimer: function(a) {
      var d = this;
      if (d._endTimers[a]) {
        if (typeof d._endTimers[a] != "function")
          clearTimeout(d._endTimers[a]);
        else {
          var p = d._soundById(a);
          p && p._node && p._node.removeEventListener("ended", d._endTimers[a], false);
        }
        delete d._endTimers[a];
      }
      return d;
    }, _soundById: function(a) {
      for (var d = this, p = 0; p < d._sounds.length; p++)
        if (a === d._sounds[p]._id)
          return d._sounds[p];
      return null;
    }, _inactiveSound: function() {
      var a = this;
      a._drain();
      for (var d = 0; d < a._sounds.length; d++)
        if (a._sounds[d]._ended)
          return a._sounds[d].reset();
      return new t(a);
    }, _drain: function() {
      var a = this, d = a._pool, p = 0, f = 0;
      if (!(a._sounds.length < d)) {
        for (f = 0; f < a._sounds.length; f++)
          a._sounds[f]._ended && p++;
        for (f = a._sounds.length - 1; f >= 0; f--) {
          if (p <= d)
            return;
          a._sounds[f]._ended && (a._webAudio && a._sounds[f]._node && a._sounds[f]._node.disconnect(0), a._sounds.splice(f, 1), p--);
        }
      }
    }, _getSoundIds: function(a) {
      var d = this;
      if (typeof a > "u") {
        for (var p = [], f = 0; f < d._sounds.length; f++)
          p.push(d._sounds[f]._id);
        return p;
      } else
        return [a];
    }, _refreshBuffer: function(a) {
      var d = this;
      return a._node.bufferSource = r.ctx.createBufferSource(), a._node.bufferSource.buffer = o[d._src], a._panner ? a._node.bufferSource.connect(a._panner) : a._node.bufferSource.connect(a._node), a._node.bufferSource.loop = a._loop, a._loop && (a._node.bufferSource.loopStart = a._start || 0, a._node.bufferSource.loopEnd = a._stop || 0), a._node.bufferSource.playbackRate.setValueAtTime(a._rate, r.ctx.currentTime), d;
    }, _cleanBuffer: function(a) {
      var d = this, p = r._navigator && r._navigator.vendor.indexOf("Apple") >= 0;
      if (r._scratchBuffer && a.bufferSource && (a.bufferSource.onended = null, a.bufferSource.disconnect(0), p))
        try {
          a.bufferSource.buffer = r._scratchBuffer;
        } catch {
        }
      return a.bufferSource = null, d;
    }, _clearSound: function(a) {
      var d = /MSIE |Trident\//.test(r._navigator && r._navigator.userAgent);
      d || (a.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
    } };
    var t = function(a) {
      this._parent = a, this.init();
    };
    t.prototype = { init: function() {
      var a = this, d = a._parent;
      return a._muted = d._muted, a._loop = d._loop, a._volume = d._volume, a._rate = d._rate, a._seek = 0, a._paused = true, a._ended = true, a._sprite = "__default", a._id = ++r._counter, d._sounds.push(a), a.create(), a;
    }, create: function() {
      var a = this, d = a._parent, p = r._muted || a._muted || a._parent._muted ? 0 : a._volume;
      return d._webAudio ? (a._node = typeof r.ctx.createGain > "u" ? r.ctx.createGainNode() : r.ctx.createGain(), a._node.gain.setValueAtTime(p, r.ctx.currentTime), a._node.paused = true, a._node.connect(r.masterGain)) : r.noAudio || (a._node = r._obtainHtml5Audio(), a._errorFn = a._errorListener.bind(a), a._node.addEventListener("error", a._errorFn, false), a._loadFn = a._loadListener.bind(a), a._node.addEventListener(r._canPlayEvent, a._loadFn, false), a._endFn = a._endListener.bind(a), a._node.addEventListener("ended", a._endFn, false), a._node.src = d._src, a._node.preload = d._preload === true ? "auto" : d._preload, a._node.volume = p * r.volume(), a._node.load()), a;
    }, reset: function() {
      var a = this, d = a._parent;
      return a._muted = d._muted, a._loop = d._loop, a._volume = d._volume, a._rate = d._rate, a._seek = 0, a._rateSeek = 0, a._paused = true, a._ended = true, a._sprite = "__default", a._id = ++r._counter, a;
    }, _errorListener: function() {
      var a = this;
      a._parent._emit("loaderror", a._id, a._node.error ? a._node.error.code : 0), a._node.removeEventListener("error", a._errorFn, false);
    }, _loadListener: function() {
      var a = this, d = a._parent;
      d._duration = Math.ceil(a._node.duration * 10) / 10, Object.keys(d._sprite).length === 0 && (d._sprite = { __default: [0, d._duration * 1e3] }), d._state !== "loaded" && (d._state = "loaded", d._emit("load"), d._loadQueue()), a._node.removeEventListener(r._canPlayEvent, a._loadFn, false);
    }, _endListener: function() {
      var a = this, d = a._parent;
      d._duration === 1 / 0 && (d._duration = Math.ceil(a._node.duration * 10) / 10, d._sprite.__default[1] === 1 / 0 && (d._sprite.__default[1] = d._duration * 1e3), d._ended(a)), a._node.removeEventListener("ended", a._endFn, false);
    } };
    var o = {}, i = function(a) {
      var d = a._src;
      if (o[d]) {
        a._duration = o[d].duration, c(a);
        return;
      }
      if (/^data:[^;]+;base64,/.test(d)) {
        for (var p = atob(d.split(",")[1]), f = new Uint8Array(p.length), m = 0; m < p.length; ++m)
          f[m] = p.charCodeAt(m);
        l(f.buffer, a);
      } else {
        var h = new XMLHttpRequest();
        h.open(a._xhr.method, d, true), h.withCredentials = a._xhr.withCredentials, h.responseType = "arraybuffer", a._xhr.headers && Object.keys(a._xhr.headers).forEach(function(y) {
          h.setRequestHeader(y, a._xhr.headers[y]);
        }), h.onload = function() {
          var y = (h.status + "")[0];
          if (y !== "0" && y !== "2" && y !== "3") {
            a._emit("loaderror", null, "Failed loading audio file with status: " + h.status + ".");
            return;
          }
          l(h.response, a);
        }, h.onerror = function() {
          a._webAudio && (a._html5 = true, a._webAudio = false, a._sounds = [], delete o[d], a.load());
        }, s(h);
      }
    }, s = function(a) {
      try {
        a.send();
      } catch {
        a.onerror();
      }
    }, l = function(a, d) {
      var p = function() {
        d._emit("loaderror", null, "Decoding audio data failed.");
      }, f = function(m) {
        m && d._sounds.length > 0 ? (o[d._src] = m, c(d, m)) : p();
      };
      typeof Promise < "u" && r.ctx.decodeAudioData.length === 1 ? r.ctx.decodeAudioData(a).then(f).catch(p) : r.ctx.decodeAudioData(a, f, p);
    }, c = function(a, d) {
      d && !a._duration && (a._duration = d.duration), Object.keys(a._sprite).length === 0 && (a._sprite = { __default: [0, a._duration * 1e3] }), a._state !== "loaded" && (a._state = "loaded", a._emit("load"), a._loadQueue());
    }, u = function() {
      if (!!r.usingWebAudio) {
        try {
          typeof AudioContext < "u" ? r.ctx = new AudioContext() : typeof webkitAudioContext < "u" ? r.ctx = new webkitAudioContext() : r.usingWebAudio = false;
        } catch {
          r.usingWebAudio = false;
        }
        r.ctx || (r.usingWebAudio = false);
        var a = /iP(hone|od|ad)/.test(r._navigator && r._navigator.platform), d = r._navigator && r._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/), p = d ? parseInt(d[1], 10) : null;
        if (a && p && p < 9) {
          var f = /safari/.test(r._navigator && r._navigator.userAgent.toLowerCase());
          r._navigator && !f && (r.usingWebAudio = false);
        }
        r.usingWebAudio && (r.masterGain = typeof r.ctx.createGain > "u" ? r.ctx.createGainNode() : r.ctx.createGain(), r.masterGain.gain.setValueAtTime(r._muted ? 0 : r._volume, r.ctx.currentTime), r.masterGain.connect(r.ctx.destination)), r._setup();
      }
    };
    typeof define == "function" && define.amd && define([], function() {
      return { Howler: r, Howl: e };
    }), typeof El < "u" && (El.Howler = r, El.Howl = e), typeof global < "u" ? (global.HowlerGlobal = n, global.Howler = r, global.Howl = e, global.Sound = t) : typeof window < "u" && (window.HowlerGlobal = n, window.Howler = r, window.Howl = e, window.Sound = t);
  })();
  (function() {
    "use strict";
    HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(r) {
      var e = this;
      if (!e.ctx || !e.ctx.listener)
        return e;
      for (var t = e._howls.length - 1; t >= 0; t--)
        e._howls[t].stereo(r);
      return e;
    }, HowlerGlobal.prototype.pos = function(r, e, t) {
      var o = this;
      if (!o.ctx || !o.ctx.listener)
        return o;
      if (e = typeof e != "number" ? o._pos[1] : e, t = typeof t != "number" ? o._pos[2] : t, typeof r == "number")
        o._pos = [r, e, t], typeof o.ctx.listener.positionX < "u" ? (o.ctx.listener.positionX.setTargetAtTime(o._pos[0], Howler.ctx.currentTime, 0.1), o.ctx.listener.positionY.setTargetAtTime(o._pos[1], Howler.ctx.currentTime, 0.1), o.ctx.listener.positionZ.setTargetAtTime(o._pos[2], Howler.ctx.currentTime, 0.1)) : o.ctx.listener.setPosition(o._pos[0], o._pos[1], o._pos[2]);
      else
        return o._pos;
      return o;
    }, HowlerGlobal.prototype.orientation = function(r, e, t, o, i, s) {
      var l = this;
      if (!l.ctx || !l.ctx.listener)
        return l;
      var c = l._orientation;
      if (e = typeof e != "number" ? c[1] : e, t = typeof t != "number" ? c[2] : t, o = typeof o != "number" ? c[3] : o, i = typeof i != "number" ? c[4] : i, s = typeof s != "number" ? c[5] : s, typeof r == "number")
        l._orientation = [r, e, t, o, i, s], typeof l.ctx.listener.forwardX < "u" ? (l.ctx.listener.forwardX.setTargetAtTime(r, Howler.ctx.currentTime, 0.1), l.ctx.listener.forwardY.setTargetAtTime(e, Howler.ctx.currentTime, 0.1), l.ctx.listener.forwardZ.setTargetAtTime(t, Howler.ctx.currentTime, 0.1), l.ctx.listener.upX.setTargetAtTime(o, Howler.ctx.currentTime, 0.1), l.ctx.listener.upY.setTargetAtTime(i, Howler.ctx.currentTime, 0.1), l.ctx.listener.upZ.setTargetAtTime(s, Howler.ctx.currentTime, 0.1)) : l.ctx.listener.setOrientation(r, e, t, o, i, s);
      else
        return c;
      return l;
    }, Howl.prototype.init = function(r) {
      return function(e) {
        var t = this;
        return t._orientation = e.orientation || [1, 0, 0], t._stereo = e.stereo || null, t._pos = e.pos || null, t._pannerAttr = { coneInnerAngle: typeof e.coneInnerAngle < "u" ? e.coneInnerAngle : 360, coneOuterAngle: typeof e.coneOuterAngle < "u" ? e.coneOuterAngle : 360, coneOuterGain: typeof e.coneOuterGain < "u" ? e.coneOuterGain : 0, distanceModel: typeof e.distanceModel < "u" ? e.distanceModel : "inverse", maxDistance: typeof e.maxDistance < "u" ? e.maxDistance : 1e4, panningModel: typeof e.panningModel < "u" ? e.panningModel : "HRTF", refDistance: typeof e.refDistance < "u" ? e.refDistance : 1, rolloffFactor: typeof e.rolloffFactor < "u" ? e.rolloffFactor : 1 }, t._onstereo = e.onstereo ? [{ fn: e.onstereo }] : [], t._onpos = e.onpos ? [{ fn: e.onpos }] : [], t._onorientation = e.onorientation ? [{ fn: e.onorientation }] : [], r.call(this, e);
      };
    }(Howl.prototype.init), Howl.prototype.stereo = function(r, e) {
      var t = this;
      if (!t._webAudio)
        return t;
      if (t._state !== "loaded")
        return t._queue.push({ event: "stereo", action: function() {
          t.stereo(r, e);
        } }), t;
      var o = typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
      if (typeof e > "u")
        if (typeof r == "number")
          t._stereo = r, t._pos = [r, 0, 0];
        else
          return t._stereo;
      for (var i = t._getSoundIds(e), s = 0; s < i.length; s++) {
        var l = t._soundById(i[s]);
        if (l)
          if (typeof r == "number")
            l._stereo = r, l._pos = [r, 0, 0], l._node && (l._pannerAttr.panningModel = "equalpower", (!l._panner || !l._panner.pan) && n(l, o), o === "spatial" ? typeof l._panner.positionX < "u" ? (l._panner.positionX.setValueAtTime(r, Howler.ctx.currentTime), l._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), l._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : l._panner.setPosition(r, 0, 0) : l._panner.pan.setValueAtTime(r, Howler.ctx.currentTime)), t._emit("stereo", l._id);
          else
            return l._stereo;
      }
      return t;
    }, Howl.prototype.pos = function(r, e, t, o) {
      var i = this;
      if (!i._webAudio)
        return i;
      if (i._state !== "loaded")
        return i._queue.push({ event: "pos", action: function() {
          i.pos(r, e, t, o);
        } }), i;
      if (e = typeof e != "number" ? 0 : e, t = typeof t != "number" ? -0.5 : t, typeof o > "u")
        if (typeof r == "number")
          i._pos = [r, e, t];
        else
          return i._pos;
      for (var s = i._getSoundIds(o), l = 0; l < s.length; l++) {
        var c = i._soundById(s[l]);
        if (c)
          if (typeof r == "number")
            c._pos = [r, e, t], c._node && ((!c._panner || c._panner.pan) && n(c, "spatial"), typeof c._panner.positionX < "u" ? (c._panner.positionX.setValueAtTime(r, Howler.ctx.currentTime), c._panner.positionY.setValueAtTime(e, Howler.ctx.currentTime), c._panner.positionZ.setValueAtTime(t, Howler.ctx.currentTime)) : c._panner.setPosition(r, e, t)), i._emit("pos", c._id);
          else
            return c._pos;
      }
      return i;
    }, Howl.prototype.orientation = function(r, e, t, o) {
      var i = this;
      if (!i._webAudio)
        return i;
      if (i._state !== "loaded")
        return i._queue.push({ event: "orientation", action: function() {
          i.orientation(r, e, t, o);
        } }), i;
      if (e = typeof e != "number" ? i._orientation[1] : e, t = typeof t != "number" ? i._orientation[2] : t, typeof o > "u")
        if (typeof r == "number")
          i._orientation = [r, e, t];
        else
          return i._orientation;
      for (var s = i._getSoundIds(o), l = 0; l < s.length; l++) {
        var c = i._soundById(s[l]);
        if (c)
          if (typeof r == "number")
            c._orientation = [r, e, t], c._node && (c._panner || (c._pos || (c._pos = i._pos || [0, 0, -0.5]), n(c, "spatial")), typeof c._panner.orientationX < "u" ? (c._panner.orientationX.setValueAtTime(r, Howler.ctx.currentTime), c._panner.orientationY.setValueAtTime(e, Howler.ctx.currentTime), c._panner.orientationZ.setValueAtTime(t, Howler.ctx.currentTime)) : c._panner.setOrientation(r, e, t)), i._emit("orientation", c._id);
          else
            return c._orientation;
      }
      return i;
    }, Howl.prototype.pannerAttr = function() {
      var r = this, e = arguments, t, o, i;
      if (!r._webAudio)
        return r;
      if (e.length === 0)
        return r._pannerAttr;
      if (e.length === 1)
        if (typeof e[0] == "object")
          t = e[0], typeof o > "u" && (t.pannerAttr || (t.pannerAttr = { coneInnerAngle: t.coneInnerAngle, coneOuterAngle: t.coneOuterAngle, coneOuterGain: t.coneOuterGain, distanceModel: t.distanceModel, maxDistance: t.maxDistance, refDistance: t.refDistance, rolloffFactor: t.rolloffFactor, panningModel: t.panningModel }), r._pannerAttr = { coneInnerAngle: typeof t.pannerAttr.coneInnerAngle < "u" ? t.pannerAttr.coneInnerAngle : r._coneInnerAngle, coneOuterAngle: typeof t.pannerAttr.coneOuterAngle < "u" ? t.pannerAttr.coneOuterAngle : r._coneOuterAngle, coneOuterGain: typeof t.pannerAttr.coneOuterGain < "u" ? t.pannerAttr.coneOuterGain : r._coneOuterGain, distanceModel: typeof t.pannerAttr.distanceModel < "u" ? t.pannerAttr.distanceModel : r._distanceModel, maxDistance: typeof t.pannerAttr.maxDistance < "u" ? t.pannerAttr.maxDistance : r._maxDistance, refDistance: typeof t.pannerAttr.refDistance < "u" ? t.pannerAttr.refDistance : r._refDistance, rolloffFactor: typeof t.pannerAttr.rolloffFactor < "u" ? t.pannerAttr.rolloffFactor : r._rolloffFactor, panningModel: typeof t.pannerAttr.panningModel < "u" ? t.pannerAttr.panningModel : r._panningModel });
        else
          return i = r._soundById(parseInt(e[0], 10)), i ? i._pannerAttr : r._pannerAttr;
      else
        e.length === 2 && (t = e[0], o = parseInt(e[1], 10));
      for (var s = r._getSoundIds(o), l = 0; l < s.length; l++)
        if (i = r._soundById(s[l]), i) {
          var c = i._pannerAttr;
          c = { coneInnerAngle: typeof t.coneInnerAngle < "u" ? t.coneInnerAngle : c.coneInnerAngle, coneOuterAngle: typeof t.coneOuterAngle < "u" ? t.coneOuterAngle : c.coneOuterAngle, coneOuterGain: typeof t.coneOuterGain < "u" ? t.coneOuterGain : c.coneOuterGain, distanceModel: typeof t.distanceModel < "u" ? t.distanceModel : c.distanceModel, maxDistance: typeof t.maxDistance < "u" ? t.maxDistance : c.maxDistance, refDistance: typeof t.refDistance < "u" ? t.refDistance : c.refDistance, rolloffFactor: typeof t.rolloffFactor < "u" ? t.rolloffFactor : c.rolloffFactor, panningModel: typeof t.panningModel < "u" ? t.panningModel : c.panningModel };
          var u = i._panner;
          u ? (u.coneInnerAngle = c.coneInnerAngle, u.coneOuterAngle = c.coneOuterAngle, u.coneOuterGain = c.coneOuterGain, u.distanceModel = c.distanceModel, u.maxDistance = c.maxDistance, u.refDistance = c.refDistance, u.rolloffFactor = c.rolloffFactor, u.panningModel = c.panningModel) : (i._pos || (i._pos = r._pos || [0, 0, -0.5]), n(i, "spatial"));
        }
      return r;
    }, Sound.prototype.init = function(r) {
      return function() {
        var e = this, t = e._parent;
        e._orientation = t._orientation, e._stereo = t._stereo, e._pos = t._pos, e._pannerAttr = t._pannerAttr, r.call(this), e._stereo ? t.stereo(e._stereo) : e._pos && t.pos(e._pos[0], e._pos[1], e._pos[2], e._id);
      };
    }(Sound.prototype.init), Sound.prototype.reset = function(r) {
      return function() {
        var e = this, t = e._parent;
        return e._orientation = t._orientation, e._stereo = t._stereo, e._pos = t._pos, e._pannerAttr = t._pannerAttr, e._stereo ? t.stereo(e._stereo) : e._pos ? t.pos(e._pos[0], e._pos[1], e._pos[2], e._id) : e._panner && (e._panner.disconnect(0), e._panner = void 0, t._refreshBuffer(e)), r.call(this);
      };
    }(Sound.prototype.reset);
    var n = function(r, e) {
      e = e || "spatial", e === "spatial" ? (r._panner = Howler.ctx.createPanner(), r._panner.coneInnerAngle = r._pannerAttr.coneInnerAngle, r._panner.coneOuterAngle = r._pannerAttr.coneOuterAngle, r._panner.coneOuterGain = r._pannerAttr.coneOuterGain, r._panner.distanceModel = r._pannerAttr.distanceModel, r._panner.maxDistance = r._pannerAttr.maxDistance, r._panner.refDistance = r._pannerAttr.refDistance, r._panner.rolloffFactor = r._pannerAttr.rolloffFactor, r._panner.panningModel = r._pannerAttr.panningModel, typeof r._panner.positionX < "u" ? (r._panner.positionX.setValueAtTime(r._pos[0], Howler.ctx.currentTime), r._panner.positionY.setValueAtTime(r._pos[1], Howler.ctx.currentTime), r._panner.positionZ.setValueAtTime(r._pos[2], Howler.ctx.currentTime)) : r._panner.setPosition(r._pos[0], r._pos[1], r._pos[2]), typeof r._panner.orientationX < "u" ? (r._panner.orientationX.setValueAtTime(r._orientation[0], Howler.ctx.currentTime), r._panner.orientationY.setValueAtTime(r._orientation[1], Howler.ctx.currentTime), r._panner.orientationZ.setValueAtTime(r._orientation[2], Howler.ctx.currentTime)) : r._panner.setOrientation(r._orientation[0], r._orientation[1], r._orientation[2])) : (r._panner = Howler.ctx.createStereoPanner(), r._panner.pan.setValueAtTime(r._stereo, Howler.ctx.currentTime)), r._panner.connect(r._node), r._paused || r._parent.pause(r._id, true).play(r._id, true);
    };
  })();
});
var Jg = qs((UK, Qg) => {
  Qg.exports = function(r, e) {
    for (var t = r.split("."), o = e.split("."), i = 0; i < 3; i++) {
      var s = Number(t[i]), l = Number(o[i]);
      if (s > l)
        return 1;
      if (l > s)
        return -1;
      if (!isNaN(s) && isNaN(l))
        return 1;
      if (isNaN(s) && !isNaN(l))
        return -1;
    }
    return 0;
  };
});
function Su(n) {
  for (let r of Object.keys(n))
    n[r] === void 0 && delete n[r];
  return n;
}
function Vr(n, r) {
  return Object.setPrototypeOf(n, r), n;
}
function $s(n) {
  return Array.isArray(n) ? n : [n];
}
function wu(n, r) {
  let e = 0;
  for (; e < n.length && e < r.length; ) {
    if (n[e] < r[e])
      return -1;
    if (n[e] > r[e])
      return 1;
    e += 1;
  }
  return e !== r.length ? -1 : e !== n.length ? 1 : 0;
}
var g0 = typeof global == "object" && global && global.Object === Object && global;
var Ys = g0;
var x0 = typeof self == "object" && self && self.Object === Object && self;
var v0 = Ys || x0 || Function("return this")();
var We = v0;
var b0 = We.Symbol;
var Ze = b0;
var _u = Object.prototype;
var S0 = _u.hasOwnProperty;
var w0 = _u.toString;
var ji = Ze ? Ze.toStringTag : void 0;
function _0(n) {
  var r = S0.call(n, ji), e = n[ji];
  try {
    n[ji] = void 0;
    var t = true;
  } catch {
  }
  var o = w0.call(n);
  return t && (r ? n[ji] = e : delete n[ji]), o;
}
var Pu = _0;
var P0 = Object.prototype;
var T0 = P0.toString;
function O0(n) {
  return T0.call(n);
}
var Tu = O0;
var A0 = "[object Null]";
var N0 = "[object Undefined]";
var Ou = Ze ? Ze.toStringTag : void 0;
function C0(n) {
  return n == null ? n === void 0 ? N0 : A0 : Ou && Ou in Object(n) ? Pu(n) : Tu(n);
}
var Lt = C0;
function I0(n) {
  return n != null && typeof n == "object";
}
var at = I0;
var M0 = "[object Symbol]";
function E0(n) {
  return typeof n == "symbol" || at(n) && Lt(n) == M0;
}
var Ko = E0;
function L0(n, r) {
  for (var e = -1, t = n == null ? 0 : n.length, o = Array(t); ++e < t; )
    o[e] = r(n[e], e, n);
  return o;
}
var Xs = L0;
var B0 = Array.isArray;
var Ve = B0;
var D0 = 1 / 0;
var Au = Ze ? Ze.prototype : void 0;
var Nu = Au ? Au.toString : void 0;
function Cu(n) {
  if (typeof n == "string")
    return n;
  if (Ve(n))
    return Xs(n, Cu) + "";
  if (Ko(n))
    return Nu ? Nu.call(n) : "";
  var r = n + "";
  return r == "0" && 1 / n == -D0 ? "-0" : r;
}
var Iu = Cu;
function G0(n) {
  var r = typeof n;
  return n != null && (r == "object" || r == "function");
}
var Bt = G0;
function R0(n) {
  return n;
}
var Mu = R0;
var V0 = "[object AsyncFunction]";
var z0 = "[object Function]";
var j0 = "[object GeneratorFunction]";
var F0 = "[object Proxy]";
function k0(n) {
  if (!Bt(n))
    return false;
  var r = Lt(n);
  return r == z0 || r == j0 || r == V0 || r == F0;
}
var Ks = k0;
var U0 = We["__core-js_shared__"];
var Zs = U0;
var Eu = function() {
  var n = /[^.]+$/.exec(Zs && Zs.keys && Zs.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function H0(n) {
  return !!Eu && Eu in n;
}
var Lu = H0;
var q0 = Function.prototype;
var W0 = q0.toString;
function $0(n) {
  if (n != null) {
    try {
      return W0.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var zr = $0;
var Y0 = /[\\^$.*+?()[\]{}|]/g;
var X0 = /^\[object .+?Constructor\]$/;
var K0 = Function.prototype;
var Z0 = Object.prototype;
var Q0 = K0.toString;
var J0 = Z0.hasOwnProperty;
var ex = RegExp("^" + Q0.call(J0).replace(Y0, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function tx(n) {
  if (!Bt(n) || Lu(n))
    return false;
  var r = Ks(n) ? ex : X0;
  return r.test(zr(n));
}
var Bu = tx;
function rx(n, r) {
  return n == null ? void 0 : n[r];
}
var Du = rx;
function ox(n, r) {
  var e = Du(n, r);
  return Bu(e) ? e : void 0;
}
var Pt = ox;
var nx = Pt(We, "WeakMap");
var Qs = nx;
var Gu = Object.create;
var ix = function() {
  function n() {
  }
  return function(r) {
    if (!Bt(r))
      return {};
    if (Gu)
      return Gu(r);
    n.prototype = r;
    var e = new n();
    return n.prototype = void 0, e;
  };
}();
var Ru = ix;
function sx(n, r, e) {
  switch (e.length) {
    case 0:
      return n.call(r);
    case 1:
      return n.call(r, e[0]);
    case 2:
      return n.call(r, e[0], e[1]);
    case 3:
      return n.call(r, e[0], e[1], e[2]);
  }
  return n.apply(r, e);
}
var Vu = sx;
function ax(n, r) {
  var e = -1, t = n.length;
  for (r || (r = Array(t)); ++e < t; )
    r[e] = n[e];
  return r;
}
var zu = ax;
var lx = 800;
var cx = 16;
var dx = Date.now;
function ux(n) {
  var r = 0, e = 0;
  return function() {
    var t = dx(), o = cx - (t - e);
    if (e = t, o > 0) {
      if (++r >= lx)
        return arguments[0];
    } else
      r = 0;
    return n.apply(void 0, arguments);
  };
}
var ju = ux;
function px(n) {
  return function() {
    return n;
  };
}
var Fu = px;
var fx = function() {
  try {
    var n = Pt(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}();
var Zo = fx;
var mx = Zo ? function(n, r) {
  return Zo(n, "toString", { configurable: true, enumerable: false, value: Fu(r), writable: true });
} : Mu;
var ku = mx;
var hx = ju(ku);
var Uu = hx;
function yx(n, r) {
  for (var e = -1, t = n == null ? 0 : n.length; ++e < t && r(n[e], e, n) !== false; )
    ;
  return n;
}
var Hu = yx;
var gx = 9007199254740991;
var xx = /^(?:0|[1-9]\d*)$/;
function vx(n, r) {
  var e = typeof n;
  return r = r ?? gx, !!r && (e == "number" || e != "symbol" && xx.test(n)) && n > -1 && n % 1 == 0 && n < r;
}
var Qo = vx;
function bx(n, r, e) {
  r == "__proto__" && Zo ? Zo(n, r, { configurable: true, enumerable: true, value: e, writable: true }) : n[r] = e;
}
var Js = bx;
function Sx(n, r) {
  return n === r || n !== n && r !== r;
}
var Jo = Sx;
var wx = Object.prototype;
var _x = wx.hasOwnProperty;
function Px(n, r, e) {
  var t = n[r];
  (!(_x.call(n, r) && Jo(t, e)) || e === void 0 && !(r in n)) && Js(n, r, e);
}
var en = Px;
function Tx(n, r, e, t) {
  var o = !e;
  e || (e = {});
  for (var i = -1, s = r.length; ++i < s; ) {
    var l = r[i], c = t ? t(e[l], n[l], l, e, n) : void 0;
    c === void 0 && (c = n[l]), o ? Js(e, l, c) : en(e, l, c);
  }
  return e;
}
var hr = Tx;
var qu = Math.max;
function Ox(n, r, e) {
  return r = qu(r === void 0 ? n.length - 1 : r, 0), function() {
    for (var t = arguments, o = -1, i = qu(t.length - r, 0), s = Array(i); ++o < i; )
      s[o] = t[r + o];
    o = -1;
    for (var l = Array(r + 1); ++o < r; )
      l[o] = t[o];
    return l[r] = e(s), Vu(n, this, l);
  };
}
var Wu = Ox;
var Ax = 9007199254740991;
function Nx(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= Ax;
}
var tn = Nx;
function Cx(n) {
  return n != null && tn(n.length) && !Ks(n);
}
var ea = Cx;
var Ix = Object.prototype;
function Mx(n) {
  var r = n && n.constructor, e = typeof r == "function" && r.prototype || Ix;
  return n === e;
}
var rn = Mx;
function Ex(n, r) {
  for (var e = -1, t = Array(n); ++e < n; )
    t[e] = r(e);
  return t;
}
var $u = Ex;
var Lx = "[object Arguments]";
function Bx(n) {
  return at(n) && Lt(n) == Lx;
}
var Jl = Bx;
var Yu = Object.prototype;
var Dx = Yu.hasOwnProperty;
var Gx = Yu.propertyIsEnumerable;
var Rx = Jl(function() {
  return arguments;
}()) ? Jl : function(n) {
  return at(n) && Dx.call(n, "callee") && !Gx.call(n, "callee");
};
var on = Rx;
function Vx() {
  return false;
}
var Xu = Vx;
var Qu = typeof exports == "object" && exports && !exports.nodeType && exports;
var Ku = Qu && typeof module == "object" && module && !module.nodeType && module;
var zx = Ku && Ku.exports === Qu;
var Zu = zx ? We.Buffer : void 0;
var jx = Zu ? Zu.isBuffer : void 0;
var Fx = jx || Xu;
var wo = Fx;
var kx = "[object Arguments]";
var Ux = "[object Array]";
var Hx = "[object Boolean]";
var qx = "[object Date]";
var Wx = "[object Error]";
var $x = "[object Function]";
var Yx = "[object Map]";
var Xx = "[object Number]";
var Kx = "[object Object]";
var Zx = "[object RegExp]";
var Qx = "[object Set]";
var Jx = "[object String]";
var ev = "[object WeakMap]";
var tv = "[object ArrayBuffer]";
var rv = "[object DataView]";
var ov = "[object Float32Array]";
var nv = "[object Float64Array]";
var iv = "[object Int8Array]";
var sv = "[object Int16Array]";
var av = "[object Int32Array]";
var lv = "[object Uint8Array]";
var cv = "[object Uint8ClampedArray]";
var dv = "[object Uint16Array]";
var uv = "[object Uint32Array]";
var Le = {};
Le[ov] = Le[nv] = Le[iv] = Le[sv] = Le[av] = Le[lv] = Le[cv] = Le[dv] = Le[uv] = true;
Le[kx] = Le[Ux] = Le[tv] = Le[Hx] = Le[rv] = Le[qx] = Le[Wx] = Le[$x] = Le[Yx] = Le[Xx] = Le[Kx] = Le[Zx] = Le[Qx] = Le[Jx] = Le[ev] = false;
function pv(n) {
  return at(n) && tn(n.length) && !!Le[Lt(n)];
}
var Ju = pv;
function fv(n) {
  return function(r) {
    return n(r);
  };
}
var nn = fv;
var ep = typeof exports == "object" && exports && !exports.nodeType && exports;
var Fi = ep && typeof module == "object" && module && !module.nodeType && module;
var mv = Fi && Fi.exports === ep;
var ec = mv && Ys.process;
var hv = function() {
  try {
    var n = Fi && Fi.require && Fi.require("util").types;
    return n || ec && ec.binding && ec.binding("util");
  } catch {
  }
}();
var jr = hv;
var tp = jr && jr.isTypedArray;
var yv = tp ? nn(tp) : Ju;
var ta = yv;
var gv = Object.prototype;
var xv = gv.hasOwnProperty;
function vv(n, r) {
  var e = Ve(n), t = !e && on(n), o = !e && !t && wo(n), i = !e && !t && !o && ta(n), s = e || t || o || i, l = s ? $u(n.length, String) : [], c = l.length;
  for (var u in n)
    (r || xv.call(n, u)) && !(s && (u == "length" || o && (u == "offset" || u == "parent") || i && (u == "buffer" || u == "byteLength" || u == "byteOffset") || Qo(u, c))) && l.push(u);
  return l;
}
var ra = vv;
function bv(n, r) {
  return function(e) {
    return n(r(e));
  };
}
var oa = bv;
var Sv = oa(Object.keys, Object);
var rp = Sv;
var wv = Object.prototype;
var _v = wv.hasOwnProperty;
function Pv(n) {
  if (!rn(n))
    return rp(n);
  var r = [];
  for (var e in Object(n))
    _v.call(n, e) && e != "constructor" && r.push(e);
  return r;
}
var op = Pv;
function Tv(n) {
  return ea(n) ? ra(n) : op(n);
}
var sn = Tv;
function Ov(n) {
  var r = [];
  if (n != null)
    for (var e in Object(n))
      r.push(e);
  return r;
}
var np = Ov;
var Av = Object.prototype;
var Nv = Av.hasOwnProperty;
function Cv(n) {
  if (!Bt(n))
    return np(n);
  var r = rn(n), e = [];
  for (var t in n)
    t == "constructor" && (r || !Nv.call(n, t)) || e.push(t);
  return e;
}
var ip = Cv;
function Iv(n) {
  return ea(n) ? ra(n, true) : ip(n);
}
var an = Iv;
var Mv = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var Ev = /^\w*$/;
function Lv(n, r) {
  if (Ve(n))
    return false;
  var e = typeof n;
  return e == "number" || e == "symbol" || e == "boolean" || n == null || Ko(n) ? true : Ev.test(n) || !Mv.test(n) || r != null && n in Object(r);
}
var sp = Lv;
var Bv = Pt(Object, "create");
var Fr = Bv;
function Dv() {
  this.__data__ = Fr ? Fr(null) : {}, this.size = 0;
}
var ap = Dv;
function Gv(n) {
  var r = this.has(n) && delete this.__data__[n];
  return this.size -= r ? 1 : 0, r;
}
var lp = Gv;
var Rv = "__lodash_hash_undefined__";
var Vv = Object.prototype;
var zv = Vv.hasOwnProperty;
function jv(n) {
  var r = this.__data__;
  if (Fr) {
    var e = r[n];
    return e === Rv ? void 0 : e;
  }
  return zv.call(r, n) ? r[n] : void 0;
}
var cp = jv;
var Fv = Object.prototype;
var kv = Fv.hasOwnProperty;
function Uv(n) {
  var r = this.__data__;
  return Fr ? r[n] !== void 0 : kv.call(r, n);
}
var dp = Uv;
var Hv = "__lodash_hash_undefined__";
function qv(n, r) {
  var e = this.__data__;
  return this.size += this.has(n) ? 0 : 1, e[n] = Fr && r === void 0 ? Hv : r, this;
}
var up = qv;
function ln(n) {
  var r = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++r < e; ) {
    var t = n[r];
    this.set(t[0], t[1]);
  }
}
ln.prototype.clear = ap;
ln.prototype.delete = lp;
ln.prototype.get = cp;
ln.prototype.has = dp;
ln.prototype.set = up;
var tc = ln;
function Wv() {
  this.__data__ = [], this.size = 0;
}
var pp = Wv;
function $v(n, r) {
  for (var e = n.length; e--; )
    if (Jo(n[e][0], r))
      return e;
  return -1;
}
var Jr = $v;
var Yv = Array.prototype;
var Xv = Yv.splice;
function Kv(n) {
  var r = this.__data__, e = Jr(r, n);
  if (e < 0)
    return false;
  var t = r.length - 1;
  return e == t ? r.pop() : Xv.call(r, e, 1), --this.size, true;
}
var fp = Kv;
function Zv(n) {
  var r = this.__data__, e = Jr(r, n);
  return e < 0 ? void 0 : r[e][1];
}
var mp = Zv;
function Qv(n) {
  return Jr(this.__data__, n) > -1;
}
var hp = Qv;
function Jv(n, r) {
  var e = this.__data__, t = Jr(e, n);
  return t < 0 ? (++this.size, e.push([n, r])) : e[t][1] = r, this;
}
var yp = Jv;
function cn(n) {
  var r = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++r < e; ) {
    var t = n[r];
    this.set(t[0], t[1]);
  }
}
cn.prototype.clear = pp;
cn.prototype.delete = fp;
cn.prototype.get = mp;
cn.prototype.has = hp;
cn.prototype.set = yp;
var eo = cn;
var eb = Pt(We, "Map");
var to = eb;
function tb() {
  this.size = 0, this.__data__ = { hash: new tc(), map: new (to || eo)(), string: new tc() };
}
var gp = tb;
function rb(n) {
  var r = typeof n;
  return r == "string" || r == "number" || r == "symbol" || r == "boolean" ? n !== "__proto__" : n === null;
}
var xp = rb;
function ob(n, r) {
  var e = n.__data__;
  return xp(r) ? e[typeof r == "string" ? "string" : "hash"] : e.map;
}
var ro = ob;
function nb(n) {
  var r = ro(this, n).delete(n);
  return this.size -= r ? 1 : 0, r;
}
var vp = nb;
function ib(n) {
  return ro(this, n).get(n);
}
var bp = ib;
function sb(n) {
  return ro(this, n).has(n);
}
var Sp = sb;
function ab(n, r) {
  var e = ro(this, n), t = e.size;
  return e.set(n, r), this.size += e.size == t ? 0 : 1, this;
}
var wp = ab;
function dn(n) {
  var r = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++r < e; ) {
    var t = n[r];
    this.set(t[0], t[1]);
  }
}
dn.prototype.clear = gp;
dn.prototype.delete = vp;
dn.prototype.get = bp;
dn.prototype.has = Sp;
dn.prototype.set = wp;
var _o = dn;
var lb = "Expected a function";
function rc(n, r) {
  if (typeof n != "function" || r != null && typeof r != "function")
    throw new TypeError(lb);
  var e = function() {
    var t = arguments, o = r ? r.apply(this, t) : t[0], i = e.cache;
    if (i.has(o))
      return i.get(o);
    var s = n.apply(this, t);
    return e.cache = i.set(o, s) || i, s;
  };
  return e.cache = new (rc.Cache || _o)(), e;
}
rc.Cache = _o;
var _p = rc;
var cb = 500;
function db(n) {
  var r = _p(n, function(t) {
    return e.size === cb && e.clear(), t;
  }), e = r.cache;
  return r;
}
var Pp = db;
var ub = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var pb = /\\(\\)?/g;
var fb = Pp(function(n) {
  var r = [];
  return n.charCodeAt(0) === 46 && r.push(""), n.replace(ub, function(e, t, o, i) {
    r.push(o ? i.replace(pb, "$1") : t || e);
  }), r;
});
var Tp = fb;
function mb(n) {
  return n == null ? "" : Iu(n);
}
var Op = mb;
function hb(n, r) {
  return Ve(n) ? n : sp(n, r) ? [n] : Tp(Op(n));
}
var kt = hb;
var yb = 1 / 0;
function gb(n) {
  if (typeof n == "string" || Ko(n))
    return n;
  var r = n + "";
  return r == "0" && 1 / n == -yb ? "-0" : r;
}
var oo = gb;
function xb(n, r) {
  r = kt(r, n);
  for (var e = 0, t = r.length; n != null && e < t; )
    n = n[oo(r[e++])];
  return e && e == t ? n : void 0;
}
var na = xb;
function vb(n, r) {
  for (var e = -1, t = r.length, o = n.length; ++e < t; )
    n[o + e] = r[e];
  return n;
}
var un = vb;
var Ap = Ze ? Ze.isConcatSpreadable : void 0;
function bb(n) {
  return Ve(n) || on(n) || !!(Ap && n && n[Ap]);
}
var Np = bb;
function Cp(n, r, e, t, o) {
  var i = -1, s = n.length;
  for (e || (e = Np), o || (o = []); ++i < s; ) {
    var l = n[i];
    r > 0 && e(l) ? r > 1 ? Cp(l, r - 1, e, t, o) : un(o, l) : t || (o[o.length] = l);
  }
  return o;
}
var Ip = Cp;
function Sb(n) {
  var r = n == null ? 0 : n.length;
  return r ? Ip(n, 1) : [];
}
var Mp = Sb;
function wb(n) {
  return Uu(Wu(n, void 0, Mp), n + "");
}
var ia = wb;
var _b = oa(Object.getPrototypeOf, Object);
var pn = _b;
var Pb = "[object Object]";
var Tb = Function.prototype;
var Ob = Object.prototype;
var Ep = Tb.toString;
var Ab = Ob.hasOwnProperty;
var Nb = Ep.call(Object);
function Cb(n) {
  if (!at(n) || Lt(n) != Pb)
    return false;
  var r = pn(n);
  if (r === null)
    return true;
  var e = Ab.call(r, "constructor") && r.constructor;
  return typeof e == "function" && e instanceof e && Ep.call(e) == Nb;
}
var Lp = Cb;
function Ib(n, r, e) {
  var t = -1, o = n.length;
  r < 0 && (r = -r > o ? 0 : o + r), e = e > o ? o : e, e < 0 && (e += o), o = r > e ? 0 : e - r >>> 0, r >>>= 0;
  for (var i = Array(o); ++t < o; )
    i[t] = n[t + r];
  return i;
}
var Bp = Ib;
function Mb() {
  this.__data__ = new eo(), this.size = 0;
}
var Dp = Mb;
function Eb(n) {
  var r = this.__data__, e = r.delete(n);
  return this.size = r.size, e;
}
var Gp = Eb;
function Lb(n) {
  return this.__data__.get(n);
}
var Rp = Lb;
function Bb(n) {
  return this.__data__.has(n);
}
var Vp = Bb;
var Db = 200;
function Gb(n, r) {
  var e = this.__data__;
  if (e instanceof eo) {
    var t = e.__data__;
    if (!to || t.length < Db - 1)
      return t.push([n, r]), this.size = ++e.size, this;
    e = this.__data__ = new _o(t);
  }
  return e.set(n, r), this.size = e.size, this;
}
var zp = Gb;
function fn(n) {
  var r = this.__data__ = new eo(n);
  this.size = r.size;
}
fn.prototype.clear = Dp;
fn.prototype.delete = Gp;
fn.prototype.get = Rp;
fn.prototype.has = Vp;
fn.prototype.set = zp;
var mn = fn;
function Rb(n, r) {
  return n && hr(r, sn(r), n);
}
var jp = Rb;
function Vb(n, r) {
  return n && hr(r, an(r), n);
}
var Fp = Vb;
var qp = typeof exports == "object" && exports && !exports.nodeType && exports;
var kp = qp && typeof module == "object" && module && !module.nodeType && module;
var zb = kp && kp.exports === qp;
var Up = zb ? We.Buffer : void 0;
var Hp = Up ? Up.allocUnsafe : void 0;
function jb(n, r) {
  if (r)
    return n.slice();
  var e = n.length, t = Hp ? Hp(e) : new n.constructor(e);
  return n.copy(t), t;
}
var Wp = jb;
function Fb(n, r) {
  for (var e = -1, t = n == null ? 0 : n.length, o = 0, i = []; ++e < t; ) {
    var s = n[e];
    r(s, e, n) && (i[o++] = s);
  }
  return i;
}
var $p = Fb;
function kb() {
  return [];
}
var sa = kb;
var Ub = Object.prototype;
var Hb = Ub.propertyIsEnumerable;
var Yp = Object.getOwnPropertySymbols;
var qb = Yp ? function(n) {
  return n == null ? [] : (n = Object(n), $p(Yp(n), function(r) {
    return Hb.call(n, r);
  }));
} : sa;
var hn = qb;
function Wb(n, r) {
  return hr(n, hn(n), r);
}
var Xp = Wb;
var $b = Object.getOwnPropertySymbols;
var Yb = $b ? function(n) {
  for (var r = []; n; )
    un(r, hn(n)), n = pn(n);
  return r;
} : sa;
var aa = Yb;
function Xb(n, r) {
  return hr(n, aa(n), r);
}
var Kp = Xb;
function Kb(n, r, e) {
  var t = r(n);
  return Ve(n) ? t : un(t, e(n));
}
var la = Kb;
function Zb(n) {
  return la(n, sn, hn);
}
var ki = Zb;
function Qb(n) {
  return la(n, an, aa);
}
var ca = Qb;
var Jb = Pt(We, "DataView");
var da = Jb;
var e1 = Pt(We, "Promise");
var ua = e1;
var t1 = Pt(We, "Set");
var pa = t1;
var Zp = "[object Map]";
var r1 = "[object Object]";
var Qp = "[object Promise]";
var Jp = "[object Set]";
var ef = "[object WeakMap]";
var tf = "[object DataView]";
var o1 = zr(da);
var n1 = zr(to);
var i1 = zr(ua);
var s1 = zr(pa);
var a1 = zr(Qs);
var Po = Lt;
(da && Po(new da(new ArrayBuffer(1))) != tf || to && Po(new to()) != Zp || ua && Po(ua.resolve()) != Qp || pa && Po(new pa()) != Jp || Qs && Po(new Qs()) != ef) && (Po = function(n) {
  var r = Lt(n), e = r == r1 ? n.constructor : void 0, t = e ? zr(e) : "";
  if (t)
    switch (t) {
      case o1:
        return tf;
      case n1:
        return Zp;
      case i1:
        return Qp;
      case s1:
        return Jp;
      case a1:
        return ef;
    }
  return r;
});
var kr = Po;
var l1 = Object.prototype;
var c1 = l1.hasOwnProperty;
function d1(n) {
  var r = n.length, e = new n.constructor(r);
  return r && typeof n[0] == "string" && c1.call(n, "index") && (e.index = n.index, e.input = n.input), e;
}
var rf = d1;
var u1 = We.Uint8Array;
var yn = u1;
function p1(n) {
  var r = new n.constructor(n.byteLength);
  return new yn(r).set(new yn(n)), r;
}
var gn = p1;
function f1(n, r) {
  var e = r ? gn(n.buffer) : n.buffer;
  return new n.constructor(e, n.byteOffset, n.byteLength);
}
var of = f1;
var m1 = /\w*$/;
function h1(n) {
  var r = new n.constructor(n.source, m1.exec(n));
  return r.lastIndex = n.lastIndex, r;
}
var nf = h1;
var sf = Ze ? Ze.prototype : void 0;
var af = sf ? sf.valueOf : void 0;
function y1(n) {
  return af ? Object(af.call(n)) : {};
}
var lf = y1;
function g1(n, r) {
  var e = r ? gn(n.buffer) : n.buffer;
  return new n.constructor(e, n.byteOffset, n.length);
}
var cf = g1;
var x1 = "[object Boolean]";
var v1 = "[object Date]";
var b1 = "[object Map]";
var S1 = "[object Number]";
var w1 = "[object RegExp]";
var _1 = "[object Set]";
var P1 = "[object String]";
var T1 = "[object Symbol]";
var O1 = "[object ArrayBuffer]";
var A1 = "[object DataView]";
var N1 = "[object Float32Array]";
var C1 = "[object Float64Array]";
var I1 = "[object Int8Array]";
var M1 = "[object Int16Array]";
var E1 = "[object Int32Array]";
var L1 = "[object Uint8Array]";
var B1 = "[object Uint8ClampedArray]";
var D1 = "[object Uint16Array]";
var G1 = "[object Uint32Array]";
function R1(n, r, e) {
  var t = n.constructor;
  switch (r) {
    case O1:
      return gn(n);
    case x1:
    case v1:
      return new t(+n);
    case A1:
      return of(n, e);
    case N1:
    case C1:
    case I1:
    case M1:
    case E1:
    case L1:
    case B1:
    case D1:
    case G1:
      return cf(n, e);
    case b1:
      return new t();
    case S1:
    case P1:
      return new t(n);
    case w1:
      return nf(n);
    case _1:
      return new t();
    case T1:
      return lf(n);
  }
}
var df = R1;
function V1(n) {
  return typeof n.constructor == "function" && !rn(n) ? Ru(pn(n)) : {};
}
var uf = V1;
var z1 = "[object Map]";
function j1(n) {
  return at(n) && kr(n) == z1;
}
var pf = j1;
var ff = jr && jr.isMap;
var F1 = ff ? nn(ff) : pf;
var mf = F1;
var k1 = "[object Set]";
function U1(n) {
  return at(n) && kr(n) == k1;
}
var hf = U1;
var yf = jr && jr.isSet;
var H1 = yf ? nn(yf) : hf;
var gf = H1;
var q1 = 1;
var W1 = 2;
var $1 = 4;
var xf = "[object Arguments]";
var Y1 = "[object Array]";
var X1 = "[object Boolean]";
var K1 = "[object Date]";
var Z1 = "[object Error]";
var vf = "[object Function]";
var Q1 = "[object GeneratorFunction]";
var J1 = "[object Map]";
var eS = "[object Number]";
var bf = "[object Object]";
var tS = "[object RegExp]";
var rS = "[object Set]";
var oS = "[object String]";
var nS = "[object Symbol]";
var iS = "[object WeakMap]";
var sS = "[object ArrayBuffer]";
var aS = "[object DataView]";
var lS = "[object Float32Array]";
var cS = "[object Float64Array]";
var dS = "[object Int8Array]";
var uS = "[object Int16Array]";
var pS = "[object Int32Array]";
var fS = "[object Uint8Array]";
var mS = "[object Uint8ClampedArray]";
var hS = "[object Uint16Array]";
var yS = "[object Uint32Array]";
var Ee = {};
Ee[xf] = Ee[Y1] = Ee[sS] = Ee[aS] = Ee[X1] = Ee[K1] = Ee[lS] = Ee[cS] = Ee[dS] = Ee[uS] = Ee[pS] = Ee[J1] = Ee[eS] = Ee[bf] = Ee[tS] = Ee[rS] = Ee[oS] = Ee[nS] = Ee[fS] = Ee[mS] = Ee[hS] = Ee[yS] = true;
Ee[Z1] = Ee[vf] = Ee[iS] = false;
function fa(n, r, e, t, o, i) {
  var s, l = r & q1, c = r & W1, u = r & $1;
  if (e && (s = o ? e(n, t, o, i) : e(n)), s !== void 0)
    return s;
  if (!Bt(n))
    return n;
  var a = Ve(n);
  if (a) {
    if (s = rf(n), !l)
      return zu(n, s);
  } else {
    var d = kr(n), p = d == vf || d == Q1;
    if (wo(n))
      return Wp(n, l);
    if (d == bf || d == xf || p && !o) {
      if (s = c || p ? {} : uf(n), !l)
        return c ? Kp(n, Fp(s, n)) : Xp(n, jp(s, n));
    } else {
      if (!Ee[d])
        return o ? n : {};
      s = df(n, d, l);
    }
  }
  i || (i = new mn());
  var f = i.get(n);
  if (f)
    return f;
  i.set(n, s), gf(n) ? n.forEach(function(y) {
    s.add(fa(y, r, e, y, n, i));
  }) : mf(n) && n.forEach(function(y, g) {
    s.set(g, fa(y, r, e, g, n, i));
  });
  var m = u ? c ? ca : ki : c ? an : sn, h = a ? void 0 : m(n);
  return Hu(h || n, function(y, g) {
    h && (g = y, y = n[g]), en(s, g, fa(y, r, e, g, n, i));
  }), s;
}
var ma = fa;
var gS = 1;
var xS = 4;
function vS(n) {
  return ma(n, gS | xS);
}
var Ur = vS;
var bS = "__lodash_hash_undefined__";
function SS(n) {
  return this.__data__.set(n, bS), this;
}
var Sf = SS;
function wS(n) {
  return this.__data__.has(n);
}
var wf = wS;
function ha(n) {
  var r = -1, e = n == null ? 0 : n.length;
  for (this.__data__ = new _o(); ++r < e; )
    this.add(n[r]);
}
ha.prototype.add = ha.prototype.push = Sf;
ha.prototype.has = wf;
var _f = ha;
function _S(n, r) {
  for (var e = -1, t = n == null ? 0 : n.length; ++e < t; )
    if (r(n[e], e, n))
      return true;
  return false;
}
var Pf = _S;
function PS(n, r) {
  return n.has(r);
}
var Tf = PS;
var TS = 1;
var OS = 2;
function AS(n, r, e, t, o, i) {
  var s = e & TS, l = n.length, c = r.length;
  if (l != c && !(s && c > l))
    return false;
  var u = i.get(n), a = i.get(r);
  if (u && a)
    return u == r && a == n;
  var d = -1, p = true, f = e & OS ? new _f() : void 0;
  for (i.set(n, r), i.set(r, n); ++d < l; ) {
    var m = n[d], h = r[d];
    if (t)
      var y = s ? t(h, m, d, r, n, i) : t(m, h, d, n, r, i);
    if (y !== void 0) {
      if (y)
        continue;
      p = false;
      break;
    }
    if (f) {
      if (!Pf(r, function(g, v) {
        if (!Tf(f, v) && (m === g || o(m, g, e, t, i)))
          return f.push(v);
      })) {
        p = false;
        break;
      }
    } else if (!(m === h || o(m, h, e, t, i))) {
      p = false;
      break;
    }
  }
  return i.delete(n), i.delete(r), p;
}
var ya = AS;
function NS(n) {
  var r = -1, e = Array(n.size);
  return n.forEach(function(t, o) {
    e[++r] = [o, t];
  }), e;
}
var Of = NS;
function CS(n) {
  var r = -1, e = Array(n.size);
  return n.forEach(function(t) {
    e[++r] = t;
  }), e;
}
var Af = CS;
var IS = 1;
var MS = 2;
var ES = "[object Boolean]";
var LS = "[object Date]";
var BS = "[object Error]";
var DS = "[object Map]";
var GS = "[object Number]";
var RS = "[object RegExp]";
var VS = "[object Set]";
var zS = "[object String]";
var jS = "[object Symbol]";
var FS = "[object ArrayBuffer]";
var kS = "[object DataView]";
var Nf = Ze ? Ze.prototype : void 0;
var oc = Nf ? Nf.valueOf : void 0;
function US(n, r, e, t, o, i, s) {
  switch (e) {
    case kS:
      if (n.byteLength != r.byteLength || n.byteOffset != r.byteOffset)
        return false;
      n = n.buffer, r = r.buffer;
    case FS:
      return !(n.byteLength != r.byteLength || !i(new yn(n), new yn(r)));
    case ES:
    case LS:
    case GS:
      return Jo(+n, +r);
    case BS:
      return n.name == r.name && n.message == r.message;
    case RS:
    case zS:
      return n == r + "";
    case DS:
      var l = Of;
    case VS:
      var c = t & IS;
      if (l || (l = Af), n.size != r.size && !c)
        return false;
      var u = s.get(n);
      if (u)
        return u == r;
      t |= MS, s.set(n, r);
      var a = ya(l(n), l(r), t, o, i, s);
      return s.delete(n), a;
    case jS:
      if (oc)
        return oc.call(n) == oc.call(r);
  }
  return false;
}
var Cf = US;
var HS = 1;
var qS = Object.prototype;
var WS = qS.hasOwnProperty;
function $S(n, r, e, t, o, i) {
  var s = e & HS, l = ki(n), c = l.length, u = ki(r), a = u.length;
  if (c != a && !s)
    return false;
  for (var d = c; d--; ) {
    var p = l[d];
    if (!(s ? p in r : WS.call(r, p)))
      return false;
  }
  var f = i.get(n), m = i.get(r);
  if (f && m)
    return f == r && m == n;
  var h = true;
  i.set(n, r), i.set(r, n);
  for (var y = s; ++d < c; ) {
    p = l[d];
    var g = n[p], v = r[p];
    if (t)
      var b = s ? t(v, g, p, r, n, i) : t(g, v, p, n, r, i);
    if (!(b === void 0 ? g === v || o(g, v, e, t, i) : b)) {
      h = false;
      break;
    }
    y || (y = p == "constructor");
  }
  if (h && !y) {
    var w = n.constructor, S = r.constructor;
    w != S && "constructor" in n && "constructor" in r && !(typeof w == "function" && w instanceof w && typeof S == "function" && S instanceof S) && (h = false);
  }
  return i.delete(n), i.delete(r), h;
}
var If = $S;
var YS = 1;
var Mf = "[object Arguments]";
var Ef = "[object Array]";
var ga = "[object Object]";
var XS = Object.prototype;
var Lf = XS.hasOwnProperty;
function KS(n, r, e, t, o, i) {
  var s = Ve(n), l = Ve(r), c = s ? Ef : kr(n), u = l ? Ef : kr(r);
  c = c == Mf ? ga : c, u = u == Mf ? ga : u;
  var a = c == ga, d = u == ga, p = c == u;
  if (p && wo(n)) {
    if (!wo(r))
      return false;
    s = true, a = false;
  }
  if (p && !a)
    return i || (i = new mn()), s || ta(n) ? ya(n, r, e, t, o, i) : Cf(n, r, c, e, t, o, i);
  if (!(e & YS)) {
    var f = a && Lf.call(n, "__wrapped__"), m = d && Lf.call(r, "__wrapped__");
    if (f || m) {
      var h = f ? n.value() : n, y = m ? r.value() : r;
      return i || (i = new mn()), o(h, y, e, t, i);
    }
  }
  return p ? (i || (i = new mn()), If(n, r, e, t, o, i)) : false;
}
var Bf = KS;
function Df(n, r, e, t, o) {
  return n === r ? true : n == null || r == null || !at(n) && !at(r) ? n !== n && r !== r : Bf(n, r, e, t, Df, o);
}
var Gf = Df;
function ZS(n, r) {
  return n != null && r in Object(n);
}
var Rf = ZS;
function QS(n, r, e) {
  r = kt(r, n);
  for (var t = -1, o = r.length, i = false; ++t < o; ) {
    var s = oo(r[t]);
    if (!(i = n != null && e(n, s)))
      break;
    n = n[s];
  }
  return i || ++t != o ? i : (o = n == null ? 0 : n.length, !!o && tn(o) && Qo(s, o) && (Ve(n) || on(n)));
}
var Vf = QS;
function JS(n, r) {
  return n != null && Vf(n, r, Rf);
}
var zf = JS;
function ew(n) {
  var r = n == null ? 0 : n.length;
  return r ? n[r - 1] : void 0;
}
var jf = ew;
function tw(n, r) {
  return r.length < 2 ? n : na(n, Bp(r, 0, -1));
}
var Ff = tw;
function rw(n, r) {
  return Gf(n, r);
}
var Ui = rw;
function ow(n, r) {
  return r = kt(r, n), n = Ff(n, r), n == null || delete n[oo(jf(r))];
}
var kf = ow;
function nw(n) {
  return Lp(n) ? void 0 : n;
}
var Uf = nw;
var iw = 1;
var sw = 2;
var aw = 4;
var lw = ia(function(n, r) {
  var e = {};
  if (n == null)
    return e;
  var t = false;
  r = Xs(r, function(i) {
    return i = kt(i, n), t || (t = i.length > 1), i;
  }), hr(n, ca(n), e), t && (e = ma(e, iw | sw | aw, Uf));
  for (var o = r.length; o--; )
    kf(e, r[o]);
  return e;
});
var xn = lw;
function cw(n, r, e, t) {
  if (!Bt(n))
    return n;
  r = kt(r, n);
  for (var o = -1, i = r.length, s = i - 1, l = n; l != null && ++o < i; ) {
    var c = oo(r[o]), u = e;
    if (c === "__proto__" || c === "constructor" || c === "prototype")
      return n;
    if (o != s) {
      var a = l[c];
      u = t ? t(a, c, l) : void 0, u === void 0 && (u = Bt(a) ? a : Qo(r[o + 1]) ? [] : {});
    }
    en(l, c, u), l = l[c];
  }
  return n;
}
var Hf = cw;
function dw(n, r, e) {
  for (var t = -1, o = r.length, i = {}; ++t < o; ) {
    var s = r[t], l = na(n, s);
    e(l, s) && Hf(i, kt(s, n), l);
  }
  return i;
}
var qf = dw;
function uw(n, r) {
  return qf(n, r, function(e, t) {
    return zf(n, t);
  });
}
var Wf = uw;
var pw = ia(function(n, r) {
  return n == null ? {} : Wf(n, r);
});
var vn = pw;
var Me = class {
  modifyById(r, e) {
    let t = this;
    if (t[r] === void 0)
      throw new Error("not expected");
    {
      let i = { ...t, [r]: e };
      return Object.setPrototypeOf(i, Me.prototype), i;
    }
  }
  add(r, e) {
    var _a2;
    return ((_a2 = this.runOp({ type: 1, id: r, data: e })) == null ? void 0 : _a2.data) ?? this;
  }
  runOp(r) {
    let e = this;
    if (r.type === 1) {
      let t = e[r.id], o;
      t === void 0 ? o = { type: 2, id: r.id } : o = { type: 1, id: r.id, data: t };
      let { id: i, data: s } = r, l = { ...e, [i]: s };
      return Object.setPrototypeOf(l, Me.prototype), { data: l, actual: r, reverse: o };
    } else if (r.type === 2) {
      let { id: t } = r, o = e[t];
      if (o === void 0)
        return null;
      {
        let i = { ...e };
        return Object.setPrototypeOf(i, Me.prototype), delete i[t], { data: i, actual: r, reverse: { type: 1, id: t, data: o } };
      }
    }
    return null;
  }
};
function Hi(n) {
  if (n.deepFreeze !== void 0) {
    n.deepFreeze(n);
    return;
  }
  let r = Object.getOwnPropertyNames(n);
  for (let e of r) {
    let t = n[e];
    t && typeof t == "object" && Hi(t);
  }
  return Object.freeze(n);
}
function $f(n, r) {
  let e = 0;
  for (; e < n.length && e < r.length; ) {
    if (n[e] < r[e])
      return -1;
    if (n[e] > r[e])
      return 1;
    e += 1;
  }
  return e !== r.length ? -1 : e !== n.length ? 1 : 0;
}
var bn = class extends Error {
};
function xa(n) {
  let r = { ...n };
  return Object.setPrototypeOf(r, Object.getPrototypeOf(n)), r;
}
function yr(n, r, e) {
  if (n === void 0 ? r === void 0 ? (n = 0, r = 10) : n = r - 10 : r === void 0 && (r = n + 10), n > r) {
    let i = n;
    n = r, r = i;
  }
  let t = [], o = 1 / (e + 1);
  for (let i = 0; i < e; i++) {
    let s = n + (r - n) * (i + 0.75 + Math.random() * 0.5) * o;
    t.push(s);
  }
  return t;
}
function Sn(n) {
  return n instanceof Uint8Array || n instanceof Uint16Array || n instanceof Uint32Array || n instanceof Int8Array || n instanceof Int16Array || n instanceof Int32Array || n instanceof Float32Array || n instanceof Float64Array;
}
function Yf() {
  return typeof process < "u";
}
function Xf(n, r) {
  for (let e of n)
    r(e.id, e.data) !== true && Xf(e.children, r);
}
function Kf(n, r) {
  if (r(n.id, n.data) !== true)
    for (let e of n.children)
      Kf(e, r);
}
var $e = class extends Array {
  constructor(...e) {
    super(...e);
    Object.setPrototypeOf(this, $e.prototype);
  }
  deepFreeze() {
    let e = 0;
    for (; e < this.length; )
      Hi(this[e]), e++;
  }
  fillCaches0(e, t) {
    this.objCaches.set(e.id, e), this.parentCaches.set(e.id, t);
    for (let o of e.children)
      this.fillCaches0(o, e.id);
  }
  fillCaches() {
    if (this.objCaches === void 0) {
      this.objCaches = /* @__PURE__ */ new Map(), this.parentCaches = /* @__PURE__ */ new Map();
      for (let e of this)
        this.fillCaches0(e, null);
    }
  }
  randomId() {
    this.fillCaches();
    let e = Array.from(this.objCaches.keys());
    if (e.length !== 0)
      return e[Math.max(0, Math.floor(Math.random() * e.length) - 1)];
  }
  nonExistOrDescendantOf(e, t) {
    if (!this.has(e))
      return true;
    for (; e; ) {
      let o = this.parent(e);
      if (o === t)
        return true;
      e = o;
    }
    return false;
  }
  isDescendantOf(e, t) {
    for (; e; ) {
      let o = this.parent(e);
      if (o === t)
        return true;
      e = o;
    }
    return false;
  }
  data(e) {
    var _a2;
    return (_a2 = this.get(e)) == null ? void 0 : _a2.data;
  }
  has(e) {
    return this.childrenOf(e) !== void 0;
  }
  get(e) {
    return this.fillCaches(), this.objCaches.get(e);
  }
  childrenOf(e) {
    var _a2;
    return e === null ? this : (_a2 = this.get(e)) == null ? void 0 : _a2.children;
  }
  traverseFrom(e, t) {
    if (e === null)
      this.traverse(t);
    else {
      let o = this.get(e);
      o && Kf(o, t);
    }
  }
  traverse(e) {
    Xf(this, e);
  }
  totalSize() {
    return this.fillCaches(), this.objCaches.size;
  }
  parent(e) {
    return this.fillCaches(), this.parentCaches.get(e);
  }
  childrenArray(e) {
    return e === null ? this : this.get(e).children;
  }
  modifyById(e, t) {
    if (this.get(e) === void 0)
      throw new Error("not expected");
    {
      let i = this.parent(e), s = this.childrenArray(i), l = s.findIndex((a) => a.id === e);
      if (l < 0)
        throw new Error("not expected");
      let c = s[l];
      return s = [...s], s[l] = { ...c, data: t }, this.modifyArrayBy(i, s);
    }
  }
  modifyArrayBy(e, t) {
    let o = e, i = t;
    for (; o !== null; ) {
      let l = i, c = o;
      if (o = this.parent(o), o === void 0)
        throw new Error();
      i = this.childrenArray(o);
      let u = i.findIndex((a) => a.id === c);
      if (u < 0)
        throw new Error();
      i = [...i], i[u] = { ...i[u], children: l };
    }
    Object.setPrototypeOf(i, $e.prototype);
    let s = i;
    return s.fillCaches(), s;
  }
  runOp(e) {
    switch (e.type) {
      case 7:
        return this.addOp(e);
      case 8:
        return this.deleteOp(e);
      case 9:
        return this.moveOp(e);
    }
    return null;
  }
  checkDuplicatedIdRec({ id: e, children: t }) {
    if (this.get(e) !== void 0)
      return true;
    for (let o of t)
      if (this.checkDuplicatedIdRec(o))
        return true;
    return false;
  }
  addOp(e) {
    let { parent: t, fi: o, id: i, data: s, children: l } = e;
    if (t !== null && this.get(t) === void 0)
      return null;
    if (this.checkDuplicatedIdRec(e))
      return null;
    {
      let c = t, u = this.childrenArray(c), a = { fi: o, id: i, data: s, children: l };
      return u = [...u, a], u.sort((p, f) => p.fi - f.fi), e.localIndex = u.indexOf(a), { data: this.modifyArrayBy(c, u), actual: e, reverse: { type: 8, id: i } };
    }
  }
  deleteOp(e) {
    let { id: t } = e;
    if (this.get(t) === null)
      return null;
    {
      let o = this.parent(t);
      if (o === void 0)
        return null;
      let i = this.childrenArray(o), s = i.findIndex((u) => u.id === t);
      e.localIndex = s, i = [...i];
      let l = i.splice(s, 1)[0];
      return { data: this.modifyArrayBy(o, i), actual: e, reverse: { type: 7, ...l, parent: o } };
    }
  }
  moveOp(e) {
    let { parent: t, fi: o, id: i } = e;
    if (t !== null && this.get(t) === void 0)
      return this.deleteOp({ type: 8, id: i });
    if (t !== null) {
      let f = t;
      for (; f !== null; ) {
        if (f === void 0)
          throw new Error();
        if (f === i)
          throw new bn("cyclic tree");
        f = this.parent(f);
      }
    }
    let s = this.parent(i);
    if (s === void 0)
      return null;
    let l = s, c = this.childrenArray(s), u = c.findIndex((f) => f.id === i);
    c = [...c];
    let a = c.splice(u, 1)[0], d = this.modifyArrayBy(s, c);
    s = t, c = d.childrenArray(s);
    let p = a.fi;
    return a = { ...a, fi: o }, c = [...c, a], c.sort((f, m) => f.fi - m.fi), e.localIndex = c.indexOf(a), d = d.modifyArrayBy(s, c), { data: d, actual: e, reverse: { type: 9, parent: l, fi: p, id: i } };
  }
  previous(e, t) {
    if (t === null) {
      let i = this.childrenArray(e);
      return i.length === 0 ? null : i[i.length - 1].id;
    }
    let o = null;
    for (let i of this.childrenArray(e)) {
      if (i.id === t)
        return o;
      o = i.id;
    }
    return null;
  }
  traverseSortNext(e) {
    let t = this.parent(e);
    if (t !== void 0) {
      let o = this.childrenArray(t), i = o.findIndex((s) => s.id === e) + 1;
      if (i < o.length)
        return o[i].id;
      if (t)
        return this.traverseSortNext(t);
    }
  }
  sortNext(e) {
    let t = this.childrenArray(e);
    return t.length > 0 ? t[0].id : this.traverseSortNext(e);
  }
  traverseSortPrevious(e) {
    let t = this.childrenArray(e);
    return t.length > 0 ? this.traverseSortPrevious(t[t.length - 1].id) : e;
  }
  sortPrevious(e) {
    let t = this.parent(e);
    if (t !== void 0) {
      let o = this.childrenArray(t), i = o.findIndex((s) => s.id === e) - 1;
      return i >= 0 ? this.traverseSortPrevious(o[i].id) : t;
    }
  }
  getAllSorted(e) {
    let t = [];
    for (let o of e) {
      let i = this.getWithSortKey(o.id);
      i !== void 0 && t.push({ ...o, ...i });
    }
    t.sort((o, i) => $f(o.sortKey, i.sortKey));
    for (let o of t)
      delete o.sortKey;
    return t;
  }
  getWithSortKey(e) {
    var t = e;
    let o = [], i = this.get(t), s = i;
    if (i !== void 0) {
      for (; t; )
        o.splice(0, 0, i.fi), t = this.parent(t), t !== null && (i = this.get(t));
      return { ...s, sortKey: o };
    }
  }
  insertBeforeHelper(e, t, o) {
    return this.insertAfterHelper(e, this.previous(e, t), o);
  }
  insertAfterHelper(e, t, o) {
    let i = this.childrenArray(e);
    if (t === null) {
      if (i.length === 0)
        return yr(0, o, o);
      {
        let s = i[0].fi;
        return yr(s - o, s, o);
      }
    } else {
      let s = this.get(t);
      if (s === void 0 || this.parent(t) !== e)
        throw new Error("illegal args");
      let l = i.find((c) => c.fi > s.fi);
      if (l === void 0) {
        let c = i[i.length - 1].fi;
        return yr(c, c + o, o);
      } else
        return yr(s.fi, l.fi, o);
    }
  }
};
var wn;
((r) => {
  function n(e, t) {
    if (t.type !== 0)
      return null;
    if (Array.isArray(e)) {
      let o = t.props, i = {}, s = [...e], l = false;
      if (o)
        for (let c of Object.keys(o)) {
          let u = parseInt(c);
          if (isNaN(u))
            throw new Error("wrong index");
          i[c] = s[u], s[u] = o[c], l = true;
        }
      return l ? { data: s, actual: t, reverse: { type: 0, props: i } } : null;
    } else {
      let o = t.props, i = {}, s = { ...e }, l = false;
      if (o)
        for (let c of Object.keys(o)) {
          i[c] = s[c];
          let u = o[c];
          u === void 0 ? delete s[c] : s[c] = u, l = true;
        }
      return l ? { data: s, actual: t, reverse: { type: 0, props: i } } : null;
    }
  }
  r.runOp = n;
})(wn || (wn = {}));
var he = class extends Array {
  constructor(...e) {
    super(...e);
    Object.setPrototypeOf(this, he.prototype);
  }
  deepFreeze() {
    let e = 0;
    for (; e < this.length; )
      Hi(this[e]), e++;
  }
  fillCaches0(e) {
    this.objCaches.set(e.id, e);
  }
  fillCaches() {
    if (this.objCaches === void 0) {
      this.objCaches = /* @__PURE__ */ new Map(), Object.getOwnPropertyDescriptor(this, "objCaches").enumerable = false;
      for (let e of this)
        this.fillCaches0(e);
    }
  }
  randomId() {
    this.fillCaches();
    let e = Array.from(this.objCaches.keys());
    if (e.length !== 0)
      return e[Math.max(0, Math.floor(Math.random() * e.length) - 1)];
  }
  data(e) {
    var _a2;
    return (_a2 = this.get(e)) == null ? void 0 : _a2.data;
  }
  get(e) {
    return this.fillCaches(), this.objCaches.get(e);
  }
  modifyById(e, t) {
    if (this.get(e) === void 0)
      throw new Error("not expected");
    {
      let i = this, s = i.findIndex((u) => u.id === e);
      if (s < 0)
        throw new Error("not expected");
      let l = i[s];
      return i = [...i], i[s] = { ...l, data: t }, this.modifyArrayBy(i);
    }
  }
  modifyArrayBy(e) {
    Object.setPrototypeOf(e, he.prototype);
    let t = e;
    return Yf() || t.fillCaches(), t;
  }
  runOp(e) {
    switch (e.type) {
      case 4:
        return this.addOp(e);
      case 5:
        return this.deleteOp(e);
      case 6:
        return this.moveOp(e);
    }
    return null;
  }
  addOp(e) {
    let { fi: t, id: o, data: i } = e, s = this, l = { fi: t, id: o, data: i };
    return s = [...s, l], s.sort((u, a) => u.fi - a.fi), e.localIndex = s.indexOf(l), { data: this.modifyArrayBy(s), actual: e, reverse: { type: 5, id: o } };
  }
  deleteOp(e) {
    let { id: t } = e, o = this, i = o.findIndex((c) => c.id === t);
    if (i === -1)
      return null;
    e.localIndex = i, o = [...o];
    let s = o.splice(i, 1)[0];
    return { data: this.modifyArrayBy(o), actual: e, reverse: { type: 4, ...s } };
  }
  moveOp(e) {
    let { fi: t, id: o } = e, i = this;
    i = [...i];
    let s = i.findIndex((a) => a.id === o);
    if (s === -1)
      return null;
    let l = i[s].fi, c = { ...i[s], fi: t };
    return i[s] = c, i.sort((a, d) => a.fi - d.fi), e.localIndex = i.indexOf(c), { data: this.modifyArrayBy(i), actual: e, reverse: { type: 6, fi: l, id: o } };
  }
  previous(e) {
    if (e === null)
      return this.length === 0 ? null : this[this.length - 1].id;
    let t = null;
    for (let o of this) {
      if (o.id === e)
        return t;
      t = o.id;
    }
    return null;
  }
  insertBeforeHelper(e, t) {
    return this.insertAfterHelper(this.previous(e), t);
  }
  insertAfterHelper(e, t) {
    let o = this;
    if (e === null) {
      if (o.length === 0)
        return yr(0, t, t);
      {
        let i = o[0].fi;
        return yr(i - t, i, t);
      }
    } else {
      let i = this.get(e);
      if (i === void 0)
        throw new Error("illegal args");
      let s = o.find((l) => l.fi > i.fi);
      if (s === void 0) {
        let l = o[o.length - 1].fi;
        return yr(l, l + t, t);
      } else
        return yr(i.fi, s.fi, t);
    }
  }
};
function _n(n) {
  return n && typeof n == "object" && n instanceof Be;
}
var Be = class {
  unusedFunOverridesTable(r) {
  }
  runOp(r) {
    let e = [], t = this, o = 0, i = {};
    for (; o < r.path.length; ) {
      if (e.push(t), t = t === void 0 ? void 0 : t[r.path[o]], t !== void 0 && !_n(t))
        return null;
      o += 1;
    }
    t = t ? xa(t) : new Be();
    for (let [c, u] of Object.entries(r.props)) {
      let a = t[c];
      i[c] = a, u === void 0 ? delete t[c] : t[c] = u;
    }
    for (; o > 0; ) {
      if (Object.keys(t).length === 0) {
        let c = e[o - 1];
        c && (t = xa(c), delete t[r.path[o - 1]]);
      } else {
        let c = e[o - 1];
        if (c) {
          let u = xa(c);
          u[r.path[o - 1]] = t, t = u;
        } else {
          let u = new Be();
          u[r.path[o - 1]] = t, t = u;
        }
      }
      o -= 1;
    }
    let s = Object.setPrototypeOf(t, Be.prototype), l = { ...r, props: i };
    return { data: s, actual: r, reverse: l };
  }
};
var Hr;
((t) => {
  function n(o, i) {
    return qi(o, i) ?? o;
  }
  t.apply = n;
  function r(o, i) {
    return ic(o, i);
  }
  t.merge = r;
  function e(o, i) {
    let s = 0, l = i.path, c = o;
    for (; s < l.length && c !== void 0; ) {
      if (c = yt.zoomOnce(c, l[s]), c === void 0)
        return i;
      if (!_n(c))
        return;
      s += 1;
    }
    if (c === void 0)
      return i;
    if (!!_n(c))
      if (i.type === 0) {
        let u = { ...i.props };
        for (let a of Object.keys(c))
          delete u[a];
        return { ...i, props: u };
      } else if (i.type === 1 || i.type === 4 || i.type === 7) {
        let u = nc([i], c);
        return u ? (console.log(u), u) : i;
      } else
        return i;
  }
  t.filterOp = e;
})(Hr || (Hr = {}));
function nc(n, r) {
  if (r === void 0)
    return;
  let e = false, t = n.map((o) => {
    let i = o.id, s = qi(o.data, r[i]);
    if (e = e || s !== void 0, s === void 0 && (s = o.data), o.children) {
      let l = nc(o.children, r);
      return l !== void 0 ? e = true : l = o.children, { ...o, id: i, data: s, children: l };
    } else
      return { ...o, id: i, data: s };
  });
  if (e)
    return t;
}
function fw(n, r) {
  if (r === void 0)
    return;
  let e = false, t = n.map((o) => {
    let i = o.id, s = qi(o.data, r[i]);
    return e = e || s !== void 0, s === void 0 && (s = o.data), { ...o, id: i, data: s };
  });
  if (e)
    return Object.setPrototypeOf(t, Object.getPrototypeOf(n)), t;
}
function qi(n, r) {
  if (!_n(r))
    return r;
  if (n instanceof $e) {
    let e = nc(n, r);
    return e !== void 0 && Object.setPrototypeOf(e, Object.getPrototypeOf(n)), e;
  } else {
    if (n instanceof he)
      return fw(n, r);
    if (Array.isArray(n)) {
      let e = false, t = n.map((o, i) => {
        let s = qi(o, r[i]);
        return e = e || s !== void 0, s === void 0 && (s = o), s;
      });
      return e ? (Object.setPrototypeOf(t, Object.getPrototypeOf(n)), t) : void 0;
    } else {
      if (n instanceof Be)
        return ic(n, r);
      if (n && typeof n == "object") {
        let e = {}, t = false;
        for (let [o, i] of Object.entries(n)) {
          let s = qi(i, r[o]);
          t = t || s !== void 0, s === void 0 && (s = i), e[o] = s;
        }
        return t ? (Object.setPrototypeOf(e, Object.getPrototypeOf(n)), e) : void 0;
      }
    }
  }
}
function ic(n, r) {
  if (n === void 0)
    return r;
  if (r === void 0)
    return n;
  if (!_n(r))
    return r;
  if (!_n(n))
    return Hr.apply(n, r);
  let e = /* @__PURE__ */ new Set();
  for (let o of Object.keys(n))
    e.add(o);
  for (let o of Object.keys(r))
    e.add(o);
  let t = new Be();
  for (let o of e) {
    let i = ic(n === void 0 ? void 0 : n[o], r === void 0 ? void 0 : r[o]);
    t[o] = i;
  }
  return t;
}
function Zf(n, r) {
  let e = { cur: [], result: [], len: 0 };
  return n = Wi(n, r, e) ?? n, [n, e.result];
}
function va(n, r) {
  return n === null ? null : (n.cur[n.len] = r, n.len += 1, n);
}
function ba(n) {
  n && (n.len -= 1);
}
function mw(n) {
  if (n === null)
    return null;
  n.result.push(n.cur.slice(0, n.len));
}
function Qf(n, r, e) {
  let t = false, o = n.map((i) => {
    let s = i.id, l = r[s];
    if (l !== void 0 && typeof l == "string" && (t = true, s = l, e !== null))
      throw new Error("not supported");
    let c = Wi(i.data, r, va(e, s));
    ba(e), t = t || c !== void 0, c === void 0 && (c = i.data);
    let u = Qf(i.children, r, e);
    return u !== void 0 ? t = true : u = i.children, { ...i, id: s, data: c, children: u };
  });
  if (t)
    return o;
}
function hw(n, r, e) {
  let t = false, o = n.map((i) => {
    let s = i.id, l = r[s];
    if (l !== void 0 && typeof l == "string" && (t = true, s = l, e !== null))
      throw new Error("not supported");
    let c = Wi(i.data, r, va(e, s));
    return ba(e), t = t || c !== void 0, c === void 0 && (c = i.data), { ...i, id: s, data: c };
  });
  if (t)
    return Object.setPrototypeOf(o, Object.getPrototypeOf(n)), o;
}
function Wi(n, r, e) {
  if (n instanceof $e) {
    let t = Qf(n, r, e);
    return t !== void 0 && Object.setPrototypeOf(t, Object.getPrototypeOf(n)), t;
  } else {
    if (n instanceof he)
      return hw(n, r, e);
    if (Array.isArray(n)) {
      let t = false, o = n.map((i, s) => {
        let l = Wi(i, r, va(e, s));
        return ba(e), t = t || l !== void 0, l === void 0 && (l = i), l;
      });
      return t ? (Object.setPrototypeOf(o, Object.getPrototypeOf(n)), o) : void 0;
    } else if (n && typeof n == "object" && !Sn(n)) {
      let t = {}, o = false;
      for (let [i, s] of Object.entries(n))
        if (i !== "name" && i !== "text") {
          let l = r[i];
          if (typeof l == "string") {
            if (e !== null)
              throw new Error("not supported");
            o = true, i = l;
          }
          let c = Wi(s, r, va(e, i));
          ba(e), o = o || c !== void 0, c === void 0 && (c = s), t[i] = c;
        } else
          t[i] = s;
      return o ? (Object.setPrototypeOf(t, Object.getPrototypeOf(n)), t) : void 0;
    } else if (typeof n == "string") {
      let t = r[n];
      if (t !== void 0) {
        if (n.length !== 36)
          throw new Error("for now you should only call this method when the key is a uuid");
        mw(e);
      }
      return t;
    } else
      return;
  }
}
var Sa;
((r) => {
  function n(e, t) {
    let o = yt.zoom(t, e.path);
    if (typeof o == "object") {
      let i = {};
      for (let s of Object.keys(e.props))
        i[s] = o[s];
      return { ...e, props: i };
    } else
      return { ...e, props: {} };
  }
  r.replaceProps = n;
})(Sa || (Sa = {}));
var lt;
((l) => {
  function n(c, u) {
    return { ...c, path: c.path.slice(u) };
  }
  l.drop = n;
  function r(c, u) {
    var _a2;
    return ((_a2 = e(c, u)) == null ? void 0 : _a2.data) ?? c;
  }
  l.applySimple = r;
  function e(c, u) {
    var _a2, _b2;
    let a = u.path;
    for (var d = []; ; ) {
      let p;
      if (c instanceof Be && u.type === 0 && (p = c.runOp({ ...u, path: a.slice(d.length) }), p === null && (p = void 0)), p === void 0 && d.length === a.length && (c instanceof $e || c instanceof he || c instanceof Me ? p = c.runOp(u) : p = wn.runOp(c, u)), p !== void 0)
        if (p !== null) {
          let h = p.data;
          for (let y = d.length - 1; y >= 0; y--) {
            let g = a[y], v = d[y];
            if (v instanceof $e) {
              if (typeof g == "number")
                throw new Error("illegal arg");
              h = v.modifyById(g, h);
            } else if (v instanceof he) {
              if (typeof g == "number")
                throw new Error("illegal arg");
              h = v.modifyById(g, h);
            } else if (v instanceof Me) {
              if (typeof g == "number")
                throw new Error("illegal arg");
              h = v.modifyById(g, h);
            } else if (v instanceof Be) {
              let b = { ...v, [g]: h };
              h = Object.setPrototypeOf(b, Be.prototype);
            } else if (typeof v == "object")
              if (Array.isArray(v)) {
                if (typeof g == "string" && (g = parseInt(g), isNaN(g)))
                  throw new Error("Invalid path");
                let b = h;
                h = [...v], h[g] = b;
              } else
                h = { ...v, [g]: h };
            else
              return null;
          }
          return { data: h, actual: { ...p.actual, path: a }, reverse: { ...p.reverse, path: a } };
        } else
          return null;
      let f = a[d.length], m;
      if (c instanceof $e) {
        if (typeof f == "number")
          throw new Error("");
        m = (_a2 = c.get(f)) == null ? void 0 : _a2.data;
      } else if (c instanceof he) {
        if (typeof f == "number")
          throw new Error("");
        m = (_b2 = c.get(f)) == null ? void 0 : _b2.data;
      } else
        c !== null && (m = c[f]);
      if (m !== void 0)
        d.push(c), c = m;
      else
        return null;
    }
  }
  l.apply = e;
  function t(c, u) {
    for (let a = 0; a < c.length && a < u.length; a++)
      if (c[a] !== u[a])
        return true;
    return false;
  }
  l.pathDisjoint = t;
  function o(c, u) {
    if (c.length !== u.length)
      return false;
    for (let a = 0; a < c.length; a++)
      if (c[a] !== u[a])
        return false;
    return true;
  }
  l.pathEq = o;
  function i(c, u) {
    return t(c.path, u.path);
  }
  l.commutative = i;
  function s(c, u) {
    return c.type === 0 && u.type === 0 && o(c.path, u.path) ? Object.keys(c.props).every((a) => u.props[a] !== void 0) : false;
  }
  l.subsumed = s;
})(lt || (lt = {}));
var sc;
((c) => {
  function n() {
    return [];
  }
  c.empty = n;
  function r(u, a) {
    let d = [];
    for (let p of u) {
      let [f, ...m] = p.path;
      f === a && d.push({ ...p, path: m });
    }
    return d;
  }
  c.removePrefix = r;
  function e(u, a) {
    return u.map((d) => ({ ...d, path: [a, ...d.path] }));
  }
  c.addPrefix = e;
  function t(u, a) {
    return [...u, ...a];
  }
  c.concat = t;
  function o(u, a) {
    return [...u.filter((p) => !a.some((f) => lt.subsumed(p, f))), ...a];
  }
  c.compress = o;
  function i(u, a) {
    return u.every((d) => a.every((p) => lt.commutative(d, p)));
  }
  c.commutative = i;
  function s(u, a) {
    for (let d of a) {
      let p = l(u, d);
      p !== null && (u = p.data);
    }
    return u;
  }
  c.applyAll = s;
  function l(u, a) {
    var d = u;
    let p = [], f = [];
    for (let m of a)
      try {
        if (m.type === 3) {
          let h = yt.zoom(d, [...m.path, m.id]), y = lt.apply(d, { ...m, type: 2 });
          if (y !== null) {
            d = y.data;
            let [g, v] = Zf(d, { [m.id]: h });
            d = g;
            for (let b of v) {
              let w = b[b.length - 1];
              b.splice(b.length - 1, 1), p.push({ type: 0, path: b, props: { [w]: h } }), f.push({ type: 0, path: b, props: { [w]: m.id } });
            }
            f.push(y.reverse), p.push(y.actual);
          }
        } else {
          let h = lt.apply(d, m);
          h !== null && (p.push(h.actual), d = h.data, f.push(h.reverse));
        }
      } catch (h) {
        if (h instanceof bn)
          return null;
        throw h;
      }
    return { data: d, actual: p, reverse: f.reverse() };
  }
  c.apply = l;
})(sc || (sc = {}));
var Jf = Symbol();
var yw = Symbol();
var _a = Symbol();
var To = class {
  reportOp(r, e, t = []) {
    let o = this;
    if (e === null)
      return;
    o._current = e.data;
    let i = t;
    for (; !(o instanceof wa); ) {
      let s = o._path, l = o._current;
      if (s !== "" && i.splice(0, 0, s), o = o._parent, o === null)
        return;
      o.update(s, l);
    }
    o.push(i, r, e.actual, e.reverse);
  }
  deleteChildren(r) {
    if (this._children) {
      let e = this._children[r];
      if (e) {
        let t = e[_a];
        t && t(), delete this._children[r];
      }
    }
  }
};
var lc = class extends To {
  constructor(r, e, t) {
    super(), this._parent = r, this._path = e, this._current = t;
  }
  update(r, e) {
    if (Array.isArray(this._current)) {
      if (typeof r == "string" && (r = parseInt(r), isNaN(r)))
        throw new Error("Invalid path");
      this._current = [...this._current], this._current[r] = e;
    } else
      this._current = { ...this._current, [r]: e };
  }
  runOp(r) {
    this.reportOp(r, wn.runOp(this._current, r), r.path);
  }
};
var cc = class extends To {
  constructor(r, e, t) {
    super(), this._parent = r, this._path = e, this._current = t;
  }
  update(r, e) {
    this._current = { ...this._current, [r]: e }, Object.setPrototypeOf(this._current, Me.prototype);
  }
  runOp(r) {
    this.reportOp(r, this._current.runOp(r));
  }
};
var em = { get(n, r) {
  if (r === _a)
    return () => {
      n._parent = null;
    };
  if (r === Jf)
    return n._current;
  if (r === yw)
    return n;
  let { _current: e, _children: t } = n;
  if (r === "push" && Array.isArray(e))
    throw new Error("not supported to expand array");
  let o = t === void 0 ? void 0 : t[r];
  if (o !== void 0)
    return o;
  let i = e[r], s = Pa(n, r, i);
  return s !== i ? (t === void 0 && (t = {}, n._children = t), t[r] = s, s) : i;
}, has(n, r) {
  return r in n._current;
}, ownKeys(n) {
  return Reflect.ownKeys(n._current);
}, defineProperty() {
  throw Error("not supported");
}, getPrototypeOf(n) {
  return Object.getPrototypeOf(n._current);
}, setPrototypeOf() {
  throw Error("not supported");
}, getOwnPropertyDescriptor(n, r) {
  let e = n._current, t = Reflect.getOwnPropertyDescriptor(e, r);
  return t && { writable: true, configurable: true, enumerable: t.enumerable, value: e[r] };
} };
var gw = { ...em, set(n, r, e) {
  let t = { type: 0, props: { [r]: Qe(e) ?? e } };
  return n.deleteChildren(r), n.runOp(t), true;
}, deleteProperty(n, r) {
  let e = { type: 0, props: { [r]: void 0 } };
  return n.deleteChildren(r), n.runOp(e), true;
} };
var xw = { ...em, set(n, r, e) {
  return e === void 0 ? this.deleteProperty(n, r) : (n.deleteChildren(r), n.runOp({ type: 1, id: r, data: e })), true;
}, deleteProperty(n, r) {
  return n.runOp({ type: 2, id: r }), true;
} };
var Pn = class extends To {
  constructor(r, e, t) {
    super(), this._children = {}, this._parent = r, this._path = e, this._current = t, this[_a] = () => {
      this._parent = null;
    };
  }
  unproxy() {
    return this._current;
  }
  update(r, e) {
    this._current = this._current.modifyById(r, e);
  }
  runOp(r) {
    this.reportOp(r, this._current.runOp(r));
  }
  randomId() {
    return this._current.randomId();
  }
  isDescendantOf(r, e) {
    return this._current.isDescendantOf(r, e);
  }
  childrenOf(r) {
    return this._current.childrenOf(r);
  }
  traverse(r) {
    return this._current.traverse(r);
  }
  get(r) {
    return this._current.get(r);
  }
  parent(r) {
    return this._current.parent(r);
  }
  traverse(r) {
    this._current.traverse((e, t) => {
      r(e, this.data(e));
    });
  }
  data(r) {
    var _a2;
    let { _current: e, _children: t } = this, o = t === void 0 ? void 0 : t[r];
    if (o !== void 0)
      return o;
    let i = (_a2 = e.get(r)) == null ? void 0 : _a2.data, s = Pa(this, r, i);
    return s !== i ? (t === void 0 && (t = {}, this._children = t), t[r] = s, s) : i;
  }
  add(r, e, t, o, i) {
    this.runOp({ type: 7, parent: r, fi: e, id: t, data: o, children: i });
  }
  move(r, e, t) {
    this.runOp({ type: 9, parent: r, fi: e, id: t });
  }
  insertAfter(r, e, t) {
    let o = this._current.insertAfterHelper(r, e, t.length);
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      this.add(r, o[i], s.id, s.data, s.children);
    }
  }
  insertBefore(r, e, t) {
    let o = this._current.insertBeforeHelper(r, e, t.length);
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      this.add(r, o[i], s.id, s.data, s.children);
    }
  }
  moveAfter(r, e, t) {
    let o = this._current.insertAfterHelper(r, e, t.length);
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      this.move(r, o[i], s);
    }
  }
  moveBefore(r, e, t) {
    let o = this._current.insertBeforeHelper(r, e, t.length);
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      this.move(r, o[i], s);
    }
  }
  delete(r) {
    this.deleteChildren(r), this.runOp({ type: 8, id: r });
  }
  sortNext(r) {
    return this._current.sortNext(r);
  }
  sortPrevious(r) {
    return this._current.sortPrevious(r);
  }
  getAllSorted(r) {
    return this._current.getAllSorted(r);
  }
};
var Tn = class extends To {
  constructor(r, e, t) {
    super(), this._children = {}, this._parent = r, this._path = e, this._current = t, this[_a] = () => {
      this._parent = null;
    };
  }
  unproxy() {
    return this._current;
  }
  get length() {
    return this._current.length;
  }
  forEach(r) {
    let e = this.length;
    for (let t = 0; t < e; t++) {
      let o = this._current[t].id, i = this._current[t].fi;
      r(this.data(this._current[t].id), o, i);
    }
  }
  find(r) {
    let e = this.length;
    for (let t = 0; t < e; t++) {
      let o = this._current[t].id;
      if (r(this.data(o), o))
        return this.get(o);
    }
  }
  update(r, e) {
    this._current = this._current.modifyById(r, e);
  }
  randomId() {
    return this._current.randomId();
  }
  get(r) {
    return { ...this._current.get(r), data: this.data(r) };
  }
  data(r) {
    var _a2;
    let { _current: e, _children: t } = this, o = t === void 0 ? void 0 : t[r];
    if (o !== void 0)
      return o;
    let i = (_a2 = e.get(r)) == null ? void 0 : _a2.data, s = Pa(this, r, i);
    return s !== i ? (t === void 0 && (t = {}, this._children = t), t[r] = s, s) : i;
  }
  runOp(r) {
    this.reportOp(r, this._current.runOp(r));
  }
  add(r, e, t) {
    this.runOp({ type: 4, fi: r, id: e, data: t });
  }
  move(r, e) {
    this.runOp({ type: 6, fi: r, id: e });
  }
  insertAfter(r, e) {
    let t = this._current.insertAfterHelper(r, e.length);
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      this.add(t[o], i.id, i.data);
    }
  }
  insertBefore(r, e) {
    let t = this._current.insertBeforeHelper(r, e.length);
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      this.add(t[o], i.id, i.data);
    }
  }
  moveAfter(r, e) {
    let t = this._current.insertAfterHelper(r, e.length);
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      this.move(t[o], i);
    }
  }
  moveBefore(r, e) {
    let t = this._current.insertBeforeHelper(r, e.length);
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      this.move(t[o], i);
    }
  }
  delete(r) {
    this.deleteChildren(r), this.runOp({ type: 5, id: r });
  }
};
function ac(n, r, e) {
  if (n.length > 0) {
    let t = n[n.length - 1];
    if (t.type === 0 && r.type === 0 && yt.equal(t.path, e)) {
      Object.assign(t.props, r.props);
      return;
    }
  }
  n.push({ ...r, path: e });
}
var wa = class extends To {
  constructor(r) {
    super(), this.ts = [], this.actual = [], this.reverse = [], this._current = r;
  }
  update(r, e) {
    if (r !== "")
      throw new Error("");
    this._current = e;
  }
  push(r, e, t, o) {
    ac(this.ts, e, r), ac(this.actual, t, r), ac(this.reverse, o, r);
  }
  result() {
    return { data: this._current, ts: this.ts, actual: this.actual, reverse: this.reverse.reverse() };
  }
};
function Pa(n, r, e) {
  return e instanceof $e ? new Pn(n, r, e) : e instanceof he ? new Tn(n, r, e) : e instanceof Me ? new Proxy(new cc(n, r, e), xw) : e !== null && typeof e == "object" ? Sn(e) ? e : new Proxy(new lc(n, r, e), gw) : e;
}
function dc(n) {
  let r = new wa(n);
  return [Pa(r, "", n), r];
}
function On(n, r) {
  let [e, t] = dc(n);
  return r(e), t.result();
}
function Qe(n) {
  return n instanceof Pn || n instanceof Tn ? n._current : n !== null && typeof n == "object" ? n[Jf] : n;
}
var yt;
((o) => {
  function n(i, s) {
    if (s.length === i.length)
      for (var l = 0; l < i.length; ) {
        if (i[l] !== s[l])
          return false;
        l += 1;
      }
    else
      return false;
    return true;
  }
  o.equal = n;
  function r(i, s, l) {
    let c = t(l, i);
    if (c !== void 0 && typeof c == "object" && c !== null) {
      let u = { ...s };
      return Object.keys(c).forEach((a) => {
        delete u[a];
      }), u;
    } else
      return s;
  }
  o.removeOverridden = r;
  function e(i, s) {
    if ((i instanceof $e || i instanceof Pn) && typeof s == "string")
      return i.data(s);
    if ((i instanceof he || i instanceof Tn) && typeof s == "string")
      return i.data(s);
    if (typeof s == "number" && Array.isArray(i))
      return i[s];
    if (typeof s == "string" && typeof i == "object" && i !== null)
      return i[s];
  }
  o.zoomOnce = e;
  function t(i, s, l = 0) {
    for (; l < s.length && i !== void 0; )
      i = e(i, s[l]), l += 1;
    return i;
  }
  o.zoom = t;
})(yt || (yt = {}));
function tm(n, r) {
  let e = [];
  if (r.length === n.length)
    for (var t = 0; t < n.length; ) {
      if (r[t] === "*")
        e.push(n[t]);
      else if (n[t] !== r[t])
        return null;
      t += 1;
    }
  else
    return null;
  return e;
}
function Zt(n, r) {
  let e = [];
  if (r.length <= n.length)
    for (var t = 0; t < r.length; ) {
      if (r[t] === "*")
        e.push(n[t]);
      else if (n[t] !== r[t])
        return null;
      t += 1;
    }
  else
    return null;
  return e;
}
var Ta = class {
};
var $i = class extends Ta {
  constructor(e) {
    super();
    this.id = e;
  }
};
var Yi = class extends Ta {
  constructor(e) {
    super();
    this.data = e;
  }
};
var pc;
try {
  pc = new TextDecoder();
} catch {
}
var ne;
var io;
var I = 0;
var cm = [];
var fc = cm;
var mc = 0;
var Tt = {};
var Pe;
var no;
var Ut = 0;
var gr = 0;
var Dt;
var qr;
var gt = [];
var Ae;
var rm = { useRecords: false, mapsAsObjects: true };
var Xi = class {
};
var yc = new Xi();
yc.name = "MessagePack 0xC1";
var An = false;
var xr = class {
  constructor(r) {
    r && (r.useRecords === false && r.mapsAsObjects === void 0 && (r.mapsAsObjects = true), r.structures ? r.structures.sharedLength = r.structures.length : r.getStructures && ((r.structures = []).uninitialized = true, r.structures.sharedLength = 0)), Object.assign(this, r);
  }
  unpack(r, e) {
    if (ne)
      return mm(() => (Aa(), this ? this.unpack(r, e) : xr.prototype.unpack.call(rm, r, e)));
    io = e > -1 ? e : r.length, I = 0, mc = 0, gr = 0, no = null, fc = cm, Dt = null, ne = r;
    try {
      Ae = r.dataView || (r.dataView = new DataView(r.buffer, r.byteOffset, r.byteLength));
    } catch (t) {
      throw ne = null, r instanceof Uint8Array ? t : new Error("Source must be a Uint8Array or Buffer but was a " + (r && typeof r == "object" ? r.constructor.name : typeof r));
    }
    if (this instanceof xr) {
      if (Tt = this, this.structures)
        return Pe = this.structures, Oa();
      (!Pe || Pe.length > 0) && (Pe = []);
    } else
      Tt = rm, (!Pe || Pe.length > 0) && (Pe = []);
    return Oa();
  }
  unpackMultiple(r, e) {
    let t, o = 0;
    try {
      An = true;
      let i = r.length, s = this ? this.unpack(r, i) : Ia.unpack(r, i);
      if (e) {
        for (e(s); I < i; )
          if (o = I, e(Oa()) === false)
            return;
      } else {
        for (t = [s]; I < i; )
          o = I, t.push(Oa());
        return t;
      }
    } catch (i) {
      throw i.lastPosition = o, i.values = t, i;
    } finally {
      An = false, Aa();
    }
  }
  _mergeStructures(r, e) {
    r = r || [];
    for (let t = 0, o = r.length; t < o; t++) {
      let i = r[t];
      i && (i.isShared = true, t >= 32 && (i.highByte = t - 32 >> 5));
    }
    r.sharedLength = r.length;
    for (let t in e || [])
      if (t >= 0) {
        let o = r[t], i = e[t];
        i && (o && ((r.restoreStructures || (r.restoreStructures = []))[t] = o), r[t] = i);
      }
    return this.structures = r;
  }
  decode(r, e) {
    return this.unpack(r, e);
  }
};
function Oa() {
  try {
    if (!Tt.trusted && !An) {
      let r = Pe.sharedLength || 0;
      r < Pe.length && (Pe.length = r);
    }
    let n = ze();
    if (I == io)
      Pe.restoreStructures && om(), Pe = null, ne = null, qr && (qr = null);
    else if (I > io) {
      let r = new Error("Unexpected end of MessagePack data");
      throw r.incomplete = true, r;
    } else if (!An)
      throw new Error("Data read, but end of buffer not reached");
    return n;
  } catch (n) {
    throw Pe.restoreStructures && om(), Aa(), (n instanceof RangeError || n.message.startsWith("Unexpected end of buffer")) && (n.incomplete = true), n;
  }
}
function om() {
  for (let n in Pe.restoreStructures)
    Pe[n] = Pe.restoreStructures[n];
  Pe.restoreStructures = null;
}
function ze() {
  let n = ne[I++];
  if (n < 160)
    if (n < 128) {
      if (n < 64)
        return n;
      {
        let r = Pe[n & 63] || Tt.getStructures && dm()[n & 63];
        return r ? (r.read || (r.read = gc(r, n & 63)), r.read()) : n;
      }
    } else if (n < 144)
      if (n -= 128, Tt.mapsAsObjects) {
        let r = {};
        for (let e = 0; e < n; e++)
          r[pm()] = ze();
        return r;
      } else {
        let r = /* @__PURE__ */ new Map();
        for (let e = 0; e < n; e++)
          r.set(ze(), ze());
        return r;
      }
    else {
      n -= 144;
      let r = new Array(n);
      for (let e = 0; e < n; e++)
        r[e] = ze();
      return r;
    }
  else if (n < 192) {
    let r = n - 160;
    if (gr >= I)
      return no.slice(I - Ut, (I += r) - Ut);
    if (gr == 0 && io < 140) {
      let e = r < 16 ? xc(r) : um(r);
      if (e != null)
        return e;
    }
    return hc(r);
  } else {
    let r;
    switch (n) {
      case 192:
        return null;
      case 193:
        return Dt ? (r = ze(), r > 0 ? Dt[1].slice(Dt.position1, Dt.position1 += r) : Dt[0].slice(Dt.position0, Dt.position0 -= r)) : yc;
      case 194:
        return false;
      case 195:
        return true;
      case 196:
        return uc(ne[I++]);
      case 197:
        return r = Ae.getUint16(I), I += 2, uc(r);
      case 198:
        return r = Ae.getUint32(I), I += 4, uc(r);
      case 199:
        return Oo(ne[I++]);
      case 200:
        return r = Ae.getUint16(I), I += 2, Oo(r);
      case 201:
        return r = Ae.getUint32(I), I += 4, Oo(r);
      case 202:
        if (r = Ae.getFloat32(I), Tt.useFloat32 > 2) {
          let e = Ca[(ne[I] & 127) << 1 | ne[I + 1] >> 7];
          return I += 4, (e * r + (r > 0 ? 0.5 : -0.5) >> 0) / e;
        }
        return I += 4, r;
      case 203:
        return r = Ae.getFloat64(I), I += 8, r;
      case 204:
        return ne[I++];
      case 205:
        return r = Ae.getUint16(I), I += 2, r;
      case 206:
        return r = Ae.getUint32(I), I += 4, r;
      case 207:
        return Tt.int64AsNumber ? (r = Ae.getUint32(I) * 4294967296, r += Ae.getUint32(I + 4)) : r = Ae.getBigUint64(I), I += 8, r;
      case 208:
        return Ae.getInt8(I++);
      case 209:
        return r = Ae.getInt16(I), I += 2, r;
      case 210:
        return r = Ae.getInt32(I), I += 4, r;
      case 211:
        return Tt.int64AsNumber ? (r = Ae.getInt32(I) * 4294967296, r += Ae.getUint32(I + 4)) : r = Ae.getBigInt64(I), I += 8, r;
      case 212:
        if (r = ne[I++], r == 114)
          return lm(ne[I++] & 63);
        {
          let e = gt[r];
          if (e)
            return e.read ? (I++, e.read(ze())) : e.noBuffer ? (I++, e()) : e(ne.subarray(I, ++I));
          throw new Error("Unknown extension " + r);
        }
      case 213:
        return r = ne[I], r == 114 ? (I++, lm(ne[I++] & 63, ne[I++])) : Oo(2);
      case 214:
        return Oo(4);
      case 215:
        return Oo(8);
      case 216:
        return Oo(16);
      case 217:
        return r = ne[I++], gr >= I ? no.slice(I - Ut, (I += r) - Ut) : bw(r);
      case 218:
        return r = Ae.getUint16(I), I += 2, gr >= I ? no.slice(I - Ut, (I += r) - Ut) : Sw(r);
      case 219:
        return r = Ae.getUint32(I), I += 4, gr >= I ? no.slice(I - Ut, (I += r) - Ut) : ww(r);
      case 220:
        return r = Ae.getUint16(I), I += 2, im(r);
      case 221:
        return r = Ae.getUint32(I), I += 4, im(r);
      case 222:
        return r = Ae.getUint16(I), I += 2, sm(r);
      case 223:
        return r = Ae.getUint32(I), I += 4, sm(r);
      default:
        if (n >= 224)
          return n - 256;
        if (n === void 0) {
          let e = new Error("Unexpected end of MessagePack data");
          throw e.incomplete = true, e;
        }
        throw new Error("Unknown MessagePack token " + n);
    }
  }
}
var vw = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function gc(n, r) {
  function e() {
    if (e.count++ > 2) {
      let o = n.read = new Function("r", "return function(){return {" + n.map((i) => vw.test(i) ? i + ":r()" : "[" + JSON.stringify(i) + "]:r()").join(",") + "}}")(ze);
      return n.highByte === 0 && (n.read = nm(r, n.read)), o();
    }
    let t = {};
    for (let o = 0, i = n.length; o < i; o++) {
      let s = n[o];
      t[s] = ze();
    }
    return t;
  }
  return e.count = 0, n.highByte === 0 ? nm(r, e) : e;
}
var nm = (n, r) => function() {
  let e = ne[I++];
  if (e === 0)
    return r();
  let t = n < 32 ? -(n + (e << 5)) : n + (e << 5), o = Pe[t] || dm()[t];
  if (!o)
    throw new Error("Record id is not defined for " + t);
  return o.read || (o.read = gc(o, n)), o.read();
};
function dm() {
  let n = mm(() => (ne = null, Tt.getStructures()));
  return Pe = Tt._mergeStructures(n, Pe);
}
var hc = Na;
var bw = Na;
var Sw = Na;
var ww = Na;
function Na(n) {
  let r;
  if (n < 16 && (r = xc(n)))
    return r;
  if (n > 64 && pc)
    return pc.decode(ne.subarray(I, I += n));
  let e = I + n, t = [];
  for (r = ""; I < e; ) {
    let o = ne[I++];
    if ((o & 128) === 0)
      t.push(o);
    else if ((o & 224) === 192) {
      let i = ne[I++] & 63;
      t.push((o & 31) << 6 | i);
    } else if ((o & 240) === 224) {
      let i = ne[I++] & 63, s = ne[I++] & 63;
      t.push((o & 31) << 12 | i << 6 | s);
    } else if ((o & 248) === 240) {
      let i = ne[I++] & 63, s = ne[I++] & 63, l = ne[I++] & 63, c = (o & 7) << 18 | i << 12 | s << 6 | l;
      c > 65535 && (c -= 65536, t.push(c >>> 10 & 1023 | 55296), c = 56320 | c & 1023), t.push(c);
    } else
      t.push(o);
    t.length >= 4096 && (r += Je.apply(String, t), t.length = 0);
  }
  return t.length > 0 && (r += Je.apply(String, t)), r;
}
function im(n) {
  let r = new Array(n);
  for (let e = 0; e < n; e++)
    r[e] = ze();
  return r;
}
function sm(n) {
  if (Tt.mapsAsObjects) {
    let r = {};
    for (let e = 0; e < n; e++)
      r[pm()] = ze();
    return r;
  } else {
    let r = /* @__PURE__ */ new Map();
    for (let e = 0; e < n; e++)
      r.set(ze(), ze());
    return r;
  }
}
var Je = String.fromCharCode;
function um(n) {
  let r = I, e = new Array(n);
  for (let t = 0; t < n; t++) {
    let o = ne[I++];
    if ((o & 128) > 0) {
      I = r;
      return;
    }
    e[t] = o;
  }
  return Je.apply(String, e);
}
function xc(n) {
  if (n < 4)
    if (n < 2) {
      if (n === 0)
        return "";
      {
        let r = ne[I++];
        if ((r & 128) > 1) {
          I -= 1;
          return;
        }
        return Je(r);
      }
    } else {
      let r = ne[I++], e = ne[I++];
      if ((r & 128) > 0 || (e & 128) > 0) {
        I -= 2;
        return;
      }
      if (n < 3)
        return Je(r, e);
      let t = ne[I++];
      if ((t & 128) > 0) {
        I -= 3;
        return;
      }
      return Je(r, e, t);
    }
  else {
    let r = ne[I++], e = ne[I++], t = ne[I++], o = ne[I++];
    if ((r & 128) > 0 || (e & 128) > 0 || (t & 128) > 0 || (o & 128) > 0) {
      I -= 4;
      return;
    }
    if (n < 6) {
      if (n === 4)
        return Je(r, e, t, o);
      {
        let i = ne[I++];
        if ((i & 128) > 0) {
          I -= 5;
          return;
        }
        return Je(r, e, t, o, i);
      }
    } else if (n < 8) {
      let i = ne[I++], s = ne[I++];
      if ((i & 128) > 0 || (s & 128) > 0) {
        I -= 6;
        return;
      }
      if (n < 7)
        return Je(r, e, t, o, i, s);
      let l = ne[I++];
      if ((l & 128) > 0) {
        I -= 7;
        return;
      }
      return Je(r, e, t, o, i, s, l);
    } else {
      let i = ne[I++], s = ne[I++], l = ne[I++], c = ne[I++];
      if ((i & 128) > 0 || (s & 128) > 0 || (l & 128) > 0 || (c & 128) > 0) {
        I -= 8;
        return;
      }
      if (n < 10) {
        if (n === 8)
          return Je(r, e, t, o, i, s, l, c);
        {
          let u = ne[I++];
          if ((u & 128) > 0) {
            I -= 9;
            return;
          }
          return Je(r, e, t, o, i, s, l, c, u);
        }
      } else if (n < 12) {
        let u = ne[I++], a = ne[I++];
        if ((u & 128) > 0 || (a & 128) > 0) {
          I -= 10;
          return;
        }
        if (n < 11)
          return Je(r, e, t, o, i, s, l, c, u, a);
        let d = ne[I++];
        if ((d & 128) > 0) {
          I -= 11;
          return;
        }
        return Je(r, e, t, o, i, s, l, c, u, a, d);
      } else {
        let u = ne[I++], a = ne[I++], d = ne[I++], p = ne[I++];
        if ((u & 128) > 0 || (a & 128) > 0 || (d & 128) > 0 || (p & 128) > 0) {
          I -= 12;
          return;
        }
        if (n < 14) {
          if (n === 12)
            return Je(r, e, t, o, i, s, l, c, u, a, d, p);
          {
            let f = ne[I++];
            if ((f & 128) > 0) {
              I -= 13;
              return;
            }
            return Je(r, e, t, o, i, s, l, c, u, a, d, p, f);
          }
        } else {
          let f = ne[I++], m = ne[I++];
          if ((f & 128) > 0 || (m & 128) > 0) {
            I -= 14;
            return;
          }
          if (n < 15)
            return Je(r, e, t, o, i, s, l, c, u, a, d, p, f, m);
          let h = ne[I++];
          if ((h & 128) > 0) {
            I -= 15;
            return;
          }
          return Je(r, e, t, o, i, s, l, c, u, a, d, p, f, m, h);
        }
      }
    }
  }
}
function uc(n) {
  return Tt.copyBuffers ? Uint8Array.prototype.slice.call(ne, I, I += n) : ne.subarray(I, I += n);
}
function Oo(n) {
  let r = ne[I++];
  if (gt[r])
    return gt[r](ne.subarray(I, I += n));
  throw new Error("Unknown extension type " + r);
}
var am = new Array(4096);
function pm() {
  let n = ne[I++];
  if (n >= 160 && n < 192) {
    if (n = n - 160, gr >= I)
      return no.slice(I - Ut, (I += n) - Ut);
    if (!(gr == 0 && io < 180))
      return hc(n);
  } else
    return I--, ze();
  let r = (n << 5 ^ (n > 1 ? Ae.getUint16(I) : n > 0 ? ne[I] : 0)) & 4095, e = am[r], t = I, o = I + n - 3, i, s = 0;
  if (e && e.bytes == n) {
    for (; t < o; ) {
      if (i = Ae.getUint32(t), i != e[s++]) {
        t = 1879048192;
        break;
      }
      t += 4;
    }
    for (o += 3; t < o; )
      if (i = ne[t++], i != e[s++]) {
        t = 1879048192;
        break;
      }
    if (t === o)
      return I = t, e.string;
    o -= 3, t = I;
  }
  for (e = [], am[r] = e, e.bytes = n; t < o; )
    i = Ae.getUint32(t), e.push(i), t += 4;
  for (o += 3; t < o; )
    i = ne[t++], e.push(i);
  let l = n < 16 ? xc(n) : um(n);
  return l != null ? e.string = l : e.string = hc(n);
}
var lm = (n, r) => {
  var e = ze();
  let t = n;
  r !== void 0 && (n = n < 32 ? -((r << 5) + n) : (r << 5) + n, e.highByte = r);
  let o = Pe[n];
  return o && o.isShared && ((Pe.restoreStructures || (Pe.restoreStructures = []))[n] = o), Pe[n] = e, e.read = gc(e, t), e.read();
};
var fm = typeof self == "object" ? self : global;
gt[0] = () => {
};
gt[0].noBuffer = true;
gt[101] = () => {
  let n = ze();
  return (fm[n[0]] || Error)(n[1]);
};
gt[105] = (n) => {
  let r = Ae.getUint32(I - 4);
  qr || (qr = /* @__PURE__ */ new Map());
  let e = ne[I], t;
  e >= 144 && e < 160 || e == 220 || e == 221 ? t = [] : t = {};
  let o = { target: t };
  qr.set(r, o);
  let i = ze();
  return o.used ? Object.assign(t, i) : (o.target = i, i);
};
gt[112] = (n) => {
  let r = Ae.getUint32(I - 4), e = qr.get(r);
  return e.used = true, e.target;
};
gt[115] = () => new Set(ze());
var vc = ["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64", "BigInt64", "BigUint64"].map((n) => n + "Array");
gt[116] = (n) => {
  let r = n[0], e = vc[r];
  if (!e)
    throw new Error("Could not find typed array for code " + r);
  return new fm[e](Uint8Array.prototype.slice.call(n, 1).buffer);
};
gt[120] = () => {
  let n = ze();
  return new RegExp(n[0], n[1]);
};
gt[98] = (n) => {
  let r = (n[0] << 24) + (n[1] << 16) + (n[2] << 8) + n[3], e = I;
  I += r - 4, Dt = [ze(), ze()], Dt.position0 = 0, Dt.position1 = 0;
  let t = I;
  I = e;
  try {
    return ze();
  } finally {
    I = t;
  }
};
gt[255] = (n) => n.length == 4 ? new Date((n[0] * 16777216 + (n[1] << 16) + (n[2] << 8) + n[3]) * 1e3) : n.length == 8 ? new Date(((n[0] << 22) + (n[1] << 14) + (n[2] << 6) + (n[3] >> 2)) / 1e6 + ((n[3] & 3) * 4294967296 + n[4] * 16777216 + (n[5] << 16) + (n[6] << 8) + n[7]) * 1e3) : n.length == 12 ? new Date(((n[0] << 24) + (n[1] << 16) + (n[2] << 8) + n[3]) / 1e6 + ((n[4] & 128 ? -281474976710656 : 0) + n[6] * 1099511627776 + n[7] * 4294967296 + n[8] * 16777216 + (n[9] << 16) + (n[10] << 8) + n[11]) * 1e3) : /* @__PURE__ */ new Date("invalid");
function mm(n) {
  let r = io, e = I, t = mc, o = Ut, i = gr, s = no, l = fc, c = qr, u = Dt, a = new Uint8Array(ne.slice(0, io)), d = Pe, p = Pe.slice(0, Pe.length), f = Tt, m = An, h = n();
  return io = r, I = e, mc = t, Ut = o, gr = i, no = s, fc = l, qr = c, Dt = u, ne = a, An = m, Pe = d, Pe.splice(0, Pe.length, ...p), Tt = f, Ae = new DataView(ne.buffer, ne.byteOffset, ne.byteLength), h;
}
function Aa() {
  ne = null, qr = null, Pe = null;
}
function hm(n) {
  n.unpack ? gt[n.type] = n.unpack : gt[n.type] = n;
}
var Ca = new Array(147);
for (let n = 0; n < 256; n++)
  Ca[n] = +("1e" + Math.floor(45.15 - n * 0.30103));
var Ia = new xr({ useRecords: false });
var _w = Ia.unpack;
var Pw = Ia.unpackMultiple;
var Tw = Ia.unpack;
var Ma = { NEVER: 0, ALWAYS: 1, DECIMAL_ROUND: 3, DECIMAL_FIT: 4 };
var Ow = new Float32Array(1);
var _D = new Uint8Array(Ow.buffer, 0, 4);
var Ea;
try {
  Ea = new TextEncoder();
} catch {
}
var La;
var Sc;
var Ba = typeof Buffer < "u";
var bc = Ba ? Buffer.allocUnsafeSlow : Uint8Array;
var vm = Ba ? Buffer : Uint8Array;
var ym = Ba ? 4294967296 : 2144337920;
var z;
var Ue;
var E = 0;
var vr;
var br = null;
var Aw = /[\u0080-\uFFFF]/;
var Ki = Symbol("record-id");
var Ao = class extends xr {
  constructor(r) {
    super(r), this.offset = 0;
    let e, t, o, i, s, l, c = 0, u = vm.prototype.utf8Write ? function(x, C, T) {
      return z.utf8Write(x, C, T);
    } : Ea && Ea.encodeInto ? function(x, C) {
      return Ea.encodeInto(x, z.subarray(C)).written;
    } : false, a = this;
    r || (r = {});
    let d = r && r.sequential, p = r.structures || r.saveStructures, f = r.maxSharedStructures;
    if (f == null && (f = p ? 32 : 0), f > 8160)
      throw new Error("Maximum maxSharedStructure is 8160");
    let m = r.maxOwnStructures;
    m == null && (m = p ? 32 : 64), d && !r.saveStructures && (this.structures = []);
    let h = f > 32 || m + f > 64, y = f + 64, g = f + m + 64;
    if (g > 8256)
      throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");
    let v = [], b = 0, w = 0;
    this.pack = this.encode = function(x, C) {
      if (z || (z = new bc(8192), Ue = new DataView(z.buffer, 0, 8192), E = 0), vr = z.length - 10, vr - E < 2048 ? (z = new bc(z.length), Ue = new DataView(z.buffer, 0, z.length), vr = z.length - 10, E = 0) : E = E + 7 & 2147483640, t = E, l = a.structuredClone ? /* @__PURE__ */ new Map() : null, a.bundleStrings ? (br = ["", ""], z[E++] = 214, z[E++] = 98, br.position = E - t, E += 4) : br = null, o = a.structures, o) {
        o.uninitialized && (o = a._mergeStructures(a.getStructures()));
        let T = o.sharedLength || 0;
        if (T > f)
          throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " + o.sharedLength);
        if (!o.transitions) {
          o.transitions = /* @__PURE__ */ Object.create(null);
          for (let N = 0; N < T; N++) {
            let O = o[N];
            if (!O)
              continue;
            let A, R = o.transitions;
            for (let k = 0, $ = O.length; k < $; k++) {
              let te = O[k];
              A = R[te], A || (A = R[te] = /* @__PURE__ */ Object.create(null)), R = A;
            }
            R[Ki] = N + 64;
          }
          c = T;
        }
        d || (o.nextId = T + 64);
      }
      i && (i = false), s = o || [];
      try {
        if (S(x), br) {
          Ue.setUint32(br.position + t, E - br.position - t);
          let T = br;
          br = null, S(T[0]), S(T[1]);
        }
        if (a.offset = E, l && l.idsToInsert) {
          E += l.idsToInsert.length * 6, E > vr && _(E), a.offset = E;
          let T = Cw(z.subarray(t, E), l.idsToInsert);
          return l = null, T;
        }
        return C & Sm ? (z.start = t, z.end = E, z) : z.subarray(t, E);
      } finally {
        if (o) {
          if (w < 10 && w++, b > 1e4)
            o.transitions = null, w = 0, b = 0, v.length > 0 && (v = []);
          else if (v.length > 0 && !d) {
            for (let T = 0, N = v.length; T < N; T++)
              v[T][Ki] = 0;
            v = [];
          }
          if (i && a.saveStructures) {
            let T = o.sharedLength || f;
            o.length > T && (o = o.slice(0, T));
            let N = z.subarray(t, E);
            return a.saveStructures(o, c) === false ? (a._mergeStructures(a.getStructures()), a.pack(x)) : (c = T, N);
          }
        }
        C & Gw && (E = t);
      }
    };
    let S = (x) => {
      E > vr && (z = _(E));
      var C = typeof x, T;
      if (C === "string") {
        let N = x.length;
        if (br && N >= 8 && N < 4096) {
          let R = Aw.test(x);
          br[R ? 0 : 1] += x, z[E++] = 193, S(R ? -N : N);
          return;
        }
        let O;
        N < 32 ? O = 1 : N < 256 ? O = 2 : N < 65536 ? O = 3 : O = 5;
        let A = N * 3;
        if (E + A > vr && (z = _(E + A)), N < 64 || !u) {
          let R, k, $, te = E + O;
          for (R = 0; R < N; R++)
            k = x.charCodeAt(R), k < 128 ? z[te++] = k : k < 2048 ? (z[te++] = k >> 6 | 192, z[te++] = k & 63 | 128) : (k & 64512) === 55296 && (($ = x.charCodeAt(R + 1)) & 64512) === 56320 ? (k = 65536 + ((k & 1023) << 10) + ($ & 1023), R++, z[te++] = k >> 18 | 240, z[te++] = k >> 12 & 63 | 128, z[te++] = k >> 6 & 63 | 128, z[te++] = k & 63 | 128) : (z[te++] = k >> 12 | 224, z[te++] = k >> 6 & 63 | 128, z[te++] = k & 63 | 128);
          T = te - E - O;
        } else
          T = u(x, E + O, A);
        T < 32 ? z[E++] = 160 | T : T < 256 ? (O < 2 && z.copyWithin(E + 2, E + 1, E + 1 + T), z[E++] = 217, z[E++] = T) : T < 65536 ? (O < 3 && z.copyWithin(E + 3, E + 2, E + 2 + T), z[E++] = 218, z[E++] = T >> 8, z[E++] = T & 255) : (O < 5 && z.copyWithin(E + 5, E + 3, E + 3 + T), z[E++] = 219, Ue.setUint32(E, T), E += 4), E += T;
      } else if (C === "number")
        if (x >>> 0 === x)
          x < 64 ? z[E++] = x : x < 256 ? (z[E++] = 204, z[E++] = x) : x < 65536 ? (z[E++] = 205, z[E++] = x >> 8, z[E++] = x & 255) : (z[E++] = 206, Ue.setUint32(E, x), E += 4);
        else if (x >> 0 === x)
          x >= -32 ? z[E++] = 256 + x : x >= -128 ? (z[E++] = 208, z[E++] = x + 256) : x >= -32768 ? (z[E++] = 209, Ue.setInt16(E, x), E += 2) : (z[E++] = 210, Ue.setInt32(E, x), E += 4);
        else {
          let N;
          if ((N = this.useFloat32) > 0 && x < 4294967296 && x >= -2147483648) {
            z[E++] = 202, Ue.setFloat32(E, x);
            let O;
            if (N < 4 || (O = x * Ca[(z[E] & 127) << 1 | z[E + 1] >> 7]) >> 0 === O) {
              E += 4;
              return;
            } else
              E--;
          }
          z[E++] = 203, Ue.setFloat64(E, x), E += 8;
        }
      else if (C === "object")
        if (!x)
          z[E++] = 192;
        else {
          if (l) {
            let O = l.get(x);
            if (O) {
              if (!O.id) {
                let A = l.idsToInsert || (l.idsToInsert = []);
                O.id = A.push(O);
              }
              z[E++] = 214, z[E++] = 112, Ue.setUint32(E, O.id), E += 4;
              return;
            } else
              l.set(x, { offset: E - t });
          }
          let N = x.constructor;
          if (N === Object)
            P(x, true);
          else if (N === Array) {
            T = x.length, T < 16 ? z[E++] = 144 | T : T < 65536 ? (z[E++] = 220, z[E++] = T >> 8, z[E++] = T & 255) : (z[E++] = 221, Ue.setUint32(E, T), E += 4);
            for (let O = 0; O < T; O++)
              S(x[O]);
          } else if (N === Map) {
            T = x.size, T < 16 ? z[E++] = 128 | T : T < 65536 ? (z[E++] = 222, z[E++] = T >> 8, z[E++] = T & 255) : (z[E++] = 223, Ue.setUint32(E, T), E += 4);
            for (let [O, A] of x)
              S(O), S(A);
          } else {
            for (let O = 0, A = La.length; O < A; O++) {
              let R = Sc[O];
              if (x instanceof R) {
                let k = La[O];
                if (k.write) {
                  k.type && (z[E++] = 212, z[E++] = k.type, z[E++] = 0), S(k.write.call(this, x));
                  return;
                }
                let $ = z, te = Ue, Y = E;
                z = null;
                let W;
                try {
                  W = k.pack.call(this, x, (H) => (z = $, $ = null, E += H, E > vr && _(E), { target: z, targetView: Ue, position: E - H }), S);
                } finally {
                  $ && (z = $, Ue = te, E = Y, vr = z.length - 10);
                }
                W && (W.length + E > vr && _(W.length + E), E = Nw(W, z, E, k.type));
                return;
              }
            }
            P(x, !x.hasOwnProperty);
          }
        }
      else if (C === "boolean")
        z[E++] = x ? 195 : 194;
      else if (C === "bigint") {
        if (x < BigInt(1) << BigInt(63) && x >= -(BigInt(1) << BigInt(63)))
          z[E++] = 211, Ue.setBigInt64(E, x);
        else if (x < BigInt(1) << BigInt(64) && x > 0)
          z[E++] = 207, Ue.setBigUint64(E, x);
        else if (this.largeBigIntToFloat)
          z[E++] = 203, Ue.setFloat64(E, Number(x));
        else
          throw new RangeError(x + " was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");
        E += 8;
      } else if (C === "undefined")
        this.encodeUndefinedAsNil ? z[E++] = 192 : (z[E++] = 212, z[E++] = 0, z[E++] = 0);
      else if (C === "function")
        S(this.writeFunction && this.writeFunction());
      else
        throw new Error("Unknown type: " + C);
    }, P = this.useRecords === false ? this.variableMapSize ? (x) => {
      let C = Object.keys(x), T = C.length;
      T < 16 ? z[E++] = 128 | T : T < 65536 ? (z[E++] = 222, z[E++] = T >> 8, z[E++] = T & 255) : (z[E++] = 223, Ue.setUint32(E, T), E += 4);
      let N;
      for (let O = 0; O < T; O++)
        S(N = C[O]), S(x[N]);
    } : (x, C) => {
      z[E++] = 222;
      let T = E - t;
      E += 2;
      let N = 0;
      for (let O in x)
        (C || x.hasOwnProperty(O)) && (S(O), S(x[O]), N++);
      z[T++ + t] = N >> 8, z[T + t] = N & 255;
    } : (x) => {
      let C = Object.keys(x), T, N = s.transitions || (s.transitions = /* @__PURE__ */ Object.create(null)), O = 0;
      for (let R = 0, k = C.length; R < k; R++) {
        let $ = C[R];
        T = N[$], T || (T = N[$] = /* @__PURE__ */ Object.create(null), O++), N = T;
      }
      let A = N[Ki];
      if (A)
        A >= 96 && h ? (z[E++] = ((A -= 96) & 31) + 96, z[E++] = A >> 5) : z[E++] = A;
      else {
        A = s.nextId, A || (A = 64), A < y && this.shouldShareStructure && !this.shouldShareStructure(C) ? (A = s.nextOwnId, A < g || (A = y), s.nextOwnId = A + 1) : (A >= g && (A = y), s.nextId = A + 1);
        let R = C.highByte = A >= 96 && h ? A - 96 >> 5 : -1;
        N[Ki] = A, s[A - 64] = C, A < y ? (C.isShared = true, s.sharedLength = A - 63, i = true, R >= 0 ? (z[E++] = (A & 31) + 96, z[E++] = R) : z[E++] = A) : (R >= 0 ? (z[E++] = 213, z[E++] = 114, z[E++] = (A & 31) + 96, z[E++] = R) : (z[E++] = 212, z[E++] = 114, z[E++] = A), O && (b += w * O), v.length >= m && (v.shift()[Ki] = 0), v.push(N), S(C));
      }
      for (let R = 0, k = C.length; R < k; R++)
        S(x[C[R]]);
    }, _ = (x) => {
      let C;
      if (x > 16777216) {
        if (x - t > ym)
          throw new Error("Packed buffer would be larger than maximum buffer size");
        C = Math.min(ym, Math.round(Math.max((x - t) * (x > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096);
      } else
        C = (Math.max(x - t << 2, z.length - 1) >> 12) + 1 << 12;
      let T = new bc(C);
      return Ue = new DataView(T.buffer, 0, C), z.copy ? z.copy(T, 0, t, x) : T.set(z.slice(t, x)), E -= t, t = 0, vr = T.length - 10, z = T;
    };
  }
  useBuffer(r) {
    z = r, Ue = new DataView(z.buffer, z.byteOffset, z.byteLength), E = 0;
  }
};
Sc = [Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor, Xi];
La = [{ pack(n, r, e) {
  let t = n.getTime() / 1e3;
  if ((this.useTimestamp32 || n.getMilliseconds() === 0) && t >= 0 && t < 4294967296) {
    let { target: o, targetView: i, position: s } = r(6);
    o[s++] = 214, o[s++] = 255, i.setUint32(s, t);
  } else if (t > 0 && t < 17179869184) {
    let { target: o, targetView: i, position: s } = r(10);
    o[s++] = 215, o[s++] = 255, i.setUint32(s, n.getMilliseconds() * 4e6 + (t / 1e3 / 4294967296 >> 0)), i.setUint32(s + 4, t);
  } else if (isNaN(t)) {
    if (this.onInvalidDate)
      return r(0), e(this.onInvalidDate());
    let { target: o, targetView: i, position: s } = r(3);
    o[s++] = 212, o[s++] = 255, o[s++] = 255;
  } else {
    let { target: o, targetView: i, position: s } = r(15);
    o[s++] = 199, o[s++] = 12, o[s++] = 255, i.setUint32(s, n.getMilliseconds() * 1e6), i.setBigInt64(s + 4, BigInt(Math.floor(t)));
  }
} }, { pack(n, r, e) {
  let t = Array.from(n), { target: o, position: i } = r(this.structuredClone ? 3 : 0);
  this.structuredClone && (o[i++] = 212, o[i++] = 115, o[i++] = 0), e(t);
} }, { pack(n, r, e) {
  let { target: t, position: o } = r(this.structuredClone ? 3 : 0);
  this.structuredClone && (t[o++] = 212, t[o++] = 101, t[o++] = 0), e([n.name, n.message]);
} }, { pack(n, r, e) {
  let { target: t, position: o } = r(this.structuredClone ? 3 : 0);
  this.structuredClone && (t[o++] = 212, t[o++] = 120, t[o++] = 0), e([n.source, n.flags]);
} }, { pack(n, r) {
  this.structuredClone ? gm(n, 16, r) : xm(Ba ? Buffer.from(n) : new Uint8Array(n), r);
} }, { pack(n, r) {
  let e = n.constructor;
  e !== vm && this.structuredClone ? gm(n, vc.indexOf(e.name), r) : xm(n, r);
} }, { pack(n, r) {
  let { target: e, position: t } = r(1);
  e[t] = 193;
} }];
function gm(n, r, e, t) {
  let o = n.byteLength;
  if (o + 1 < 256) {
    var { target: i, position: s } = e(4 + o);
    i[s++] = 199, i[s++] = o + 1;
  } else if (o + 1 < 65536) {
    var { target: i, position: s } = e(5 + o);
    i[s++] = 200, i[s++] = o + 1 >> 8, i[s++] = o + 1 & 255;
  } else {
    var { target: i, position: s, targetView: l } = e(7 + o);
    i[s++] = 201, l.setUint32(s, o + 1), s += 4;
  }
  i[s++] = 116, i[s++] = r, i.set(new Uint8Array(n.buffer, n.byteOffset, n.byteLength), s);
}
function xm(n, r) {
  let e = n.byteLength;
  var t, o;
  if (e < 256) {
    var { target: t, position: o } = r(e + 2);
    t[o++] = 196, t[o++] = e;
  } else if (e < 65536) {
    var { target: t, position: o } = r(e + 3);
    t[o++] = 197, t[o++] = e >> 8, t[o++] = e & 255;
  } else {
    var { target: t, position: o, targetView: i } = r(e + 5);
    t[o++] = 198, i.setUint32(o, e), o += 4;
  }
  t.set(n, o);
}
function Nw(n, r, e, t) {
  let o = n.length;
  switch (o) {
    case 1:
      r[e++] = 212;
      break;
    case 2:
      r[e++] = 213;
      break;
    case 4:
      r[e++] = 214;
      break;
    case 8:
      r[e++] = 215;
      break;
    case 16:
      r[e++] = 216;
      break;
    default:
      o < 256 ? (r[e++] = 199, r[e++] = o) : o < 65536 ? (r[e++] = 200, r[e++] = o >> 8, r[e++] = o & 255) : (r[e++] = 201, r[e++] = o >> 24, r[e++] = o >> 16 & 255, r[e++] = o >> 8 & 255, r[e++] = o & 255);
  }
  return r[e++] = t, r.set(n, e), e += o, e;
}
function Cw(n, r) {
  let e, t = r.length * 6, o = n.length - t;
  for (r.sort((i, s) => i.offset > s.offset ? 1 : -1); e = r.pop(); ) {
    let i = e.offset, s = e.id;
    n.copyWithin(i + t, i, o), t -= 6;
    let l = i + t;
    n[l++] = 214, n[l++] = 105, n[l++] = s >> 24, n[l++] = s >> 16 & 255, n[l++] = s >> 8 & 255, n[l++] = s & 255, o = i;
  }
  return n;
}
function so(n) {
  if (n.Class) {
    if (!n.pack && !n.write)
      throw new Error("Extension has no pack or write function");
    if (n.pack && !n.type)
      throw new Error("Extension has no type (numeric code to identify the extension)");
    Sc.unshift(n.Class), La.unshift(n);
  }
  hm(n);
}
var bm = new Ao({ useRecords: false });
var Iw = bm.pack;
var Mw = bm.pack;
var { NEVER: Ew, ALWAYS: Lw, DECIMAL_ROUND: Bw, DECIMAL_FIT: Dw } = Ma;
var Sm = 512;
var Gw = 1024;
var wm = new Ao({ structuredClone: true });
so({ Class: Me.prototype.constructor, type: 1, write(n) {
  return { ...n };
}, read(n) {
  return Object.setPrototypeOf(n, Me.prototype), n;
} });
so({ Class: he.prototype.constructor, type: 2, write(n) {
  return [...n];
}, read(n) {
  return Object.setPrototypeOf(n, he.prototype), n;
} });
so({ Class: $e.prototype.constructor, type: 3, write(n) {
  return [...n];
}, read(n) {
  return Object.setPrototypeOf(n, $e.prototype), n;
} });
so({ Class: $i.prototype.constructor, type: 4, write(n) {
  return n.id;
}, read(n) {
  return new $i(n);
} });
so({ Class: Yi.prototype.constructor, type: 5, write(n) {
  return n.data;
}, read(n) {
  return new Yi(n);
} });
so({ Class: Be.prototype.constructor, type: 6, write(n) {
  return { ...n };
}, read(n) {
  return Object.setPrototypeOf(n, Be.prototype), n;
} });
function Rw(n) {
  var r = 0;
  if (n.length === 0)
    return r;
  for (let e = 0; e < n.length; e++) {
    let t = n[e];
    r = (r << 5) - r + t, r = r & r;
  }
  return r;
}
function wc(n) {
  if (Sn(n))
    return n;
  if (Array.isArray(n))
    return n.map(wc);
  if (typeof n == "object" && n !== null) {
    let r = {};
    for (let e of Object.keys(n).sort())
      r[e] = wc(n[e]);
    return Object.setPrototypeOf(r, Object.getPrototypeOf(n)), r;
  } else
    return n;
}
var Da;
((t) => {
  function n(o) {
    return wm.pack(o);
  }
  t.serialize = n;
  function r(o) {
    return wm.unpack(o);
  }
  t.deserialize = r;
  function e(o) {
    return Rw(n(wc(o))).toString();
  }
  t.checksum = e;
})(Da || (Da = {}));
var _m;
((e) => {
  function n(t, o) {
    return t[0] === o[0] && t[1] === o[1];
  }
  e.isEqual = n;
  function r(t, o, i) {
    return [t[0] + (o[0] - t[0]) * i, t[1] + (o[1] - t[1]) * i];
  }
  e.lerp = r;
})(_m || (_m = {}));
var ao;
((l) => {
  function n(c, u) {
    return c[0] === u[0] && c[1] === u[1] && c[2] === u[2];
  }
  l.isEqual = n;
  function r(c, u) {
    return [c[0] + u[0], c[1] + u[1], c[2] + u[2]];
  }
  l.add = r;
  function e(c, u) {
    return [c[0] - u[0], c[1] - u[1], c[2] - u[2]];
  }
  l.sub = e;
  function t(c, u) {
    return [c[0] / u[0], c[1] / u[1], c[2] / u[2]];
  }
  l.div = t;
  function o(c, u) {
    return [c[0] * u[0], c[1] * u[1], c[2] * u[2]];
  }
  l.mul = o;
  function i(c, u) {
    return Math.hypot(c[0] - u[0], c[1] - u[1], c[2] - u[2]);
  }
  l.dist = i;
  function s(c, u, a) {
    return [c[0] + (u[0] - c[0]) * a, c[1] + (u[1] - c[1]) * a, c[2] + (u[2] - c[2]) * a];
  }
  l.lerp = s;
})(ao || (ao = {}));
var Pm;
((e) => {
  function n(t, o) {
    return t[0] === o[0] && t[1] === o[1] && t[2] === o[2] && t[3] === o[3];
  }
  e.isEqual = n;
  function r(t, o, i) {
    return [t[0] + (o[0] - t[0]) * i, t[1] + (o[1] - t[1]) * i, t[2] + (o[2] - t[2]) * i, t[3] + (o[3] - t[3]) * i];
  }
  e.lerp = r;
})(Pm || (Pm = {}));
var lo;
((o) => {
  o.identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  function r(i, s) {
    for (let l = 0; l < 16; l++)
      if (i[l] !== s[l])
        return false;
    return true;
  }
  o.isEqual = r;
  function e(i) {
    return i ?? o.identity;
  }
  o.simplify = e;
  function t(i, s) {
    let l = s.slice(0);
    for (var c = 0, u = s.length; c < u; c += 3) {
      let a = i[3] * s[c] + i[7] * s[c + 1] + i[11] * s[c + 2] + i[15];
      l[c] = (i[0] * s[c] + i[4] * s[c + 1] + i[8] * s[c + 2] + i[12]) / a, l[c + 1] = (i[1] * s[c] + i[5] * s[c + 1] + i[9] * s[c + 2] + i[13]) / a, l[c + 2] = (i[2] * s[c] + i[6] * s[c + 1] + i[10] * s[c + 2] + i[14]) / a;
    }
    return l;
  }
  o.applyMatrix4 = t;
})(lo || (lo = {}));
var mt;
((a) => {
  function n(d) {
    return typeof d == "object" && typeof d.r == "number" && typeof d.g == "number" && typeof d.b == "number";
  }
  a.isRGB = n, a.white = { r: 1, g: 1, b: 1 }, a.red = { r: 1, g: 0, b: 0 }, a.black = { r: 0, g: 0, b: 0 };
  function o(d) {
    return { r: Math.round(d.r * 255), g: Math.round(d.g * 255), b: Math.round(d.b * 255), a: 1 };
  }
  a.toRgb255a1 = o;
  function i(d) {
    return { r: d.r, g: d.g, b: d.b };
  }
  a.clone = i;
  function s(d) {
    return d = Math.floor(d), { r: (d >> 16 & 255) / 255, g: (d >> 8 & 255) / 255, b: (d & 255) / 255 };
  }
  a.fromHex = s;
  function l(d) {
    return Math.round(d.r * 255) * 65536 + Math.round(d.g * 255) * 256 + Math.round(d.b * 255);
  }
  a.toHex = l;
  function c(d, p) {
    return d.r === p.r && d.g === p.g && d.b === p.b;
  }
  a.equals = c;
  function u(d, p, f) {
    return { r: d.r + (p.r - d.r) * f, g: d.g + (p.g - d.g) * f, b: d.b + (p.b - d.b) * f };
  }
  a.lerp = u;
})(mt || (mt = {}));
var Gt;
((l) => {
  l.white = { ...mt.white, a: 1 }, l.transparent = { ...mt.white, a: 0 };
  function e(c) {
    return { r: c[0], g: c[1], b: c[2], a: c[3] };
  }
  l.from0to1 = e;
  function t(c, u) {
    return { ...mt.fromHex(c), a: u };
  }
  l.fromHexAndA = t;
  function o(c) {
    return { r: Math.round(c.r * 255), g: Math.round(c.g * 255), b: Math.round(c.b * 255), a: c.a };
  }
  l.toRgb255a1 = o;
  function i(c, u) {
    return mt.equals(c, u) && c.a === u.a;
  }
  l.equals = i;
  function s(c, u, a) {
    return { r: c.r + (u.r - c.r) * a, g: c.g + (u.g - c.g) * a, b: c.b + (u.b - c.b) * a, a: c.a + (u.a - c.a) * a };
  }
  l.lerp = s;
})(Gt || (Gt = {}));
var Ga;
((r) => r.identity = { position: [0, 0, 0], rotation: [0, 0, 0], scale: [1, 1, 1] })(Ga || (Ga = {}));
var Tm;
((r) => r.defaultData = { mass: 1, stiffness: 80, damping: 10, velocity: 0 })(Tm || (Tm = {}));
var Om;
((r) => r.defaultData = { control1: [0.5, 0], control2: [0.5, 1] })(Om || (Om = {}));
var Am;
((i) => (i.linear = [0, 0, 1, 1], i.ease = [0.25, 0.1, 0.25, 1], i.easeIn = [0.42, 0, 1, 1], i.easeOut = [0, 0, 0.58, 1], i.easeInOut = [0.42, 0, 0.58, 1]))(Am || (Am = {}));
var Qt;
((e) => {
  e.all = ["PerspectiveCamera", "OrthographicCamera"];
  function r(t) {
    return e.all.includes(t);
  }
  e.is = r;
})(Qt || (Qt = {}));
var No;
((o) => {
  o.DefaultUp = [0, 1, 0], o.DefaultTargetOffset = 1e3, o.defaultData = { far: 1e5, type: "OrthographicCamera", perspective: { near: 70, fov: 45, zoom: 1 }, orthographic: { near: -1e5, zoom: 1, autoZoom: false, autoZoomFrustumSize: 790 }, up: o.DefaultUp, isUpVectorFlipped: false, targetOffset: o.DefaultTargetOffset };
  function t(i) {
    return i.type === "PerspectiveCamera" ? i.perspective.zoom : i.orthographic.zoom;
  }
  o.getZoom = t;
})(No || (No = {}));
var Sr;
((e) => {
  function n(t, o = 0.1) {
    return { disabled: false, type: "linear", hideBase: false, count: 3, radial: { radius: Math.max(t[0], t[1]) * 2, start: 0, end: 360, alignment: false, axis: "y", scale: [1, 1, 1], rotation: [0, 0, 0], position: [0, 0, 0] }, toObject: { object: "", spreadType: "random", scale: [0, 0, 0], rotation: [0, 0, 0], position: [0, 0, 0], axis: "x", seed: 0, count: 99, align: "normal" }, linear: { scale: [1, 1, 1], rotation: [0, 0, 0], position: [t[0] + t[0] * o, 0, 0] }, grid: { count: [2, 2, 2], size: t.map((i) => i * (1 + o)), useCenter: true }, randomness: false, randomnessObject: { strength: 100, scale: [0, 0, 0], rotation: [0, 0, 0], position: [0, 0, 0], movement: 1, seed: 0, freqScale: 10, noiseType: "perlin" } };
  }
  e.defaultData = n;
  function r(t, o) {
    let i = { ...t };
    if (Vw.forEach((s) => {
      Object.assign(i, { [s]: o[s] ?? t[s] });
    }), i.radial = { ...t.radial }, o.radial) {
      let s = t.radial, l = o.radial;
      zw.forEach((c) => {
        Object.assign(i.radial, { [c]: l[c] ?? s[c] });
      });
    }
    if (i.linear = { ...t.linear }, o.linear) {
      let s = t.linear, l = o.linear;
      jw.forEach((c) => {
        Object.assign(i.linear, { [c]: l[c] ?? s[c] });
      });
    }
    if (i.grid = { ...t.grid }, o.grid) {
      let s = t.grid, l = o.grid;
      Fw.forEach((c) => {
        Object.assign(i.grid, { [c]: l[c] ?? s[c] });
      });
    }
    if (i.toObject = { ...t.toObject }, o.toObject) {
      let s = t.toObject, l = o.toObject;
      kw.forEach((c) => {
        Object.assign(i.toObject, { [c]: l[c] ?? s[c] });
      });
    }
    if (i.randomnessObject = { ...t.randomnessObject }, o.randomnessObject) {
      let s = t.randomnessObject, l = o.randomnessObject;
      Uw.forEach((c) => {
        Object.assign(i.randomnessObject, { [c]: l[c] ?? s[c] });
      });
    }
    return i;
  }
  e.merge = r;
})(Sr || (Sr = {}));
var Ra;
((t) => {
  t.defaultData = { radial: {}, linear: {}, grid: {}, toObject: {}, randomnessObject: {} };
  let r = ["radial", "linear", "grid", "toObject", "randomnessObject"];
  function e(o, i) {
    let s = [];
    o.count !== void 0 && s.push({ type: 0, path: i, props: { count: o.count } });
    for (let l of r) {
      let c = o[l];
      c && Object.keys(c).length > 0 && s.push({ type: 0, path: [...i, l], props: c });
    }
    return s;
  }
  t.toOps = e;
})(Ra || (Ra = {}));
var Vw = ["count"];
var zw = ["radius", "start", "end", "position", "scale", "rotation"];
var jw = ["position", "scale", "rotation"];
var Fw = ["count", "size"];
var kw = ["count", "position", "scale", "rotation"];
var Uw = ["strength", "scale", "rotation", "position", "movement", "seed", "freqScale"];
var Va;
((e) => {
  e.all = ["PointLight", "SpotLight", "DirectionalLight", "HemisphereLight"];
  function r(t) {
    return e.all.includes(t);
  }
  e.is = r;
})(Va || (Va = {}));
var za;
((e) => {
  function n(t) {
    return r(t);
  }
  e.defaultData = n;
  function r(t) {
    if (t === "PointLight")
      return { type: t, color: Gt.white, intensity: 1, distance: 2e3, decay: 1, shadows: true, shadowResolution: 1024, shadowRadius: 1, depth: 1e5 };
    if (t === "SpotLight")
      return { type: t, color: Gt.white, intensity: 1, distance: 2e3, decay: 1, shadows: true, penumbra: 0, angle: 30 / 180 * Math.PI, depth: 1e5, shadowResolution: 1024, shadowRadius: 1 };
    if (t === "DirectionalLight")
      return { type: t, color: Gt.white, intensity: 1, shadows: true, size: 2e3, depth: 1e5, shadowResolution: 1024, shadowRadius: 1 };
    throw new Error("not implemented");
  }
})(za || (za = {}));
var _c;
((e) => {
  e.defaultData = { castShadow: true, receiveShadow: true };
  function r(t, o) {
    return t.castShadow === o.castShadow && t.receiveShadow === o.receiveShadow;
  }
  e.equals = r;
})(_c || (_c = {}));
var Pc;
((e) => {
  e.defaultData = { flatShading: false, wireframe: false, side: 0 };
  function r(t, o) {
    return t.flatShading === o.flatShading && t.side === o.side && t.wireframe === o.wireframe;
  }
  e.equals = r;
})(Pc || (Pc = {}));
var ja;
((r) => r.defaultData = { ...Pc.defaultData, ..._c.defaultData })(ja || (ja = {}));
var Nn;
((e) => (e.defaultVideo = { data: "", thumb: "/_assets/_videos/catThumb.png", type: "video", name: "Cat video" }, e.maxSize = 3e7))(Nn || (Nn = {}));
var Nm;
((r) => {
  function n(e) {
    return e === "texture" || e === "video" || e === "color" || e === "depth" || e === "normal" || e === "gradient" || e === "noise" || e === "fresnel" || e === "rainbow" || e === "toon" || e === "outline" || e === "transmission" || e === "matcap" || e === "displace" || e === "pattern" || e === "light";
  }
  r.is = n;
})(Nm || (Nm = {}));
function Im(n) {
  return n.type !== "displace";
}
var Cm;
((r) => {
  function n(e) {
    return e === "phong" || e === "toon" || e === "lambert" || e === "physical";
  }
  r.is = n;
})(Cm || (Cm = {}));
var Mm = ["mode", "gradientType", "noiseType", "displacementType", "projection", "cnormal", "crop", "axis", "side"];
var Em = ["wrapping", "image", "video"];
var xt;
((o) => {
  function n(i, s) {
    let { texture: l, ...c } = s;
    if (Object.assign(i, c), l) {
      let u = i.texture;
      u && Object.assign(u, l);
    }
  }
  o.patch = n;
  function r(i, s) {
    return i === "light" && s ? e(s) : t(i);
  }
  o.defaultData = r;
  function e(i) {
    let s = { mode: 0, isMask: false, visible: true };
    switch (i) {
      case "phong":
        return { ...s, category: "phong", specular: { r: 0.2, g: 0.2, b: 0.2 }, shininess: 5, type: "light", visible: true, mode: 0, occlusion: true, alpha: 0.6 };
      case "toon":
        return { ...s, category: "toon", specular: { r: 0.2, g: 0.2, b: 0.2 }, shininess: 10, type: "light", alpha: 1 };
      case "lambert":
        return { ...s, category: "lambert", emissive: { r: 0, g: 0, b: 0 }, type: "light", alpha: 1, visible: true, mode: 0, occlusion: true };
      case "physical":
        return { ...s, category: "physical", roughness: 0.2, metalness: 0.2, reflectivity: 0.2, type: "light", alpha: 1, visible: true, mode: 0, occlusion: true };
    }
  }
  function t(i) {
    let s = { alpha: 1, mode: 0, isMask: false, visible: true };
    switch (i) {
      case "texture":
        return { ...s, type: "texture", size: [128, 128], blending: 0, axis: "x", side: 2, projection: 0, texture: { image: "image_0", wrapping: 1e3, repeat: [1, 1], offset: [0, 0] }, crop: false };
      case "video":
        return { ...s, type: "video", size: [128, 128], blending: 0, axis: "x", side: 2, projection: 0, texture: { video: Nn.defaultVideo, wrapping: 1001, repeat: [1, 1], offset: [0, 0] }, crop: false };
      case "color":
        return { ...s, type: "color", color: mt.fromHex(5526619) };
      case "depth":
        return { ...s, type: "depth", gradientType: 1, smooth: false, isVector: true, isWorldSpace: false, origin: [0, 0, 0], direction: [1, 0, 0], colors: [[1, 1, 1, 1], [0, 0, 0, 1]], steps: [0, 1], near: 50, far: 200 };
      case "normal":
        return { ...s, type: "normal", cnormal: [1, 1, 1] };
      case "gradient":
        return { ...s, type: "gradient", gradientType: 0, smooth: false, colors: [[0, 0, 0, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], steps: [0, 1, 1, 1, 1, 1, 1, 1, 1, 1], num: 2, angle: 0, offset: [0, 0], morph: [0, 0] };
      case "noise":
        return { ...s, type: "noise", size: [100, 100, 100], noiseType: 0, scale: 1, move: 1, colorA: { ...mt.fromHex(6710886), a: 1 }, colorB: { ...mt.fromHex(6710886), a: 1 }, colorC: { ...mt.fromHex(16777215), a: 1 }, colorD: { ...mt.fromHex(16777215), a: 1 }, distortion: [1, 1], fA: [1.7, 9.2], fB: [8.3, 2.8], voronoiStyle: 0, highCut: 1, lowCut: 0, smoothness: 0.3, seed: 0, quality: 1 };
      case "fresnel":
        return { ...s, type: "fresnel", color: Gt.fromHexAndA(16777215, 1), bias: 0.1, scale: 1, intensity: 2, factor: 1 };
      case "rainbow":
        return { ...s, type: "rainbow", filmThickness: 30, movement: 0, wavelengths: [0, 0, 0], noiseStrength: 0, noiseScale: 1, offset: [0, 0, 0] };
      case "toon":
        return { ...s, type: "toon", positioning: 2, colors: [[0, 0, 0, 1], [0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], steps: [0, 0.475, 0.525, 1, 1, 1, 1, 1, 1, 1], num: 4, source: [0, 1e3, 0], isWorldSpace: true, noiseStrength: 0, noiseScale: 1, shadowColor: Gt.fromHexAndA(0, 0), offset: [0, 0, 0] };
      case "outline":
        return { ...s, type: "outline", outlineColor: Gt.fromHexAndA(0, 1), contourColor: Gt.fromHexAndA(0, 1), outlineWidth: 2, contourWidth: 5, outlineThreshold: 0.4, contourThreshold: 0, outlineSmoothing: 0, contourFrequency: 10, contourDirection: [0, 1, 0], positionalLines: false, compensation: true };
      case "matcap":
        return { ...s, type: "matcap", texture: { image: "matcap_0", wrapping: 1001, repeat: [1, 1], offset: [0, 0] } };
      case "transmission":
        return { ...s, type: "transmission", thickness: 10, ior: 1.5, roughness: 1 };
      case "displace":
        return { visible: true, type: "displace", displacementType: "noise", noiseType: 0, scale: 10, movement: 1, offset: [0, 0, 0], intensity: 8, voronoiStyle: 0, smoothness: 0.3, seed: 0, highCut: 1, lowCut: 0, quality: 1 };
      case "pattern":
        return { ...s, type: "pattern", style: 0, projection: 0, axis: "y", blending: 0, offset: [0, 0], colorA: { ...mt.fromHex(0), a: 1 }, colorB: { ...mt.fromHex(16777215), a: 1 }, frequency: [10, 10], size: 0.5, variation: 0, smoothness: 0.5, zigzag: 0, rotation: 0, vertical: [0, 1], horizontal: [0, 1], sides: 6 };
    }
  }
})(xt || (xt = {}));
var Ot;
((c) => {
  function n(u) {
    return !u.layers.some((d) => d.data.type === "texture" && d.data.projection !== 0 || d.data.type === "depth" && !d.data.isWorldSpace || d.data.type === "noise" || d.data.type === "displace");
  }
  c.isMergable = n;
  function r(u) {
    let a = "";
    return u.layers.forEach((d) => {
      Object.entries(d.data).forEach(([p, f]) => {
        a += `${p}${f}`, Array.isArray(f) ? f.forEach((m) => a += `${m}`) : typeof f == "object" ? Object.values(f).forEach((m) => {
          typeof m == "number" ? a += `${m.toFixed(4)}` : a += `${m}`;
        }) : a += `${f}`;
      });
    }), a;
  }
  c.getHash = r;
  function e() {
    return { layers: new he() };
  }
  c.defaultEmptyData = e;
  function t(u = "layer1", a = "layer2") {
    return i("phong", u, a);
  }
  c.defaultData = t;
  function o(u, a) {
    return { ...u, name: a };
  }
  c.withName = o;
  function i(u, a = "layer1", d = "layer2") {
    let p = new he();
    return p.push({ fi: 0, data: xt.defaultData("light", u), id: a }), p.push({ fi: 1, data: xt.defaultData("color"), id: d }), { layers: p };
  }
  c.defaultTwoLayerData = i;
  function s(u, a = "phong", d = "layer1", p = "layer2") {
    let f = xt.defaultData("texture");
    Object.assign(f.texture, { image: u });
    let m = new he();
    return m.push({ fi: 0, data: f, id: d }), m.push({ fi: 1, data: xt.defaultData("light", a), id: p }), { layers: m };
  }
  c.defaultTwoLayerTextureData = s;
  function l(u, a = "phong", d = "layer1", p = "layer2") {
    let f = xt.defaultData("video");
    Object.assign(f.texture, { video: u });
    let m = new he();
    return m.push({ fi: 0, data: f, id: d }), m.push({ fi: 1, data: xt.defaultData("light", a), id: p }), { layers: m };
  }
  c.defaultTwoLayerVideoTextureData = l;
})(Ot || (Ot = {}));
var Cn;
((r) => {
  function n() {
    return { points: new he(), roundness: 0, shapeHoles: [], isClosed: false };
  }
  r.defaultData = n;
})(Cn || (Cn = {}));
var In;
((r) => {
  function n() {
    return { points: new he(), lastInsertionPlane: null, subdivisions: 12, isClosed: false };
  }
  r.defaultData = n;
})(In || (In = {}));
var Tc = { type: "Ellipse", width: 100, height: 100, spikes: 64, angle: 360, innerRadius: 0 };
var Fa;
((r) => {
  function n(e, t) {
    let o = { ...e };
    return Hw.forEach((i) => {
      Object.assign(o, { [i]: t[i] ?? e[i] });
    }), o;
  }
  r.merge = n;
})(Fa || (Fa = {}));
var ka = { shape: Tc, depth: 1, offset: 0, bevel: 0, bevelSides: 1, angle: 0, twist: 0, startScale: 1, endScale: 1 };
var Hw = ["depth", "offset", "angle", "twist", "startScale", "endScale"];
var Zi;
((e) => {
  function n(t) {
    return t === "PolygonGeometry" || t === "RectangleGeometry" || t === "StarGeometry" || t === "TriangleGeometry" || t === "EllipseGeometry";
  }
  e.is2DParametricMesh = n;
  function r(t) {
    return t === "PolygonGeometry" || t === "PolygonGeometry" || t === "RectangleGeometry" || t === "StarGeometry" || t === "TriangleGeometry" || t === "EllipseGeometry" || t === "PathGeometry" || t === "VectorGeometry" || t === "ConeGeometry" || t === "CubeGeometry" || t === "CylinderGeometry" || t === "DodecahedronGeometry" || t === "HelixGeometry" || t === "IcosahedronGeometry" || t === "LatheGeometry" || t === "PyramidGeometry" || t === "SphereGeometry" || t === "PlaneGeometry" || t === "BackdropGeometry" || t === "TorusGeometry" || t === "TorusKnotGeometry" || t === "BooleanGeometry" || t === "TextGeometry";
  }
  e.isParametricMesh = r;
})(Zi || (Zi = {}));
var Ua;
((r) => {
  function n(e, t) {
    let o = { ...e };
    return Object.assign(o, t), o.type === "PathGeometry" && "extrusion" in t && t.extrusion && (o.extrusion = { ...e.extrusion }, Object.assign(o.extrusion, Fa.merge(o.extrusion, t.extrusion))), o;
  }
  r.merge = n;
})(Ua || (Ua = {}));
var co;
((r) => {
  function n(e) {
    if (e === "RectangleGeometry")
      return { width: 320, height: 320, type: e, cornerRadius: [0, 0, 0, 0], cornerType: 0, depth: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1 };
    if (e === "PathGeometry")
      return { type: e, width: 1, height: 1, depth: 1, path: In.defaultData(), extrusion: ka };
    if (e === "VectorGeometry")
      return { width: 1, height: 1, type: e, subdivisions: 12, shape: Cn.defaultData(), depth: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1 };
    if (e === "BooleanGeometry")
      return { type: e, operation: 2, width: 0, height: 0, depth: 0, phongAngle: 35 };
    if (e === "TextGeometry")
      return { type: e, width: 100, height: 100, depth: 0, horizontalAlign: 1, verticalAlign: 1, fontSize: 16, lineHeight: 1.2, letterSpacing: 0, text: "", textTransform: 1, font: "Roboto_regular", extrudeBevelSize: 0, extrudeBevelSegments: 1 };
    if (e === "SphereGeometry")
      return { type: "SphereGeometry", width: 100, height: 100, depth: 100, widthSegments: 64, heightSegments: 64, phiStart: 0, phiLength: 2 * Math.PI, thetaStart: 0, thetaLength: Math.PI };
    throw new Error("not implemented");
  }
  r.defaultData = n;
})(co || (co = {}));
var Lm;
((e) => {
  function n(t) {
    return t === "Component" || t === "Instance";
  }
  e.isComponentRelated = n;
  function r(t) {
    return t === "Empty" || t === "Instance";
  }
  e.isEmptyOrComponent = r;
})(Lm || (Lm = {}));
var Mn;
((o) => {
  o.identity = { ...Ga.identity, hiddenMatrix: lo.identity };
  function r(i) {
    return { position: i.position, rotation: i.rotation, scale: i.scale, hiddenMatrix: i.hiddenMatrix };
  }
  o.fromObject = r;
  function e(i, s) {
    return { position: (s == null ? void 0 : s.position) || i.position, rotation: (s == null ? void 0 : s.rotation) || i.rotation, scale: (s == null ? void 0 : s.scale) || i.scale, hiddenMatrix: (s == null ? void 0 : s.hiddenMatrix) || i.hiddenMatrix };
  }
  o.merge = e;
  function t(i, s) {
    return Su({ position: ao.isEqual(i.position, s.position) ? void 0 : s.position, rotation: ao.isEqual(i.rotation, s.rotation) ? void 0 : s.rotation, scale: ao.isEqual(i.scale, s.scale) ? null : s.scale, hiddenMatrix: lo.isEqual(i.hiddenMatrix, s.hiddenMatrix) ? void 0 : s.hiddenMatrix });
  }
  o.diff = t;
})(Mn || (Mn = {}));
var Bm;
((r) => r.defaultData = { fusedBody: true, rigidBody: "positioned", density: 1, pointMass: 0, gravityScale: 1, friction: 0.5, damping: 0, restitution: 0.2, colliderType: "convex", enabledRotation: [true, true, true], enabledTranslation: [true, true, true] })(Bm || (Bm = {}));
var Rt;
((r) => r.defaultData = { states: new he(), events: new he(), visible: true, raycastLock: false, collision: "visibility", physics: null, pathSnapping: { pathId: null, slide: 0, offset: 0, orientation: "tangential" }, ...Mn.identity, cloner: null })(Rt || (Rt = {}));
var Dm;
((r) => r.defaultData = { type: "Empty", ...Rt.defaultData })(Dm || (Dm = {}));
var Gm;
((r) => r.defaultData = { type: "Component", ...Rt.defaultData })(Gm || (Gm = {}));
var Co;
((r) => r.defaultData = { type: "Mesh", ...Rt.defaultData, ...ja.defaultData })(Co || (Co = {}));
var En;
((r) => r.defaultData = { ...Rt.defaultData, ...Mn.identity, ...No.defaultData })(En || (En = {}));
var Rm;
((r) => {
  function n(e) {
    return { ...Rt.defaultData, ...za.defaultData(e) };
  }
  r.defaultData = n;
})(Rm || (Rm = {}));
var Ln;
((e) => {
  function n(t, o, i = 0) {
    for (; i < o.length; ) {
      let s = t ? t[o[i]] : void 0;
      if (o.length === i + 1)
        return s;
      if (s)
        t = s.descendants, i += 1;
      else
        return;
    }
  }
  e.resolveWithDes = n;
  function r(t, o, i = 0) {
    let s = n(t, o, i);
    if (s) {
      let l = Object.keys(s);
      if (l.length === 1 && l[0] === "descendants")
        return;
    }
    return s;
  }
  e.resolve = r;
})(Ln || (Ln = {}));
var uo;
((i) => {
  i.rootOverrideProps = ["physics"], i.compositeNonOptionalOverrideProps = ["geometry"], i.compositeEntireOverrideOverrideProps = ["material"];
  function t(s, l) {
    return { ...Rt.defaultData, ...l, component: s, overrides: new Be(), physics: void 0, type: "Instance" };
  }
  i.ofComponent = t;
  function o(s) {
    let l = Mn.fromObject(s.data);
    return t(s.id, l);
  }
  i.fromComponentData = o;
})(uo || (uo = {}));
var Vm;
((i) => (i.defaultCamera = { position: [0, 0, 1e3], scale: [1, 1, 1], rotation: [0, 0, 0], hiddenMatrix: lo.identity, name: "Play Camera", visible: true, raycastLock: false, collision: "visibility", physics: null, states: new he(), events: new he(), cloner: null, pathSnapping: { pathId: null, orientation: "tangential", slide: 0, offset: 0 }, ...No.defaultData }, i.KeysByResetCategory = { States: ["states"], Events: ["events"], Material: ["material", "materials"], Geometry: ["geometry"], Position: ["position"], Rotation: ["rotation"], Scale: ["scale"], Transform: ["position", "scale", "rotation", "hiddenMatrix"], Name: ["name"], Visibility: ["visible", "raycastLock", "flatShading", "wireframe", "side"], Shadows: ["castShadow", "receiveShadow"], Cloner: ["cloner"], Physics: ["physics"] }, i.defaultMeshObject = { name: "Rectangle", ...Rt.defaultData, ...Co.defaultData, geometry: co.defaultData("RectangleGeometry"), material: Ot.defaultTwoLayerData("phong", "layer1", "layer2") }, i.defaultBooleanObject = { name: "Boolean", ...Rt.defaultData, ...Co.defaultData, geometry: co.defaultData("BooleanGeometry"), material: Ot.defaultTwoLayerData("phong", "layer1", "layer2") }, i.defaultTextObject = { name: "Text", ...Rt.defaultData, ...Co.defaultData, geometry: co.defaultData("TextGeometry"), material: Ot.defaultTwoLayerData("phong", "layer1", "layer2") }))(Vm || (Vm = {}));
var Io;
((o) => {
  function n(i, s) {
    let l = { name: s };
    return i.type === "Mesh" ? (l.geometry = {}, "material" in i && (l.material = { layers: new Be() }), "materials" in i && (l.materials = i.materials.map((c) => ({ layers: new Be() })))) : Qt.is(i.type) && (l.perspective = {}, l.orthographic = {}), l;
  }
  o.newEmpty = n;
  function r(i, s) {
    if (s === void 0)
      return i;
    let l = { ...i };
    return "material" in l && "material" in s && s.material && (l.material = On(l.material, (c) => {
      if (typeof c != "string")
        for (let [u, a] of Object.entries(s.material.layers)) {
          let d = c.layers.data(u);
          d && xt.patch(d, a);
        }
    }).data), l.materials && s.materials && (l.materials = On(l.materials, (c) => {
      var _a2, _b2;
      for (let u = 0; u < l.materials.length; u++) {
        let a = s.materials[u];
        if (typeof a != "string")
          for (let [d, p] of Object.entries(a.layers)) {
            let f = (_b2 = (_a2 = c[u]) == null ? void 0 : _a2.layers) == null ? void 0 : _b2.data(d);
            f && xt.patch(f, p);
          }
      }
    }).data), l;
  }
  function e(i, s) {
    let l, c = [], u = { orthographic: 0, perspective: 0, geometry: 0 };
    function a(d, p) {
      for (let [f, m] of Object.entries(p.layers)) {
        let { texture: h, ...y } = m;
        if (h !== void 0 && Object.keys(h).length > 0) {
          let g = { path: [...d, "layers", f, "texture"], props: h, type: 0 };
          c.push(g);
        }
        if (Object.keys(y).length > 0) {
          let g = { path: [...d, "layers", f], props: y, type: 0 };
          c.push(g);
        }
      }
    }
    for (let [d, p] of Object.entries(s))
      if (d !== "name")
        if (d === "cloner")
          c.push(...Ra.toOps(p, ["cloner"]));
        else if (d === "pathSnapping")
          c.push({ path: [d], props: { slide: p.slide, offset: p.offset }, type: 0 });
        else if (d === "material")
          a(["material"], p);
        else if (d === "materials")
          for (let [f, m] of Object.entries(p))
            a(["materials", f], m);
        else if (u[d] === 0) {
          if (d === "geometry" && p.extrusion !== void 0) {
            let f = { path: [d, "extrusion"], props: p.extrusion, type: 0 };
            c.push(f), p = { ...p }, delete p.extrusion;
          }
          if (Object.keys(p).length > 0) {
            let f = { path: [d], props: p, type: 0 };
            c.push(f);
          }
        } else
          l === void 0 && (l = { path: [], props: {}, type: 0 }, c.push(l)), l.props[d] = p;
    return c;
  }
  o.toOps = e;
  function t(i, s) {
    var _a2, _b2, _c2, _d, _e2, _f2;
    if (s === void 0)
      return i;
    let l = { ...i };
    if (Object.assign(l, Mn.merge(l, s)), Object.assign(l, { pathSnapping: Object.assign({}, l.pathSnapping, { slide: ((_a2 = s.pathSnapping) == null ? void 0 : _a2.slide) ?? ((_b2 = l.pathSnapping) == null ? void 0 : _b2.slide) ?? 0, offset: ((_c2 = s.pathSnapping) == null ? void 0 : _c2.offset) ?? ((_d = l.pathSnapping) == null ? void 0 : _d.offset) ?? 0 }) }), Qt.is(i.type)) {
      l.orthographic = { ...l.orthographic }, l.perspective = { ...l.perspective };
      let c = s;
      ((_e2 = c.orthographic) == null ? void 0 : _e2.zoom) !== void 0 && (l.orthographic.zoom = c.orthographic.zoom), ((_f2 = c.perspective) == null ? void 0 : _f2.zoom) !== void 0 && (l.perspective.zoom = c.perspective.zoom), c.isUpVectorFlipped !== void 0 && (l.isUpVectorFlipped = c.isUpVectorFlipped), c.targetOffset !== void 0 && (l.targetOffset = c.targetOffset);
    } else if (i.type === "Mesh")
      "geometry" in s && Object.assign(l, { geometry: Ua.merge(l.geometry, s.geometry) }), (s.material || s.materials) && (l = r(l, s)), l.cloner && "cloner" in s && Object.assign(l, { cloner: Sr.merge(l.cloner, s.cloner) });
    else if (i.type === "Empty")
      l.cloner && "cloner" in s && Object.assign(l, { cloner: Sr.merge(l.cloner, s.cloner) });
    else if (Va.is(i.type)) {
      let c = s;
      c.intensity !== void 0 && (l.intensity = c.intensity), c.color !== void 0 && (typeof c.color == "string" ? l.color = c.color : l.color = mt.clone(c.color));
    }
    return l;
  }
  o.patch = t;
})(Io || (Io = {}));
var Bn;
((r) => r.defaultData = { enablePan: true, enableZoom: true, enableRotate: true, enableDamping: true, rotationLimitsMode: 0, rotationVerticalOffset: { min: Math.PI / 4, max: Math.PI / 4 }, rotationHorizontalOffset: { min: Math.PI / 4, max: Math.PI / 4 }, rotationSoftLimit: 2, panLimitsMode: 0, panVerticalOffset: { min: 250, max: 250 }, panHorizontalOffset: { min: 250, max: 250 }, panSoftLimit: 2, zoomLimitsEnabled: false, zoomLimits: { min: 0.1, max: 2 }, autoRotate: false, autoRotateSpeed: 2, autoRotateClockwise: true, hoverRotatePanMode: 0, hoverRotatePanStrength: 20, isTouchZoom: true, orbitTouches: 2, panTouches: 3, resetHoverEffectOnPointerLeave: true, autoZoom: false })(Bn || (Bn = {}));
var Ha;
((r) => r.defaultData = { orbitControls: Bn.defaultData, playCamera: null, withBackground: true, preventScroll: false, preventTouchScroll: false, hideCursor: false, mouseEventTarget: "canvas", settings: { image: { format: "jpg", ratio: 1 }, video: { format: "mp4", imageFormat: "jpg", fps: 30, mbps: 80, ratio: Math.max(1, typeof window < "u" ? Math.floor(window.devicePixelRatio) : 1), stopMode: "manual", duration: 5e3 }, web: { logo: true, compress: true, preset: 1, preload: true, hint: false } }, stopRaycast: true, joystickSizeAndXYOffset: Array(12).fill(0).map((e, t) => {
  let o = 0, i = 0;
  return t < 5 ? i = -30 : t < 10 && (i = 30), t === 0 || t === 10 || t === 5 ? o = 30 : (t === 4 || t === 11 || t === 9) && (o = -30), [120, [o, i], "show"];
}), gameControlObject: null, hdTransmission: false })(Ha || (Ha = {}));
var Oc;
((r) => r.defaultData = { id: "basic", label: "Basic", style: "None", prompt: "" })(Oc || (Oc = {}));
var Ac;
((r) => r.defaultData = { weather: 0, shadows: 0, lightOrigin: 0, temperature: 0, sun: 0, camera: 0, environment: 0, particles: 0, nature: 0, floor: 0 })(Ac || (Ac = {}));
var qa;
((e) => (e.defaultData = () => ({ mode: "line-art-both", prompt: "", negativePrompt: "", style: { ...Oc.defaultData }, isRandomSeed: true, seed: e.generateSeed(), guessMode: false, advanced: false, steps: 20, guidanceScale: 7.5, controlNetScale: 1, modifiers: Ac.defaultData }), e.generateSeed = () => Math.round(Math.random() * 1e5)))(qa || (qa = {}));
var Dn;
((r) => r.emptyImage = { data: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=" })(Dn || (Dn = {}));
var Wa;
((t) => {
  function n() {
    let o = {};
    return o["89b10010-844c-11ec-a8a3-0242ac120002"] = { r: 0.5, g: 0.5, b: 0.5, a: 1, name: "Default Color" }, Vr(o, Me.prototype);
  }
  t.defaultColors = n;
  function r(o) {
    let i = {};
    return (o == null ? void 0 : o.withAITexture) && (i["a1b10010-844c-a8a3-11ec-0242ac2011ec"] = { ...Dn.emptyImage, name: "AI generated image" }), Vr(i, Me.prototype);
  }
  t.defaultImages = r;
  function e() {
    return { materials: new Me(), images: new Me(), videos: new Me(), colors: new Me(), audios: new Me(), fonts: new Me(), penumbraSize: [2, 2, 2] };
  }
  t.emptyData = e;
})(Wa || (Wa = {}));
var $a;
((e) => (e.defaultColliderData = { type: "capsule", height: 200, radius: 50, position: [0, 0, 0], rotation: [0, 0, 0] }, e.defaultDataThirdPerson = { moveMode: "walk", speedTranslate: 1e3, speedRotate: 100, rotationMode: "normal", rotBy: "keys", rotByTouch: "drag", delayPos: [0.3, 0.3], delayRot: [0.3, 0.3], keyAssignments: [["moveNegZ", "W"], ["moveNegX", "A"], ["movePosZ", "S"], ["movePosX", "D"], ["rotPosX", ""], ["rotPosY", ""], ["rotNegX", ""], ["rotNegY", ""], ["jump", "Space"]], touchControl: true, joystickPosLoc: 5, joystickRotLoc: 11, jumpTouchButtonLoc: 9, collider: e.defaultColliderData, colliderHelperVisible: true, collisionEnabled: true, jumpPower: 100, resetYPosition: 3e3, alignToGround: false, autoOrientMove: true, orientWith: "camera", orientMode: "radial", delayPosCamera: 0.3, delayRotCamera: 0.3, camera: "", cameraXAxis: "Limit", cameraYAxis: "Free", cameraRotXLimits: [0, Math.PI / 2], cameraRotYLimits: [-Math.PI / 2, Math.PI / 2], gameActions: { idle: new he(), move: new he(), jump: new he() }, navmesh: { enabled: false, ch: 6, cs: 6, walkableClimb: 5, walkableHeight: 1, walkableRadius: 0, zones: "all", objects: [], helperVisible: true, destinationHelperRadius: 0, destinationHelperColor: Gt.fromHexAndA(3728051, 1) } }))($a || ($a = {}));
function zm(n) {
  n.layers.forEach((r) => {
    if (r.type === "depth" && r.colorA !== void 0) {
      let e = r.colorA, t = r.colorB, o = [[e.r, e.g, e.b, e.a], [t.r, t.g, t.b, t.a]], i = [0, 1];
      for (let l = 2; l < 10; l++)
        o.push(o[1]), i.push(1);
      let s = { ...vn(Qe(r), "type", "visible", "isVector", "isWorldSpace", "origin", "alpha", "mode"), near: Math.max(0, r.near), far: Math.max(0, r.far), colors: o, steps: i, num: 2, direction: [1, 0, 0], smooth: false, gradientType: 1 };
      Object.assign(r, s);
    } else if (r.type === "depth" && r.gradientType === 1 && (r.near < 0 || r.far < 0)) {
      let e = { ...Qe(r), near: Math.max(r.near, 0), far: Math.max(r.far, 0) };
      Object.assign(r, e);
    }
  });
}
function Gn(n, r) {
  Object.values(n.shared.materials).forEach((e) => r(e));
}
function Rn(n, r) {
  n.scene.objects.traverse((e, t) => {
    "materials" in t ? t.materials.forEach((o) => {
      typeof o != "string" && r(o);
    }) : "material" in t && typeof t.material != "string" && r(t.material);
  });
}
function qw(n) {
  Object.assign(n.scene.publish, { orbitControls: { ...Bn.defaultData, ...Qe(n.scene.publish.orbitControls) } });
}
function Ww(n) {
  Object.assign(n.scene.publish.settings, { video: { ...Ha.defaultData.settings.video, ...Qe(n.scene.publish.settings.video) } });
}
function $w(n) {
  function r(e) {
    if (e.layers) {
      for (let t of Object.values(e.layers))
        if (t) {
          for (let [o, i] of Object.entries(t))
            if ((Mm.includes(o) || typeof i == "boolean") && delete t[o], o === "texture")
              for (let [s, l] of Object.entries(i))
                (Em.includes(s) || typeof l == "boolean") && delete i[s];
        }
    }
  }
  n.scene.objects.traverse((e, t) => {
    t.states.forEach((o) => {
      let i = o;
      i.material ? r(i.material) : i.materials && i.materials.forEach((s) => {
        r(s);
      });
    });
  });
}
function Yw(n) {
  n.scene.publish.withBackground = true;
}
function Xw(n) {
  n.scene.publish.settings.web = { compress: true, preload: true, preset: 1, logo: true, hint: false };
}
function Kw(n) {
  n.scene.objects.traverse((r, e) => {
    let t = e.cloner;
    t && (t.radial.scale = t.radial.scale.map((o) => o + 1), t.linear.scale = t.linear.scale.map((o) => o + 1));
  });
}
function Zw(n) {
  n.scene.objects.traverse((r, e) => {
    let t = e.geometry;
    t && (t.type === "DodecahedronGeometry" || t.type === "IcosahedronGeometry") && (t.detail = Math.round(t.detail));
  });
}
function Qw(n) {
  n.scene.objects.traverse((r, e) => {
    let t = n.scene.objects.unproxy().parent(r);
    if (t) {
      let o = Qe(n.scene.objects.data(t));
      o && o.type === "Mesh" && o.geometry.type === "BooleanGeometry" && e.type === "Mesh" && (e.visible = Qe(e).booleanExclude !== true);
    }
  });
}
function Jw(n) {
  n.scene.objects.traverse((r, e) => {
    if (e.type === "Mesh") {
      let t = e;
      e.geometry.type === "NonParametricGeometry" ? t.material !== void 0 && delete t.material : t.materials !== void 0 && delete t.materials;
    }
  });
}
function e_(n) {
  function r(t) {
    Object.setPrototypeOf(t, Be.prototype), t.texture && Object.setPrototypeOf(t.texture, Be.prototype);
  }
  function e(t) {
    Object.setPrototypeOf(t, Be.prototype);
    for (let o in t)
      r(t[o]);
  }
  n.scene.objects.traverse((t, o) => {
    o.states.forEach((i) => {
      let s = i;
      if (s.material) {
        let l = Qe(s.material).layers;
        e(l), s.material.layers = l;
      }
      if (s.materials)
        for (let l = 0; l < s.materials.length; l++) {
          let c = s.materials[l], u = Qe(c).layers;
          e(u), c.layers = u;
        }
    });
  });
}
function jm(n) {
  n.layers === void 0 && Object.assign(n, Ot.defaultTwoLayerData("lambert"));
}
function Nc(n) {
  !n.layers || n.layers.forEach((r) => {
    if (r.type === "depth" && r.colors.length === 10) {
      let e = [...r.colors];
      e.push(r.colors[9]);
      let t = [...r.steps];
      t.push(r.steps[9]);
      let o = { ...Qe(r), colors: e, steps: t };
      Object.assign(r, o);
    }
  });
}
function t_(n) {
  n.scene.objects.traverse((r, e) => {
    e.type === "Mesh" && (e.geometry.type === "BooleanGeometry" || e.geometry.type === "SubdivGeometry") && (e.geometry.phongAngle = 35);
  });
}
function Fm(n) {
  n.scene.objects.traverse((r, e) => {
    "materials" in e ? e.materials.forEach((t) => {
      typeof t != "string" && Nc(t);
    }) : "material" in e && typeof e.material != "string" && Nc(e.material);
  }), Object.values(n.shared.materials).forEach((r) => Nc(r));
}
function r_(n) {
  n.scene.environment.ambientLight.softShadows = false, n.scene.environment.ambientLight.softShadowQuality = "low", n.scene.objects.traverse((r, e) => {
    (e.type === "DirectionalLight" || e.type === "SpotLight") && (e.shadowResolution = 1024, e.shadowRadius = 1, e.depth = 1e5);
  }), n.shared.penumbraSize = new Array(5).fill(0.5);
}
function o_(n) {
  n.shared.audios = Vr({}, Me.prototype);
}
function n_(n) {
  n.shared.videos = Vr({}, Me.prototype);
}
function i_(n) {
  let r = n.shared.materials;
  Object.entries(r).forEach(([e, t]) => {
    if (!t.layers) {
      let o = { name: "Untitled Material", layers: [{ fi: 0, data: { type: "light", category: "phong", alpha: 0.6, visible: true, mode: 0, specular: { r: 0.2, g: 0.2, b: 0.2 }, shininess: 5 }, id: "layer1" }, { fi: 1, data: { type: "color", alpha: 1, visible: true, mode: 0, color: { r: 0.2823529411764706, g: 0.2823529411764706, b: 0.30196078431372547 } }, id: "layer2" }] };
      Object.assign(r, { [e]: o });
    }
  });
}
function s_(n) {
  Object.entries(Qe(n.shared.images)).filter((t) => t[1].asset === false).map((t) => t[0]).forEach((t) => {
    delete n.shared.images[t];
  }), Object.entries(Qe(n.shared.audios)).filter((t) => t[1].asset === false).map((t) => t[0]).forEach((t) => {
    delete n.shared.audios[t];
  });
}
function a_(n) {
  n.scene.publish.settings.web.preload = false;
}
function km(n) {
  n.layers && n.layers.forEach((r) => {
    r.type === "depth" && r.num !== void 0 && (r.colors = r.colors.slice(0, r.num), r.steps = r.steps.slice(0, r.num), delete r.num);
  });
}
function Um(n) {
  n.layers && n.layers.forEach((r) => {
    Im(r) && r.isMask === void 0 && (r.isMask = false), (r.type === "texture" || r.type === "video") && r.blending === void 0 && (r.blending = 0), (r.type === "noise" || r.type === "displace" && r.displacementType === "noise") && (r.voronoiStyle === void 0 && (r.voronoiStyle = 0), r.highCut === void 0 && (r.highCut = 1), r.lowCut === void 0 && (r.lowCut = 0), r.smoothness === void 0 && (r.smoothness = 0.3), r.seed === void 0 && (r.seed = 0), r.quality === void 0 && (r.quality = 1));
  });
}
function l_(n) {
  n.shared.fonts = Vr({}, Me.prototype);
}
function c_(n) {
  return n.replace(".typeface", "").replace(/optimer/gi, "open sans").replace("space_mono", "space mono").replace(/alma_mono/gi, "varela round").replace(/droid_sans_mono/gi, "noto sans mono").replace(/droid_sans|gentilis|gnomon_(simple|foreground)|helvetiker/gi, "roboto").replace(/droid_serif/gi, "roboto slab").replace("_sans", " sans").replace("crimson_text", "crimson text").replace("medium_medium", "medium").replace("fatface_fatface", "fatface").replace("100hairline", "thin").replace("200thin", "extralight").replace("300light", "light").replace("500medium", "medium").replace("600semi", "semibold").replace("800heavy", "extrabold").replace("900black", "black").replace(/bodoni_(11|16|24|36|48|72|96)([^_])/gi, "bodoni_$1_$2").replace(/bodoni_(11|16|24|36|48|72|96)/gi, "bodoni moda").replace(/(thin|hairline)(_regular)?/gi, "100").replace(/(extra|ultra)light(_regular)?/gi, "200").replace(/light(_regular)?/gi, "300").replace(/_book|_normal|_roman/gi, "_regular").replace(/medium(_regular)?/gi, "500").replace(/(semi|demi)bold(_regular)?/gi, "600").replace(/(extra|ultra)bold(_regular)?/gi, "800").replace(/bold(_regular)?/gi, "700").replace(/(black|heavy|fatface)(_regular)?/gi, "900").replace(/([1-9]00)_italic/gi, "$1italic").replace(/regularitalic/gi, "italic").replace(/regularitalic/gi, "italic").split(" ").map((e) => e.charAt(0).toUpperCase() + e.slice(1)).join(" ");
}
function d_(n) {
  let r = [];
  n.scene.objects.traverse((e, t) => {
    let o = t;
    if (o.type === "TextFrame") {
      let i = Ot.defaultTwoLayerData("phong"), s = typeof o.color == "string" ? n.shared.colors[o.color] : o.color;
      i.layers[1].data.color = { r: s.r, g: s.g, b: s.b }, i.layers[1].data.alpha = o.alpha;
      let l = c_(o.font);
      n.shared.fonts[l] === void 0 && (n.shared.fonts[l] = { name: l });
      let c = { name: o.name, ...Rt.defaultData, ...Co.defaultData, flatShading: false, wireframe: false, geometry: { ...co.defaultData("TextGeometry"), width: o.width, height: o.height, font: l, depth: 0, horizontalAlign: o.horizontalAlign, verticalAlign: o.verticalAlign, fontSize: o.fontSize * 1.40625, lineHeight: o.lineHeight / 1.40625, letterSpacing: o.letterSpacing - 1, text: o.text, textTransform: o.textTransform, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, material: i, states: Qe(o.states), events: Qe(o.events), visible: o.visible, raycastLock: o.raycastLock, position: o.position, rotation: o.rotation, scale: o.scale, hiddenMatrix: o.hiddenMatrix }, u = Qe(n.scene.objects).parent(e);
      n.scene.objects.insertAfter(u ?? null, e, [{ id: e + "new", data: c, children: [] }]), r.push(e);
    }
  }), r.forEach((e) => {
    n.scene.objects.delete(e);
  });
}
function u_(n) {
  let r = { 0: "MouseDown", 1: "MouseUp", 2: "MouseHover", 5: "KeyDown", 6: "KeyUp", 7: "Start", 9: "LookAt", 10: "Follow", 11: "Scroll", 12: "Audio", 13: "GameControl" };
  n.scene.objects.traverse((e, t) => {
    t.events.forEach((o) => {
      if (!!r[Number(o.type)])
        if (Object.assign(o, { type: r[Number(o.type)] }), o.type === "Audio" && "audioEvent" in o && (Object.assign(o, { playAudio: o.audioEvent }), delete o.audioEvent), o.type === "GameControl")
          Object.assign(o, { gameActions: { idle: new he(), move: new he(), jump: new he() } });
        else {
          let i = new he();
          Object.assign(o, { actions: i }), (o.type === "MouseDown" || o.type === "MouseUp" || o.type === "KeyDown" || o.type === "KeyUp") && "url" in o && i.push({ fi: 0, id: MathUtils.generateUUID(), data: { type: "Link", url: o.url, delay: 0 } }), "targets" in o && (o.targets.forEach((s, l, c) => {
            let u = { state: void 0, repeat: 0, delay: 0, delayDirection: void 0, direction: "normal", duration: 0, easing: 4 }, a = { easing: s.easing, duration: s.duration };
            s.easing === 6 ? Object.assign(a, vn(s, "mass", "stiffness", "damping", "velocity")) : s.easing === 5 && Object.assign(a, { control1: { ...s.control1 }, control2: { ...s.control2 } });
            let d = { repeat: s.repeat ? -1 : 0, delay: s.delay, delayDirection: s.delayDirection, direction: s.cycle && s.rewind ? "pingpong-rewind" : s.cycle ? "pingpong" : "normal" }, p = { state: s.state, ...d, ...a }, f = { allowSlerp: true, type: "Transition", object: s.object, repeat: 0, delay: 0, delayDirection: void 0, direction: "normal", tweens: new he({ fi: 0, id: MathUtils.generateUUID(), data: u }, { fi: 1, id: MathUtils.generateUUID(), data: p }) };
            i.push({ fi: c, id: l, data: f });
          }), delete o.targets);
        }
    });
  });
}
function p_(n) {
  n.scene.objects.traverse((r, e) => {
    function t(o, i) {
      var _a2;
      let s = new he(), l = [];
      if (e.events.forEach((c, u, a) => {
        if (c.type === "Audio" && c.trigger === i) {
          let d;
          l.push(u), c.interaction === "play" ? d = { ...vn(c, "interaction", "audio", "delay", "volume", "loop"), triggerAfter: "after" in c ? c.after : void 0, toggle: "after" in c ? c.toggle : void 0, type: "Audio" } : (c.interaction === "pause" || c.interaction === "stop") && (d = { ...vn(c, "interaction", "delay", "object", "playAudio"), type: "Audio" }), d && s.push({ fi: a, id: u, data: d });
        }
      }), l.forEach((c) => e.events.delete(c)), s.length) {
        let c = (_a2 = e.events.find((u) => u.type === o)) == null ? void 0 : _a2.data;
        c ? "actions" in c && c.actions.insertBefore(null, s) : e.events.insertBefore(null, [{ id: MathUtils.generateUUID(), data: { type: o, actions: s } }]);
      }
    }
    t("Start", "start"), t("MouseDown", "mouseDown"), t("MouseUp", "mouseUp"), t("KeyDown", "keyDown"), t("KeyUp", "keyUp");
  });
}
function Hm(n) {
  var _a2;
  let r = (_a2 = n.layers.find((e) => e.type === "light")) == null ? void 0 : _a2.data;
  if ((r == null ? void 0 : r.category) === "basic") {
    let e = xt.defaultData("light", "phong"), t = r;
    Object.assign(t, e), t.visible = false;
  }
}
function qm(n) {
  Gn(n, Hm), Rn(n, Hm);
}
function f_(n) {
  n.scene.objects.traverse((r, e) => {
    e.type === "Mesh" && e.geometry.type === "SubdivGeometry" && (e.geometry.scaleBaked || (e.geometry.scaleBaked = [1, 1, 1]));
  });
}
function m_(n) {
  n.scene.objects.traverse((r, e) => {
    (e.type === "Empty" || e.type === "Mesh") && e.cloner && !e.cloner.randomnessObject && !e.cloner.toObject && !e.cloner.randomness && (e.cloner = { ...e.cloner, toObject: { object: "", spreadType: "random", scale: [0, 0, 0], rotation: [0, 0, 0], position: [0, 0, 0], axis: "x", seed: 0, count: 99, align: "normal" }, randomness: false, randomnessObject: { strength: 100, scale: [0, 0, 0], rotation: [0, 0, 0], position: [0, 0, 0], movement: 1, seed: 0, freqScale: 10, noiseType: "perlin" } });
  });
}
function h_(n) {
  n.scene.objects.traverse((r, e) => {
    e.type === "Mesh" && e.geometry.type === "NonParametricGeometry" && !("material" in e) && !("materials" in e) && (e.material = Ot.defaultTwoLayerData("phong"));
  });
}
function y_(n) {
  n.scene.publish.orbitControls.autoZoom === void 0 && (n.scene.publish.orbitControls.autoZoom = false), n.scene.objects.traverse((r, e) => {
    (e.type === "OrthographicCamera" || e.type === "PerspectiveCamera") && (e.orthographic.autoZoom === void 0 && (e.orthographic.autoZoom = false), e.orthographic.autoZoomFrustumSize === void 0 && (e.orthographic.autoZoomFrustumSize = 790));
  });
}
function g_(n) {
  n.scene.objects.traverse((r, e) => {
    e.pathSnapping === void 0 && (e.pathSnapping = { pathId: null, slide: 0, offset: 0, orientation: "tangential" }), e.pathSnapping.offset === void 0 && (e.pathSnapping.offset = 0);
  });
}
function x_(n) {
  n.scene.publish.mouseEventTarget === void 0 && (n.scene.publish.mouseEventTarget = "canvas"), n.scene.publish.settings.web.hint === void 0 && (n.scene.publish.settings.web.hint = false);
}
function v_(n) {
  let { video: r } = n.scene.publish.settings;
  r.format === "gif" && r.fps > 48 && (r.fps = 15);
}
function b_(n) {
  n.scene.objects.traverse((r, e) => {
    e.events.forEach((t) => {
      t.type === "GameControl" && (t.resetYPosition = Math.abs(t.resetYPosition - e.position[1]));
    });
  });
}
function S_(n) {
  let r = n.scene.environment.usePhysics;
  n.scene.objects.traverse((e, t) => {
    r && t.physics === null ? t.collision = false : t.collision = "visibility";
  });
}
function w_(n) {
  n.scene.objects.traverse((r, e) => {
    e.events.forEach((t) => {
      t.type === "GameControl" && (t.navmesh = $a.defaultDataThirdPerson.navmesh);
    });
  });
}
function __(n) {
  n.scene.styles || (n.scene.styles = qa.defaultData());
}
function Wm(n) {
  n.layers.forEach((r) => {
    r.type === "light" && r.category !== "toon" && r.occlusion === void 0 && (r.occlusion = true);
  });
}
function P_(n) {
  n.scene.environment.ambientLight.occlusion === void 0 && (n.scene.environment.ambientLight.occlusion = false), n.scene.environment.ambientLight.aoFullRes === void 0 && (n.scene.environment.ambientLight.aoFullRes = false), n.scene.environment.ambientLight.radius === void 0 && (n.scene.environment.ambientLight.radius = 256), n.scene.environment.ambientLight.bias === void 0 && (n.scene.environment.ambientLight.bias = 0.5), n.scene.environment.ambientLight.aoColor === void 0 && (n.scene.environment.ambientLight.aoColor = { r: 0.19607843137254902, g: 0.19607843137254902, b: 0.19607843137254902 }), Rn(n, Wm), Gn(n, Wm);
}
var $m = 41;
function Ym(n) {
  let r = n.schema ?? 0;
  r !== $m && (console.warn("updating from ", r, "to ", $m), r < 1 && (Rn(n, zm), Gn(n, zm), n.schema = 1), r < 2 && (qw(n), n.schema = 2), r < 3 && ($w(n), n.schema = 3), r < 4 && (Yw(n), n.schema = 4), r < 5 && (Xw(n), n.schema = 5), r < 6 && (Kw(n), n.schema = 6), r < 7 && (Zw(n), n.schema = 7), r < 8 && (n.schema = 8), r < 9 && (Fm(n), n.schema = 9), r < 10 && (t_(n), n.schema = 10), r < 11 && (r_(n), n.schema = 11), r < 12 && (Fm(n), n.schema = 12), r < 13 && (o_(n), n.schema = 13), r < 14 && (i_(n), n.schema = 14), r < 15 && (s_(n), n.schema = 15), r < 16 && (a_(n), n.schema = 16), r < 17 && (Rn(n, km), Gn(n, km), n.schema = 17), r < 18 && (Rn(n, jm), Gn(n, jm), n.schema = 18), r < 19 && (Ww(n), n.schema = 19), r < 20 && (l_(n), d_(n), n.schema = 20), r < 21 && (u_(n), p_(n), n.schema = 21), r < 22 && (qm(n), n.schema = 22), r < 23 && (f_(n), n.schema = 23), r < 24 && (m_(n), n.schema = 24), (r < 25 || n.shared.videos === void 0) && (n_(n), r < 25 && (n.schema = 25)), r < 26 && (Qw(n), n.schema = 26), r < 27 && (Jw(n), n.schema = 27), r < 28 && (qm(n), n.schema = 28), r < 29 && (e_(n), n.schema = 29), r < 30 && (h_(n), n.schema = 30), r < 31 && (y_(n), n.schema = 31), r < 33 && (g_(n), n.schema = 33), r < 34 && (x_(n), n.schema = 34), r < 35 && (v_(n), n.schema = 35), r < 36 && (b_(n), n.schema = 36), r < 37 && (S_(n), n.schema = 37), r < 38 && (Rn(n, Um), Gn(n, Um), n.schema = 38), r < 39 && (w_(n), n.schema = 39), r < 40 && (__(n), n.schema = 40), r < 41 && (P_(n), n.schema = 41));
}
var Ii = Ws(Km());
var T_ = 0.5 * (Math.sqrt(3) - 1);
var es = (3 - Math.sqrt(3)) / 6;
var O_ = 1 / 3;
var wr = 1 / 6;
var WR = (Math.sqrt(5) - 1) / 4;
var $R = (5 - Math.sqrt(5)) / 20;
var ts = (n) => Math.floor(n) | 0;
var Zm = new Float64Array([1, 1, -1, 1, 1, -1, -1, -1, 1, 0, -1, 0, 1, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, -1]);
var Ic = new Float64Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]);
function Xa(n = Math.random) {
  let r = Jm(n), e = new Float64Array(r).map((o) => Zm[o % 12 * 2]), t = new Float64Array(r).map((o) => Zm[o % 12 * 2 + 1]);
  return function(i, s) {
    let l = 0, c = 0, u = 0, a = (i + s) * T_, d = ts(i + a), p = ts(s + a), f = (d + p) * es, m = d - f, h = p - f, y = i - m, g = s - h, v, b;
    y > g ? (v = 1, b = 0) : (v = 0, b = 1);
    let w = y - v + es, S = g - b + es, P = y - 1 + 2 * es, _ = g - 1 + 2 * es, x = d & 255, C = p & 255, T = 0.5 - y * y - g * g;
    if (T >= 0) {
      let A = x + r[C], R = e[A], k = t[A];
      T *= T, l = T * T * (R * y + k * g);
    }
    let N = 0.5 - w * w - S * S;
    if (N >= 0) {
      let A = x + v + r[C + b], R = e[A], k = t[A];
      N *= N, c = N * N * (R * w + k * S);
    }
    let O = 0.5 - P * P - _ * _;
    if (O >= 0) {
      let A = x + 1 + r[C + 1], R = e[A], k = t[A];
      O *= O, u = O * O * (R * P + k * _);
    }
    return 70 * (l + c + u);
  };
}
function Qm(n = Math.random) {
  let r = Jm(n), e = new Float64Array(r).map((i) => Ic[i % 12 * 3]), t = new Float64Array(r).map((i) => Ic[i % 12 * 3 + 1]), o = new Float64Array(r).map((i) => Ic[i % 12 * 3 + 2]);
  return function(s, l, c) {
    let u, a, d, p, f = (s + l + c) * O_, m = ts(s + f), h = ts(l + f), y = ts(c + f), g = (m + h + y) * wr, v = m - g, b = h - g, w = y - g, S = s - v, P = l - b, _ = c - w, x, C, T, N, O, A;
    S >= P ? P >= _ ? (x = 1, C = 0, T = 0, N = 1, O = 1, A = 0) : S >= _ ? (x = 1, C = 0, T = 0, N = 1, O = 0, A = 1) : (x = 0, C = 0, T = 1, N = 1, O = 0, A = 1) : P < _ ? (x = 0, C = 0, T = 1, N = 0, O = 1, A = 1) : S < _ ? (x = 0, C = 1, T = 0, N = 0, O = 1, A = 1) : (x = 0, C = 1, T = 0, N = 1, O = 1, A = 0);
    let R = S - x + wr, k = P - C + wr, $ = _ - T + wr, te = S - N + 2 * wr, Y = P - O + 2 * wr, W = _ - A + 2 * wr, H = S - 1 + 3 * wr, V = P - 1 + 3 * wr, G = _ - 1 + 3 * wr, B = m & 255, L = h & 255, D = y & 255, X = 0.6 - S * S - P * P - _ * _;
    if (X < 0)
      u = 0;
    else {
      let M = B + r[L + r[D]];
      X *= X, u = X * X * (e[M] * S + t[M] * P + o[M] * _);
    }
    let q = 0.6 - R * R - k * k - $ * $;
    if (q < 0)
      a = 0;
    else {
      let M = B + x + r[L + C + r[D + T]];
      q *= q, a = q * q * (e[M] * R + t[M] * k + o[M] * $);
    }
    let j = 0.6 - te * te - Y * Y - W * W;
    if (j < 0)
      d = 0;
    else {
      let M = B + N + r[L + O + r[D + A]];
      j *= j, d = j * j * (e[M] * te + t[M] * Y + o[M] * W);
    }
    let F = 0.6 - H * H - V * V - G * G;
    if (F < 0)
      p = 0;
    else {
      let M = B + 1 + r[L + 1 + r[D + 1]];
      F *= F, p = F * F * (e[M] * H + t[M] * V + o[M] * G);
    }
    return 32 * (u + a + d + p);
  };
}
function Jm(n) {
  let e = new Uint8Array(512);
  for (let t = 0; t < 512 / 2; t++)
    e[t] = t;
  for (let t = 0; t < 512 / 2 - 1; t++) {
    let o = t + ~~(n() * (256 - t)), i = e[t];
    e[t] = e[o], e[o] = i;
  }
  for (let t = 256; t < 512; t++)
    e[t] = e[t - 256];
  return e;
}
var er = new Triangle();
var Ka = class {
  constructor(r) {
    this.weightAttribute = null;
    let e = r.geometry;
    if (!e.isBufferGeometry || e.attributes.position.itemSize !== 3)
      throw new Error("THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.");
    e.index && (e = e.toNonIndexed()), this.geometry = e, this.randomFunction = Math.random, this.positionAttribute = this.geometry.getAttribute("position"), this.distribution = null;
  }
  build() {
    let r = this.positionAttribute, e = new Float32Array(r.count / 3);
    for (let o = 0; o < r.count; o += 3) {
      let i = 1;
      er.a.fromBufferAttribute(r, o), er.b.fromBufferAttribute(r, o + 1), er.c.fromBufferAttribute(r, o + 2), i *= er.getArea(), e[o / 3] = i;
    }
    this.distribution = new Float32Array(r.count / 3);
    let t = 0;
    for (let o = 0; o < e.length; o++)
      t += e[o], this.distribution[o] = t;
    return this;
  }
  setRandomGenerator(r) {
    return this.randomFunction = r, this;
  }
  sample(r, e) {
    if (this.distribution) {
      let t = this.distribution[this.distribution.length - 1], o = this.binarySearch(this.randomFunction() * t);
      return this.sampleFace(o, r, e);
    }
  }
  binarySearch(r) {
    if (!this.distribution)
      return 0;
    let e = this.distribution, t = 0, o = e.length - 1, i = -1;
    for (; t <= o; ) {
      let s = Math.ceil((t + o) / 2);
      if (s === 0 || e[s - 1] <= r && e[s] > r) {
        i = s;
        break;
      } else
        r < e[s] ? o = s - 1 : t = s + 1;
    }
    return i;
  }
  sampleFace(r, e, t) {
    let o = this.randomFunction(), i = this.randomFunction();
    return o + i > 1 && (o = 1 - o, i = 1 - i), er.a.fromBufferAttribute(this.positionAttribute, r * 3), er.b.fromBufferAttribute(this.positionAttribute, r * 3 + 1), er.c.fromBufferAttribute(this.positionAttribute, r * 3 + 2), e.set(0, 0, 0).addScaledVector(er.a, o).addScaledVector(er.b, i).addScaledVector(er.c, 1 - (o + i)), er.getNormal(t), this;
  }
};
var rh = Ws(th());
var C_ = new Matrix4();
var I_ = new Matrix4();
var M_ = new Matrix4();
var rs;
((r) => {
  function n(e) {
    return e && e.__isSPEObject;
  }
  r.is = n;
})(rs || (rs = {}));
var Vn = (n) => class extends n {
  constructor() {
    super(...arguments);
    this.previousModelViewMatrix = new Matrix4();
    this.copyPreviousMatrix = true;
    this.hiddenMatrix = new Matrix4();
    this.matrixWorldRigid = new Matrix4();
    this.shearScale = new Matrix4();
    this.shearScaleInv = new Matrix4();
  }
  get __isSPEObject() {
    return true;
  }
  isDescendantOf(t) {
    t instanceof Object3D && (t = t.uuid);
    let o = this;
    for (; o.parent; ) {
      if (o.parent.uuid === t)
        return true;
      o = o.parent;
    }
    return false;
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix) : (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.hiddenMatrix), this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = false, t = true);
    for (let o of this.children)
      o.updateMatrixWorld(t);
  }
  updateWorldMatrix(t, o) {
    let i = this.parent;
    if (t && i !== null && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix) : (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.hiddenMatrix), this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)), o)
      for (let s of this.children)
        s.updateWorldMatrix(false, true);
  }
  traverseObject(t, o = 0) {
    if (t(this, o) !== true)
      for (let s of this.children)
        rs.is(s) && s.traverseObject(t, o + 1);
  }
  updateMatrixWorldSVD() {
    let t = this.matrixWorld.elements, o = [[t[0], t[4], t[8]], [t[1], t[5], t[9]], [t[2], t[6], t[10]]], { u: i, v: s, q: l } = (0, rh.SVD)(o), c = C_.set(i[0][0], i[0][1], i[0][2], 0, i[1][0], i[1][1], i[1][2], 0, i[2][0], i[2][1], i[2][2], 0, 0, 0, 0, 1), u = I_.set(s[0][0], s[0][1], s[0][2], 0, s[1][0], s[1][1], s[1][2], 0, s[2][0], s[2][1], s[2][2], 0, 0, 0, 0, 1), a = M_.copy(u).transpose();
    this.shearScale.makeScale(l[0], l[1], l[2]).multiply(a).premultiply(u), this.shearScaleInv.copy(this.shearScale).invert(), this.matrixWorldRigid.multiplyMatrices(c, a).copyPosition(this.matrixWorld), l.every((d) => Math.abs(l[0] - d) < 0.01) ? this.hasNonUniformScale = false : this.hasNonUniformScale = true;
  }
  attach(t, o) {
    this.updateWorldMatrix(true, false);
    let i = new Matrix4().copy(this.matrixWorld).invert();
    return t.parent !== null && (t.parent.updateWorldMatrix(true, false), i.multiply(t.parent.matrixWorld)), "hiddenMatrix" in t && t.hiddenMatrix instanceof Matrix4 ? t.hiddenMatrix.premultiply(i) : t.applyMatrix4(i), t.updateWorldMatrix(false, false), this.add(t), o !== void 0 && (this.children.pop(), this.children.splice(o, 0, t)), this;
  }
  copy(t, o = false) {
    return super.copy(t, o), this.hasNonUniformScale = t.hasNonUniformScale, this;
  }
  onAfterRender(t, o, i, s, l, c) {
    this.copyPreviousMatrix && this.previousModelViewMatrix.copy(this.modelViewMatrix);
  }
};
var Mc = class extends Vn(Object3D) {
};
var L_ = (n) => n.type === "Mesh";
var Wr = class extends Mc {
  constructor(e) {
    super();
    this.object = e;
    this.matrixAutoUpdate = false, this.hasNonUniformScale = e.hasNonUniformScale;
  }
  raycast(e, t) {
  }
  expand() {
    let e = 0, t = this.object.entityChildren(e);
    for (; t; ) {
      let o = this.children[e];
      (o == null ? void 0 : o.object) !== t && (o && this.remove(o), o = new Wr(t), this.add(o), this.children.splice(e, 0, this.children.pop()), o.matrixWorldNeedsUpdate = true, o.matrixAutoUpdate = false, o.matrix = t.matrix, o.hiddenMatrix = t.hiddenMatrix), o.expand(), e += 1, t = this.object.entityChildren(e);
    }
    for (; this.children.length > e; )
      this.remove(this.children[e]);
  }
  get visible() {
    var _a2;
    return this.playModeVisible !== void 0 ? this.playModeVisible : this.object.visible || this.object.dataPatched.visible && ((_a2 = this.object.dataPatched.cloner) == null ? void 0 : _a2.hideBase) === true;
  }
  set visible(e) {
  }
  get castShadow() {
    return this.object.castShadow;
  }
  set castShadow(e) {
  }
  get receiveShadow() {
    return this.object.receiveShadow;
  }
  set receiveShadow(e) {
  }
  get isMesh() {
    return L_(this.object);
  }
  get isLight() {
    return this.object.isLight;
  }
  get layers() {
    return this.object.layers;
  }
  set layers(e) {
  }
  get isCamera() {
    return false;
  }
  get geometry() {
    if (this.object.geometry)
      return this.object.geometry;
  }
  get material() {
    if (this.object.material)
      return this.object.material;
  }
};
var Mo = new Vector3();
var Eo = new Vector3();
var zn = new Matrix4();
var nh = [new Vector3(-1, 1, 1), new Vector3(-1, -1, 1), new Vector3(1, -1, 1), new Vector3(1, 1, 1), new Vector3(-1, 1, -1), new Vector3(-1, -1, -1), new Vector3(1, -1, -1), new Vector3(1, 1, -1)];
var G_ = [[0, 3], [1, 2], [5, 6], [4, 7], [0, 1], [3, 2], [7, 6], [4, 5], [0, 4], [1, 5], [2, 6], [3, 7]];
var R_ = [[0, 2], [7, 5], [4, 1], [3, 6], [4, 3], [1, 6]];
var oh = (n, r, e) => {
  n.updateEntityBoxSize(Mo, Eo), zn.copy(r).multiply(n.matrixWorld), Eo.x === 0 && Eo.y === 0 && Eo.z === 0 ? e.push(new Vector3(Mo.x, Mo.y, Mo.z).applyMatrix4(zn)) : nh.forEach((t) => {
    e.push(t.clone().multiply(Eo).add(Mo).applyMatrix4(zn));
  });
};
var os = class extends Box3 {
  constructor() {
    super(...arguments);
    this.matrix = new Matrix4();
    this.vertices = [];
    this.faces = [];
    this.edges = [];
    this.centerEdges = [];
  }
  copy(e) {
    return super.copy(e), this.matrix.copy(e.matrix), this.vertices = e.vertices.map((t) => t.clone()), this.faces = e.faces.map((t) => t.clone()), this.edges = e.edges.map((t) => t.clone()), this.centerEdges = e.centerEdges.map((t) => t.clone()), this;
  }
  setFromObjectSize(e, t = false) {
    e.updateWorldMatrix(false, t), this.makeEmpty(), this.matrix.copy(e.matrixWorld);
    let o = new Matrix4().copy(e.matrixWorld).invert();
    return this.expandByObjectSize(e, o, t);
  }
  expandByObjectSize(e, t, o = false) {
    let i = [];
    return o === true ? e.traverseEntity((s) => {
      if (s.visible || s.cloner && s.data.visible) {
        if (!("geometry" in s)) {
          i.push(new Vector3());
          return;
        }
        oh(s, t, i);
      }
    }) : oh(e, t, i), this.setFromPoints(i);
  }
  getCenter(e) {
    return e = super.getCenter(e), e.applyMatrix4(this.matrix), e;
  }
  getPositionToCenter(e) {
    return e = super.getCenter(e), e.applyMatrix4(zn.copy(this.matrix).setPosition(0, 0, 0)), e;
  }
  computeVertices() {
    this.getSize(Eo).multiplyScalar(0.5), this.getCenter(Mo), zn.copy(this.matrix).setPosition(Mo), this.vertices = nh.map((e) => e.clone().multiply(Eo).applyMatrix4(zn));
  }
  computeEdges() {
    this.vertices.length > 0 && this.computeVertices(), this.edges = G_.map(([e, t]) => new Line3(this.vertices[e], this.vertices[t])), this.centerEdges = this.edges.map((e) => e.getCenter(new Vector3()));
  }
  computeFaces() {
    this.vertices.length > 0 && this.computeVertices(), this.faces = R_.map(([e, t]) => this.vertices[e].clone().add(this.vertices[t]).multiplyScalar(0.5));
  }
};
var tr = { Cloner: () => {
}, changeEntityProptotype: () => {
}, createEntity: () => {
} };
var Dc = class extends CurvePath {
  constructor() {
    super();
  }
  getPoints(r = 12) {
    let e = [], t, o = this.getCurveLengths(), s = o[o.length - 1] / o.length;
    for (let l = 0, c = this.curves; l < c.length; l++) {
      let u = c[l], a = l === 0 ? o[l] : o[l] - o[l - 1], d = Math.ceil(r * a / s), p = u.getPoints(d);
      for (let f = 0; f < p.length; f++) {
        let m = p[f];
        t && t.equals(m) || (e.push(m), t = m);
      }
    }
    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
  }
};
var Gc = 1e-3;
function Rc(n, r, e) {
  return r.clone().sub(n).cross(r.clone().sub(e)).length() <= Gc;
}
function Bc(n, r) {
  let e = new Vector3(...n.position), t = new Vector3(...n.controlNext.position), o = new Vector3(...r.controlPrevious.position), i = new Vector3(...r.position);
  return Rc(e, t, i) && Rc(e, o, i);
}
function Qa(n) {
  let r = n.points.map((a) => new Vector3(...a.data.position)), e = [n.points[0]], t = new Vector3(...e[0].data.position);
  for (let a = 0; a < n.points.length - 1; a++)
    Rc(t, r[a], r[a + 1]) || (e.push(n.points[a]), t = r[a]);
  e.push(n.points[n.points.length - 1]);
  let o = n.isClosed, i = e.length - (o ? 0 : 1), s = e.length, l = [];
  for (let a = 0; a < s; a++) {
    let d = e[a].data, p = new Vector3(...d.position), f = new Vector3(...d.controlPrevious.position), m = new Vector3(...d.controlNext.position), h = { position: p, baseRoundness: d.roundness, controlPrevious: f, controlNext: m };
    if (d.roundness === 0 || !n.isClosed && (a === 0 || a === s - 1)) {
      l[a] = { ...h, removedLength: 0 };
      continue;
    }
    let y = o && a == 0 ? s - 1 : a - 1, g = o && a == s - 1 ? 0 : a + 1, v = e[y].data, b = e[g].data, w = new Vector3(...v.position), S = new Vector3(...b.position), P = w.clone().sub(p).normalize(), _ = S.clone().sub(p).normalize();
    Object.assign(h, { prevDir: P, nextDir: _ });
    let x = Bc(v, d), C = Bc(d, b);
    if (!x || !C)
      l[a] = { ...h, removedLength: 0 };
    else {
      let T = P.clone().add(_).normalize(), N = T.clone().cross(P).length() / P.dot(T);
      l[a] = { ...h, tan: N, removedLength: d.roundness / N };
    }
  }
  for (let a = 0; a < i; a++) {
    let d = a, p = o && a === s - 1 ? 0 : a + 1, f = l[d], m = l[p];
    if (f.removedLength !== 0 || m.removedLength !== 0) {
      let h = f.position.distanceTo(m.position);
      f.removedLength = Math.min(f.removedLength, h / 2), m.removedLength = Math.min(m.removedLength, h / 2);
    }
  }
  let c = [];
  for (let a = 0; a < i; a++) {
    let d = a, p = o && a === s - 1 ? 0 : a + 1, f = l[d], m = l[p], h = null;
    if (!Bc(e[d].data, e[p].data))
      f.position.distanceTo(m.position) > Gc && (h = new CubicBezierCurve3(f.position, f.controlNext, m.controlPrevious, m.position));
    else {
      let y = f.position.clone(), g = m.position.clone();
      (f.removedLength !== 0 || m.removedLength !== 0) && (f.nextDir && y.add(f.nextDir.clone().setLength(f.removedLength)), m.prevDir && g.add(m.prevDir.clone().setLength(m.removedLength))), y.distanceTo(g) > Gc && (h = new CubicBezierCurve3(y, y.clone().lerp(g, 0.3), g.clone().lerp(y, 0.3), g));
    }
    c[2 * a + 1] = h;
  }
  for (let a = 0; a < s; a++) {
    let d = l[a];
    if (d.removedLength === 0) {
      c[2 * a] = null;
      continue;
    }
    let p = d.position, f = d.prevDir.clone().multiplyScalar(d.removedLength).add(p), m = d.nextDir.clone().multiplyScalar(d.removedLength).add(p), h = d.tan * d.removedLength, y = d.prevDir.clone().add(d.nextDir).normalize(), g = f.clone().lerp(m, 0.5), v = f.distanceTo(m) / 2, b = y.clone().multiplyScalar(Math.sqrt(Math.pow(h, 2) - Math.pow(v, 2))).add(g), w = y.clone().multiplyScalar(-h).add(b), S = p.distanceTo(w) / p.distanceTo(g), P = d.prevDir.clone().multiplyScalar(S * p.distanceTo(f)).add(p), _ = P.clone().lerp(w, 2), x = f.clone().lerp(P, 4 / 3), C = m.clone().lerp(_, 4 / 3);
    c[2 * a] = new CubicBezierCurve3(f, x, C, m);
  }
  let u = new Dc();
  return c.forEach((a) => {
    a && u.add(a);
  }), u;
}
var Ie;
((r) => {
  function n(e) {
    return e && e.__isEntity;
  }
  r.is = n;
})(Ie || (Ie = {}));
var ns = (n) => Ie.is(n);
var F_ = { type: "completeState", isfromEntity: true };
var el = (n) => class extends Vn(n) {
  constructor() {
    super(...arguments);
    this.raycastLock = false;
    this.scaleLock = false;
    this.disposed = false;
    this.stateSelection = null;
    this.instances = [];
    this.prevState = null;
    this.currentState = null;
    this.reversibleToState = null;
    this.currentTransitionEvent = null;
    this.previousAction = null;
    this._singleBBox = new os();
    this._recursiveBBox = new os();
    this.singleBBoxNeedsUpdate = true;
    this.recursiveBBoxNeedsUpdate = true;
    this._needApplyPathSnapping = true;
    this.attachedPaths = /* @__PURE__ */ new Set();
  }
  get __isEntity() {
    return true;
  }
  entityChildren(t) {
    let o = this.children[t];
    if (Ie.is(o))
      return o;
  }
  get isConcreteEntity() {
    return typeof this.identity == "string";
  }
  get isVirtualEntity() {
    return typeof this.identity != "string";
  }
  get isInstanceRoot() {
    return this.isConcreteEntity && this.data.type === "Instance";
  }
  nearestInstanceSelfOrParent() {
    let t = this;
    for (; t.data.type !== "Instance"; ) {
      let o = t.parent;
      if (Ie.is(o))
        t = o;
      else
        return;
    }
    return t;
  }
  forInstancesRec(t) {
    this.instances.forEach((o) => {
      o.disposed || t(o), o.forInstancesRec(t);
    });
  }
  super_Entity(t, o) {
    typeof t == "string" && (this.uuid = t), this.identity = t, this.data = o, this.matrixAutoUpdate = false, this.dataPatched = this.data;
  }
  changeSelectedState(t, o, i = false) {
    if (!(this.data.states.length === 0 && !i)) {
      for (let s of this.data.states)
        Io.toOps(this.data, s.data).forEach((c) => {
          let u = Sa.replaceProps(c, this.data);
          this.dataPatched = this.data, this.updateByPatchedOp(u, this.data, o);
        });
      if (t !== null) {
        let s = this.data.states.data(t);
        s && (this.dataPatched = Io.patch(this.data, s), Io.toOps(this.data, s).forEach((c) => {
          this.updateByPatchedOp(c, this.dataPatched, o);
        }));
      }
      i && this.updateTransformState(this.dataPatched), this.stateSelection = t, this.updatePathSnapping(this.dataPatched.pathSnapping);
    }
  }
  get singleBBox() {
    return this.singleBBoxNeedsUpdate && (this.singleBBoxNeedsUpdate = false, this._singleBBox.setFromObjectSize(this, false), this._singleBBox.computeVertices(), this._singleBBox.computeEdges(), this._singleBBox.computeFaces()), this._singleBBox;
  }
  get recursiveBBox() {
    return this.recursiveBBoxNeedsUpdate && (this.recursiveBBoxNeedsUpdate = false, this._recursiveBBox.setFromObjectSize(this, true), this._recursiveBBox.computeVertices(), this._recursiveBBox.computeEdges(), this._recursiveBBox.computeFaces()), this._recursiveBBox;
  }
  updateEntityBoxSize(t, o) {
    t.setScalar(0), o.setScalar(0);
  }
  resetBBoxNeedsUpdateSelf() {
    this.singleBBoxNeedsUpdate = true, this.recursiveBBoxNeedsUpdate = true;
  }
  resetBBoxNeedsUpdate() {
    this.resetBBoxNeedsUpdateSelf(), this.traverseAncestors((t) => {
      ns(t) && t.resetBBoxNeedsUpdateSelf();
    }), this.traverseEntity((t) => {
      t.resetBBoxNeedsUpdateSelf();
    });
  }
  find(t) {
    let o;
    return this.traverseEntity((i) => {
      i.uuid === t && (o = i);
    }), o;
  }
  traverseSortNextHelper() {
    let t = this.parent;
    if (t) {
      let o = t.children, i = o.indexOf(this) + 1;
      if (Ie.is(o[i]))
        return o[i];
      if (Ie.is(t))
        return t.traverseSortNextHelper();
    }
  }
  sortNext() {
    let t = this.children;
    return this.children.length > 0 && Ie.is(this.children[0]) ? t[0] : this.traverseSortNextHelper();
  }
  goUp(t) {
    let o = this;
    for (; t > 0 && o !== null; )
      o = o.parent, t -= 1;
    return o;
  }
  hasAnccestorOrSelf(t) {
    return this === t || this.hasAnccestor(t);
  }
  hasAnccestor(t) {
    let o = this.parent;
    for (; o; ) {
      if (t === o)
        return true;
      o = o.parent;
    }
    return false;
  }
  countToAccestor(t) {
    let o = 0, i = this;
    for (; i !== t; ) {
      if (i === null)
        return -1;
      i = i.parent, o += 1;
    }
    return o;
  }
  forEachEntity(t) {
    for (let o of this.children)
      ns(o) && t(o);
  }
  traverseEntityAncestors(t) {
    this.traverseAncestors((o) => {
      Ie.is(o) && t(o);
    });
  }
  traverseEntity(t, o = 0) {
    if (t(this, o) !== true)
      for (let s of this.children)
        ns(s) && s.traverseEntity(t, o + 1);
  }
  traverseVisibleEntity(t) {
    t(this);
    for (let o of this.children)
      ns(o) && o.visible && o.traverseVisibleEntity(t);
  }
  updateMatrix() {
    super.updateMatrix(), this.cloner && this.cloner.onObjUpdateMatrix(), this.dispatchEvent({ type: "updateMatrix" });
  }
  copy(t, o = false) {
    return super.copy(t, o), this.dataPatched = t.dataPatched, this.raycastLock = t.raycastLock, this.scaleLock = t.scaleLock, this.hiddenMatrix.copy(t.hiddenMatrix), this;
  }
  hasEntityChild() {
    return this.children.some((t) => ns(t));
  }
  isAncestorOf(t) {
    if (this.uuid === t)
      return false;
    let o = false;
    return this.traverseEntity((i) => {
      i.uuid === t && (o = true);
    }), o;
  }
  toObjectTransformState(t = []) {
    this.updateWorldMatrix(true, false);
    let o = { position: this.position.toArray(), rotation: [this.rotation.x, this.rotation.y, this.rotation.z], scale: this.scale.toArray(), hiddenMatrix: this.hiddenMatrix.toArray() };
    return xn(o, t);
  }
  updateTransformState(t) {
    let o = false;
    return t.position && (this.position.fromArray(t.position), o = true), t.rotation && (this.rotation.fromArray(t.rotation), o = true), t.scale && (o = true, this.scale.fromArray(t.scale)), t.hiddenMatrix !== void 0 && (o = true, this.hiddenMatrix.fromArray(t.hiddenMatrix ?? lo.identity)), o && (this.updateMatrix(), this.resetBBoxNeedsUpdate(), this.invalidateClonerTransform(this), this.traverseEntityAncestors((i) => {
      i.invalidateClonerTransform(this);
    })), t.position && t.rotation && t.scale && t.hiddenMatrix !== void 0 && this.updateWorldMatrix(false, true), o;
  }
  dispose() {
    this.disposed = true, this.cloner && (this.cloner.removeFromParent(), this.cloner = void 0);
  }
  disposeChildrenRecursively() {
    for (let t of this.children)
      Ie.is(t) && t.disposeRecursively();
  }
  disposeRecursively() {
    this.dispose(), this.children.forEach((t) => {
      Ie.is(t) && t.disposeRecursively();
    });
  }
  toState(t = []) {
    let o = { name: this.name, visible: this.visible, raycastLock: this.raycastLock, ...this.toObjectTransformState(t) };
    return xn(o, t);
  }
  updateByOp(t, o, i, s) {
    let l = this.data;
    this.data = o;
    let c = t, u = Zt(t.path, ["states", "*"]);
    if (u !== null) {
      if (t.type === 0) {
        let [a] = u;
        if ((this == null ? void 0 : this.stateSelection) === a) {
          let d = { ...t.props };
          if (Object.values(t.props).some((p) => p === void 0)) {
            let p = this.data;
            if (p !== void 0) {
              let f = yt.zoom(p, t.path.slice(2));
              if (f)
                for (let m in t.props)
                  t.props[m] === void 0 && m in f && (d[m] = f[m]);
            }
          }
          c = { ...t, props: d, path: t.path.slice(2) };
        }
      }
    } else if (t.type === 0) {
      let a = this.stateSelection ? this.data.states.data(this.stateSelection) : void 0;
      if (a !== void 0) {
        if (t.props.name !== void 0 && a.name) {
          let { name: p, ...f } = a;
          a = f;
        }
        if (t.props.material !== void 0 && "material" in a) {
          let { material: p, ...f } = a;
          a = f;
        }
        let d = yt.removeOverridden(t.path, t.props, a);
        c = { ...t, props: d };
      }
    }
    if (this.updateByPatchedOpBase(c, Io.patch(this.data, this.stateSelection ? this.data.states.data(this.stateSelection) : void 0), i), Zt(t.path, ["overrides"])) {
      let a = [], d = [...t.path];
      for (a.push(d[1]), d.splice(0, 2); d.length > 0 && d[0] === "descendants"; )
        a.push(d[1]), d.splice(0, 2);
      if (a[a.length - 1] === void 0) {
        if (t.type === 0)
          for (let p of Object.keys(t.props)) {
            a[a.length - 1] = p;
            let f = i.scene.findInstance([this.uuid, ...a]);
            f && (f.overrideData = t.props[p], f.updateState(Hr.apply(f.component.data, f.overrideData), i));
          }
      } else {
        let p = i.scene.findInstance([this.uuid, ...a]);
        if (p) {
          let f = yt.zoom(p.component.data, d);
          if (t = { ...t, path: d }, t.type === 0) {
            let m = t.props;
            if (f)
              for (let [h, y] of Object.entries(t.props))
                y === void 0 && (m === t.props && (m = { ...t.props }), m[h] = f[h]);
            t = { ...t, props: m };
          }
          p.overrideData = Ln.resolve(o.overrides, a), p.updateByOp(t, lt.applySimple(p.data, t), i, false);
        }
      }
    } else if (this.instances.length > 0) {
      let a;
      if (t.path.length === 0 && t.type === 0) {
        let d;
        for (let p of uo.rootOverrideProps)
          p in t.props && (d === void 0 && (d = {}), d[p] = t.props[p]);
        d && (a = { ...t, props: d });
      } else
        for (let d of uo.rootOverrideProps)
          if (Zt(t.path, [d])) {
            a = t;
            break;
          }
      a !== void 0 && this.instances.forEach((d) => {
        if (d.isInstanceRoot) {
          let p = Hr.filterOp(d.overrideData, a);
          p && d.updateByOp(p, lt.applySimple(d.data, p), i, true);
        }
      }), this.instances.forEach((d) => {
        if (!d.isInstanceRoot) {
          let p = Hr.filterOp(d.overrideData, t);
          if (p) {
            let f;
            l === d.data && t === p ? f = o : f = lt.applySimple(d.data, p), d.updateByOp(p, f, i, true);
          }
        }
      });
    }
  }
  updateByPatchedOpBase(t, o, i) {
    if (this.dataPatched = o, t.path.length === 0 && t.type === 0)
      t.props.type !== void 0 && !Qt.is(t.props.type) && tr.changeEntityProptotype(this, o, i);
    else if (t.path.length === 1 && t.path[0] === "geometry" && t.type === 0 && "type" in t.props) {
      tr.changeEntityProptotype(this, o, i);
      for (let s of this.children)
        Ie.is(s) && s.updateVisible();
    }
    this.updateByPatchedOp(t, o, i);
  }
  updateByPatchedOp(t, o, i) {
    if (t.path.length === 0 && t.type === 0 && this.updateState(t.props, i), Zt(t.path, ["pathSnapping"]) !== null && this.updatePathSnapping(o.pathSnapping), Zt(t.path, ["cloner"]) !== null) {
      let s = lt.drop(t, 1);
      s.path.length === 0 && s.type === 0 && s.props.disabled === true ? this.setFromClonerState(null, i) : this.cloner ? this.cloner.updateState(o.cloner, i.scene) : (this.setFromClonerState(o.cloner, i), this.expandCloner(i.scene)), this.updateVisible();
    }
  }
  updatePathSnapping(t) {
    this._updatedPathSnapping = t, this._needApplyPathSnapping = true;
  }
  get updatedPathSnapping() {
    return this._updatedPathSnapping;
  }
  applyPathSnapping(t) {
    var _a2, _b2, _c2, _d, _e2;
    let o = ((_a2 = this._updatedPathSnapping) == null ? void 0 : _a2.pathId) ?? this.dataPatched.pathSnapping.pathId, i = ((_b2 = this._updatedPathSnapping) == null ? void 0 : _b2.slide) ?? this.dataPatched.pathSnapping.slide ?? 0, s = ((_c2 = this._updatedPathSnapping) == null ? void 0 : _c2.offset) ?? this.dataPatched.pathSnapping.offset, l = ((_d = this._updatedPathSnapping) == null ? void 0 : _d.orientation) ?? this.dataPatched.pathSnapping.orientation;
    if (o === null)
      return;
    let c = t.find(o);
    if (!c || this._needApplyPathSnapping === false)
      return;
    this._needApplyPathSnapping = false;
    let u = c.data, a = Qa(u.geometry.path), d = (i + s) % 1;
    i + s === 1 && d === 0 && (d = 1);
    let p = a.getPointAt(d), f = this.parent ? (_e2 = this.parent) == null ? void 0 : _e2.matrixWorld : new Matrix4();
    c.updateMatrixWorld();
    let m = new Matrix4().multiplyMatrices(f.clone().invert(), c.matrixWorld);
    p.applyMatrix4(m);
    let h = { position: p.toArray(), rotation: u.rotation };
    if (l === "tangential") {
      let y = new Matrix4().extractRotation(c.matrixWorld), g = a.getTangentAt(d).applyMatrix4(y).add(p), v = new Matrix4().lookAt(p, g, new Vector3(0, 1, 0)), b = new Euler().setFromRotationMatrix(v);
      h = { ...h, rotation: [b.x, b.y, b.z] };
    }
    this.updateTransformState(h), this.traverseEntity((y) => {
      y._cameraType && y.dispatchEvent(F_);
    });
  }
  updateVisible() {
    var _a2;
    this.visible = this.dataPatched.visible && (!this.dataPatched.cloner || (this.dataPatched.cloner.disabled ?? false) || ((_a2 = this.dataPatched.cloner) == null ? void 0 : _a2.hideBase) !== true);
  }
  updateState_Entity(t, o) {
    t.name !== void 0 && (this.name = t.name), t.raycastLock !== void 0 && (this.raycastLock = t.raycastLock), t.visible !== void 0 && (this.updateVisible(), this.resetBBoxNeedsUpdate()), "cloner" in t && t.cloner !== void 0 && (this.setFromClonerState(t.cloner, o), this.updateVisible()), this.updateTransformState(t);
  }
  get attachedSurfaceCloners() {
    return this.children.filter((t) => t instanceof tr.Cloner && t.parameters.type === "toObject");
  }
  setFromClonerState(t, o) {
    this.disposed || (t === null || t.disabled ? (this.cloner && this.cloner.removeFromParent(), this.cloner = void 0) : this.cloner === void 0 ? (this.cloner = new tr.Cloner(this, t), o.scene.addPendingExpandCloner(this)) : this.cloner.updateState(t, o.scene));
  }
  expandCloner(t) {
    !this.disposed && this.cloner && this.cloner.expandClones(t);
  }
  invalidateClonerTransform(t) {
    this.cloner && this.cloner.invalidateTransform(t);
  }
};
var sh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, radialSegments: 64, heightSegments: 1, openEnded: false, thetaStart: 0, thetaLength: 360, cornerRadius: 8, cornerSegments: 8, hollow: 0 }, n.parameters), t = e.width / 2, o = e.radiusTop ?? t, i = e.radiusBottom ?? t;
    return o === i ? (o = t, i = t) : o > i ? (o = t, i = i * t / o) : (o = o * t / i, i = t), { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width), radiusTop: o, radiusBottom: i }) };
  }
  static build(n) {
    let { width: r, depth: e, height: t, radialSegments: o, heightSegments: i, openEnded: s, thetaStart: l, thetaLength: c, radiusTop: u, radiusBottom: a, cornerRadius: d, cornerSegments: p, hollow: f } = n.parameters, m;
    return d || f ? m = new is(u, a, t, o, i, s, l, c * Math.PI / 180, d, d, p, f) : m = new CylinderGeometry(u, a, t, o, i, s, l, c * Math.PI / 180), m.scale(1, 1, e / r), Object.assign(m, { userData: { ...n, type: "CylinderGeometry" } });
  }
};
function po(n, r, e) {
  e.x = n.x * r.x, e.y = n.y, e.z = n.x * r.y;
}
function ih(n) {
  return new Vector2(n.y, -n.x);
}
var is = class extends BufferGeometry {
  constructor(r, e, t, o, i, s, l, c, u, a, d, p, f = false) {
    super(), this.type = "RoundedCylinderBufferGeometry", r = r !== void 0 ? r : 1, e = e !== void 0 ? e : 1, t = t || 1, o = Math.floor(o) || 8, i = Math.floor(i) || 1, s = s !== void 0 ? s : false, l = l !== void 0 ? l : 0, c = c !== void 0 ? c : Math.PI * 2, s && (u = 0, a = 0);
    let m = [], h = [], y = [], g = [], v = 0, b = t / 2, w = new Vector3(), S = new Vector3();
    f && r == 0 && (r = u), f && e == 0 && (e = a);
    let P = new Vector2(r, b), _ = new Vector2(e, -b), x = null, C = null, T = null, N = null, O = P.clone().sub(_), A = 0, R = 0, k = 0;
    p > 0 && (A = Math.min(r, e) * (1 - p), R = r - A, k = e - A);
    let $ = P.clone();
    $.x -= A;
    let te = Math.PI - O.angle(), Y = O.angle(), W = Math.tan(Y / 2), H = Math.tan(te / 2), V = W + H, G = p ? V : H, B = p ? V : W;
    if (u = Math.min(u, (r - R) / G, O.length() / V), a = Math.min(a, (e - k) / B, O.length() / V), u > 0) {
      let F = u / W;
      x = P.clone().sub(new Vector2(F, u)), p && (T = x.clone(), T.x -= A - V * u), P.sub(O.clone().setLength(F));
    }
    if (a > 0) {
      let F = a / H;
      C = _.clone().sub(new Vector2(F, -a)), _.add(O.clone().setLength(F)), p && (N = C.clone(), N.x -= A - V * a, $.sub(O.clone().setLength(F)));
    }
    O = P.clone().sub(_);
    let L = O.length() < 0.5, D = [];
    for (let F = 0; F <= o; F++) {
      let M = [], Q = F / o, re = Q * c + l, oe = new Vector2(Math.sin(re), Math.cos(re));
      N && C ? (X(M, Q, oe, te, a, N, -1, true), X(M, Q, oe, Y, a, C, -1, false)) : C ? (q(M, oe, C.x, 0, -1), X(M, Q, oe, Y, a, C, -1, false)) : s || q(M, oe, e, k, -1);
      let K = ih(O).normalize();
      if (po(K, oe, w), !L)
        for (let ee = 0; ee <= i; ee++) {
          let J = ee / i, ie = O.clone().multiplyScalar(J).add(_);
          po(ie, oe, S), h.push(S.x, S.y, S.z), y.push(w.x, w.y, w.z), g.push(Q, 0.5 + S.y / t), M.push(v++);
        }
      if (T && x ? (X(M, Q, oe, te, u, x, 1, false), X(M, Q, oe, Y, u, T, 1, true)) : x ? (X(M, Q, oe, te, u, x, 1, false), q(M, oe, x.x, 0, 1)) : s || q(M, oe, r, R, 1), p && !L) {
        let ee = ih(O).multiplyScalar(-1).normalize();
        po(ee, oe, w);
        for (let J = 0; J <= i; J++) {
          let ie = J / i, ce = O.clone().multiplyScalar(-ie).add($);
          po(ce, oe, S), h.push(S.x, S.y, S.z), y.push(w.x, w.y, w.z), g.push(Q, 0.5 + S.y / t), M.push(v++);
        }
      }
      p && !s && M.push(M[0]), D.push(M);
    }
    for (let F = 0; F < D.length - 1; F++)
      for (let M = 0; M < D[0].length - 1; M++) {
        if (s && p && M == i)
          continue;
        let Q = D[F][M], re = D[F + 1][M], oe = D[F + 1][M + 1], K = D[F][M + 1], ee = h[oe * 3 + 0], J = h[oe * 3 + 2];
        m.push(Q, re, K), (ee != 0 || J != 0) && m.push(re, oe, K);
      }
    c < Math.PI * 2 && (j(-1, D[0], l), j(1, D[D.length - 1], l + c)), this.setIndex(m), this.setAttribute("position", new Float32BufferAttribute(h, 3)), this.setAttribute("normal", new Float32BufferAttribute(y, 3)), this.setAttribute("uv", new Float32BufferAttribute(g, 2));
    function X(F, M, Q, re, oe, K, ee, J) {
      for (let ie = 0; ie < d + 1; ie++) {
        let ce = ie / d, se = ee < 0 ? ce : 1 - ce;
        J && (se -= 1), se *= re;
        let fe = new Vector2(Math.sin(se), Math.cos(se) * ee), Re = fe.clone().multiplyScalar(oe).add(K);
        po(Re, Q, S), h.push(S.x, S.y, S.z), po(fe, Q, w), y.push(w.x, w.y, w.z), g.push(M, 0.5 + S.y / t), F.push(v++);
      }
    }
    function q(F, M, Q, re, oe) {
      let K = new Vector3(), ee = new Vector2(), J = [Q, re];
      oe < 0 && J.reverse();
      for (let ie of J)
        ee.set(ie, b * oe), po(ee, M, K), h.push(K.x, K.y, K.z), y.push(0, oe, 0), g.push(0.5, 0.5), F.push(v++);
    }
    function j(F, M, Q) {
      let re = new Vector2(Math.sin(Q), Math.cos(Q)), oe = new Vector2(-Math.cos(Q), Math.sin(Q)), K = new Vector3(), ee = F < 0 ? (ce, se, fe) => m.push(ce, se, fe) : (ce, se, fe) => m.push(ce, fe, se), J = new Vector2((r + e + R + k) / 4, 0);
      po(J, re, K), h.push(K.x, K.y, K.z), y.push(oe.x, 0, oe.y), g.push(0.5, 0.5);
      let ie = v++;
      for (let ce of M) {
        let se = h.slice(ce * 3, ce * 3 + 3);
        h.push(...se), y.push(oe.x, 0, oe.y);
        let fe = g.slice(ce * 2, ce * 2 + 2);
        g.push(...fe), v++;
      }
      for (let ce = ie + 1; ce < v - 1; ce++)
        ee(ie, ce, ce + 1);
      ee(ie, v - 1, ie + 1);
    }
  }
};
var ah = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, radialSegments: 32, heightSegments: 8, openEnded: false, thetaStart: 0, thetaLength: 360, cornerRadiusTop: 8, cornerRadiusBottom: 8, cornerSegments: 8 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { width: r, depth: e, height: t, radialSegments: o, heightSegments: i, openEnded: s, thetaStart: l, thetaLength: c, cornerRadiusTop: u, cornerRadiusBottom: a, cornerSegments: d } = n.parameters, p;
    return u > 0 || a > 0 || c < 360 ? p = new is(0, r / 2, t, o, i, s, l, c * Math.PI / 180, u, a, d, 0, true) : p = new ConeGeometry(r / 2, t, o, i, s), p.scale(1, 1, e / r), Object.assign(p, { userData: { ...n, type: "ConeGeometry" } });
  }
};
var lh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, widthSegments: 1, heightSegments: 1, depthSegments: 1, cornerRadius: 8, cornerSegments: 8 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { width: r, height: e, depth: t, widthSegments: o, heightSegments: i, depthSegments: s, cornerRadius: l, cornerSegments: c } = n.parameters, u;
    return l == 0 ? u = new BoxGeometry(r, e, t, o, i, s) : u = new Fc(r, e, t, o, i, s, l, c), Object.assign(u, { userData: { ...n, type: "CubeGeometry" } });
  }
};
var jc = Math.PI / 2;
var Fc = class extends BufferGeometry {
  constructor(r = 1, e = 1, t = 1, o = 1, i = 1, s = 1, l = 0, c = 4) {
    super(), this.type = "BoxGeometry";
    let u = this;
    o = Math.floor(o), i = Math.floor(i), s = Math.floor(s), c = Math.floor(c), l = Math.min(l, r / 2, e / 2, t / 2);
    let a = [], d = [], p = [], f = [], m = 0, h = 0;
    y("z", "y", "x", -1, -1, t, e, r, s, i, 0), y("z", "y", "x", 1, -1, t, e, -r, s, i, 1), y("x", "z", "y", 1, 1, r, t, e, o, s, 2), y("x", "z", "y", 1, -1, r, t, -e, o, s, 3), y("x", "y", "z", 1, -1, r, e, t, o, i, 4), y("x", "y", "z", -1, -1, r, e, -t, o, i, 5), l > 0 && (g("z", "y", "x", -1, -1, 1, t, e, r, s, 0), g("z", "y", "x", 1, -1, -1, t, e, r, s, 1), g("z", "y", "x", -1, 1, -1, t, e, r, s, 1), g("z", "y", "x", 1, 1, 1, t, e, r, s, 0), g("x", "y", "z", -1, -1, -1, r, e, t, o, 0), g("x", "y", "z", 1, -1, 1, r, e, t, o, 1), g("x", "y", "z", -1, 1, 1, r, e, t, o, 0), g("x", "y", "z", 1, 1, -1, r, e, t, o, 1), g("y", "x", "z", -1, -1, 1, e, r, t, i, 0), g("y", "x", "z", 1, -1, -1, e, r, t, i, 1), g("y", "x", "z", 1, 1, 1, e, r, t, i, 1), g("y", "x", "z", -1, 1, -1, e, r, t, i, 0), v(1, 1, 1), v(-1, 1, 1), v(1, -1, 1), v(-1, -1, 1), v(1, 1, -1), v(-1, 1, -1), v(1, -1, -1), v(-1, -1, -1)), this.setIndex(a), this.setAttribute("position", new Float32BufferAttribute(d, 3)), this.setAttribute("normal", new Float32BufferAttribute(p, 3)), this.setAttribute("uv", new Float32BufferAttribute(f, 2));
    function y(b, w, S, P, _, x, C, T, N, O, A) {
      let R = (x - 2 * l) / N, k = (C - 2 * l) / O, $ = x / 2 - l, te = C / 2 - l, Y = T / 2, W = N + 1, H = O + 1, V = 0, G = 0, B = new Vector3();
      for (let L = 0; L < H; L++) {
        let D = L * k - te;
        for (let X = 0; X < W; X++) {
          let q = X * R - $;
          B[b] = q * P, B[w] = D * _, B[S] = Y, d.push(B.x, B.y, B.z), B[b] = 0, B[w] = 0, B[S] = T > 0 ? 1 : -1, p.push(B.x, B.y, B.z), f.push(X / N), f.push(1 - L / O), V += 1;
        }
      }
      for (let L = 0; L < O; L++)
        for (let D = 0; D < N; D++) {
          let X = m + D + W * L, q = m + D + W * (L + 1), j = m + (D + 1) + W * (L + 1), F = m + (D + 1) + W * L;
          a.push(X, q, F), a.push(q, j, F), G += 6;
        }
      u.addGroup(h, G, A), h += G, m += V;
    }
    function g(b, w, S, P, _, x, C, T, N, O, A) {
      let R = (C - 2 * l) / O, k = C / 2 - l, $ = T / 2 - l, te = N / 2, Y = O + 1, W = 0, H = 0, V = new Vector3(), G = new Vector3();
      for (let B = 0; B < c + 1; B++) {
        let L = B / c * jc, D = Math.sin(L) * l, X = (1 - Math.cos(L)) * l, q = Math.sin(L), j = Math.cos(L);
        V[w] = ($ + D) * _, V[S] = (te - X) * x, G[b] = 0, G[w] = q * Math.sign(V[w]), G[S] = j * Math.sign(V[S]);
        for (let F = 0; F < Y; F++) {
          let M = F * R - k;
          V[b] = M * P, d.push(V.x, V.y, V.z), p.push(G.x, G.y, G.z), f.push(F / O), f.push(0), W += 1;
        }
      }
      for (let B = 0; B < c; B++)
        for (let L = 0; L < O; L++) {
          let D = m + L + Y * B, X = m + L + Y * (B + 1), q = m + (L + 1) + Y * (B + 1), j = m + (L + 1) + Y * B;
          a.push(D, X, j), a.push(X, q, j), H += 6;
        }
      u.addGroup(h, H, A), h += H, m += W;
    }
    function v(b, w, S) {
      let P = new Vector3(), _ = new Vector3(r / 2, e / 2, t / 2);
      _.subScalar(l);
      let x = [], C = b * w * S > 0 ? (N, O, A) => a.push(N, O, A) : (N, O, A) => a.push(N, A, O);
      for (let N = 0; N <= c; N++) {
        let O = [], A = jc * (1 - N / c), R = Math.cos(A), k = Math.sin(A), $ = 0;
        for (let te = 0; te <= N; te++) {
          let Y = Math.cos($), W = Math.sin($);
          P.x = R * Y, P.y = k, P.z = R * W;
          let H = _.clone().addScaledVector(P, l);
          d.push(b * H.x, w * H.y, S * H.z), p.push(b * P.x, w * P.y, S * P.z), f.push(0, 0), O.push(m++), $ += jc / N;
        }
        x.push(O);
      }
      let T = x.length - 1;
      for (let N = 0; N < T; N++) {
        let O = x[N], A = x[N + 1], R = O.length - 1;
        C(O[0], A[1], A[0]);
        for (let k = 1; k <= R; k++)
          C(O[k - 1], O[k], A[k]), C(O[k], A[k + 1], A[k]);
      }
    }
  }
};
var fo = class extends BufferGeometry {
  constructor(r = [], e = [], t = "", o = 1, i = 0.2, s = 4) {
    super(), this.type = "PolyhedronGeometryRound";
    let l = [], c = [], u = [];
    a(), d(), this.setAttribute("position", new Float32BufferAttribute(l, 3)), this.setAttribute("normal", new Float32BufferAttribute(u, 3)), this.setAttribute("uv", new Float32BufferAttribute(c, 2));
    return;
    function a() {
      var _a2;
      i = Math.min(1 - 1e-5, i), i == 0 && (s = 0);
      let f = { IcosahedronGeometry: 5, DodecahedronGeometry: 3, HexahedronGeometry: 3, OctahedronGeometry: 4, TetrahedronGeometry: 3 }[t], m = new Vector3(), h = m.clone(), y = new Triangle(), g = i * o, v = o - g, b = s + 1, w = new Vector3(), S = (W, H) => w.subVectors(W, H).normalize(), P = (W, H) => Array(W).fill(void 0).map(H), _ = P(r.length / 3, (W, H) => new Vector3().fromArray(r, H * 3).setLength(o)), x = [], C = 1e6;
      for (let W = 0; W < _.length; W++) {
        let H = _[W], V = [], G, B, L, D = 1e10, X = -1;
        for (; (X = e.indexOf(W, X + 1)) != -1; ) {
          let M = X - X % 3;
          G = e[M + (X + 1) % 3], B = e[M + (X + 2) % 3], L = H.distanceToSquared(_[G]), D = Math.min(D, L), V.push([G, B, L]);
        }
        D += 1e-6;
        let q = [], j = 0, F = V.length;
        for (let M = 0; M < F; M++) {
          [G, B, L] = V[j];
          let Q = ((_a2 = x[G]) == null ? void 0 : _a2.includes(W)) == true;
          L <= D && q.push(G + +Q * C), j = V.findIndex((re) => re[0] == B);
        }
        x.push(q);
      }
      let T = [];
      {
        let W = 0, H = 0, V, G, B = f == 3;
        for (let L = 0; L <= s; L++) {
          V = L * (L + 1) / 2, G = (L + 1) * (L + 2) / 2;
          for (let D = 0; D < s - L; D++)
            [W, H] = [V + D + L + 2, G + D + L + 3], T.push(V, G, ...B ? [H, V] : [W, G], H, W), [V, G] = [W, H];
          T.push(V, G, V + s + 2);
        }
      }
      let N = m.clone(), O = m.clone(), A = m.clone(), R = m.clone(), k = m.clone(), $ = [], te = P(_.length, () => P(f, () => m.clone()));
      for (let W = 0; W < _.length; W++) {
        m.copy(_[W]).normalize(), N.copy(m).multiplyScalar(v);
        let H = x[W];
        for (let q = 0; q < H.length; q++) {
          let j = H[q], F = H[(q + 1) % f];
          y.setFromPointsAndIndices(_, W, j % C, F % C), y.b.sub(y.a).setLength(1e10).add(y.a), y.c.sub(y.a).setLength(1e10).add(y.a), y.closestPointToPoint(N, te[W][q]);
        }
        let V = [], G = [], B = [], L = new Vector3();
        s == 0 && [...te[W]].reduce((q, j) => q.add(j), L).multiplyScalar(1 / f);
        for (let q = 0; q < f; q++) {
          let j = [], F = (q - 1 + f) % f, M = te[W][F], Q = te[W][q];
          m.copy(M).sub(N), h.copy(Q).sub(N);
          let re = N.angleTo(m), oe = m.angleTo(h), K = Math.cos(re) * g;
          s == 0 ? O.copy(L) : O.copy(N).setLength(v + K), G.push(K);
          let ee = [O, M, Q];
          for (let J = 0; J < 2; J++) {
            let ie = ee[J], ce = ee[J + 1];
            R.subVectors(ie, N), k.subVectors(ce, N), A.crossVectors(R, k).normalize();
            for (let se = 0; se < b; se++) {
              let fe = [re, oe][J] * se / b;
              m.copy(R).applyAxisAngle(A, fe).add(N), V.push(m.clone()), J && (S(m, N), j.push([se == 0 ? ie : m.clone(), w.clone()]));
            }
            J && (S(ce, N), j.push([ce, w.clone()]));
          }
          B.push(j);
        }
        $.push(B);
        let D = 2 * b, X = 2;
        for (let q = 0; q < f; q++) {
          let j = D * q, F = D * ((q + 1) % f), M = [V[j]];
          for (let re = 1; re < b; re++) {
            R = V[j + re], k = V[F + re], M.push(R);
            for (let oe = 1, K = re - X + 1; oe <= K; oe++)
              m.lerpVectors(R, k, oe / (K + 1)), m.sub(N).setLength(G[q]).add(N), M.push(m.clone());
            M.push(k);
          }
          for (let re = 0; re < b; re++)
            M.push(V[re + b + j]);
          M.push(V[F + b]);
          let Q = T.map((re) => M[re]);
          l.push(...Q.map((re) => [re.x, re.y, re.z]).flat()), u.push(...Q.map((re) => (S(re, N), [w.x, w.y, w.z])).flat());
        }
      }
      let Y = [];
      for (let W = 0; W < x.length; W++)
        for (let H = 0; H < f; H++) {
          let V = x[W][H];
          if (V < C) {
            let G = x[V].findIndex((D) => D % C == W), B = $[W][H], L = $[V][G];
            for (let D = 0; D < b; D++) {
              let X = B[D], q = L[b - D], j = B[D + 1], F = L[b - (D + 1)];
              [X, q, j, j, q, F].forEach((M) => {
                l.push(M[0].x, M[0].y, M[0].z), u.push(M[1].x, M[1].y, M[1].z);
              });
            }
            Y.push(B[0][0], L[b][0], B[b][0], L[0][0]);
          }
        }
      for (; Y.length; ) {
        let W, H, V, G;
        [W, H] = Y.splice(0, 2);
        let B = [W];
        for (; W != H; )
          B.push(H), V = Y.indexOf(H), G = V % 2, H = Y.splice(V - G, 2)[1 - G];
        w.subVectors(B[0], B[1]).cross(m.subVectors(B[0], B[2])).normalize();
        let L = w.dot(B[0]) < 0;
        L && w.negate();
        for (let D = 1; D <= B.length - 2; D++)
          [B[D + +L], B[D + 1 - +L], B[0]].forEach((X) => {
            l.push(X.x, X.y, X.z), u.push(w.x, w.y, w.z);
          });
      }
    }
    function d() {
      let p = new Vector3();
      for (let _ = 0; _ < l.length; _ += 3) {
        p.x = l[_ + 0], p.y = l[_ + 1], p.z = l[_ + 2];
        let x = S(p) / 2 / Math.PI + 0.5, C = P(p) / Math.PI + 0.5;
        c.push(x, 1 - C);
      }
      let f = new Vector3(), m = new Vector3(), h = new Vector3(), y = new Vector3(), g = new Vector2(), v = new Vector2(), b = new Vector2(), w = (_, x, C, T) => {
        T < 0 && _.x === 1 && (c[x] = _.x - 1), C.x === 0 && C.z === 0 && (c[x] = T / 2 / Math.PI + 0.5);
      };
      for (let _ = 0, x = 0; _ < l.length; _ += 9, x += 6) {
        f.set(l[_ + 0], l[_ + 1], l[_ + 2]), m.set(l[_ + 3], l[_ + 4], l[_ + 5]), h.set(l[_ + 6], l[_ + 7], l[_ + 8]), g.set(c[x + 0], c[x + 1]), v.set(c[x + 2], c[x + 3]), b.set(c[x + 4], c[x + 5]), y.copy(f).add(m).add(h).divideScalar(3);
        let C = S(y);
        w(g, x + 0, f, C), w(v, x + 2, m, C), w(b, x + 4, h, C);
      }
      for (let _ = 0; _ < c.length; _ += 6) {
        let x = c[_ + 0], C = c[_ + 2], T = c[_ + 4], N = Math.max(x, C, T), O = Math.min(x, C, T);
        N > 0.9 && O < 0.1 && (x < 0.2 && (c[_ + 0] += 1), C < 0.2 && (c[_ + 2] += 1), T < 0.2 && (c[_ + 4] += 1));
      }
      function S(_) {
        return Math.atan2(_.z, -_.x);
      }
      function P(_) {
        return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z));
      }
    }
  }
  static fromJSON(r) {
    return new fo(r.vertices, r.indices, r.radius, r.corner, r.cornerSides);
  }
};
var ch = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, detail: 0, corner: 0, cornerSides: 4 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { width: r, height: e, depth: t, detail: o, corner: i, cornerSides: s } = n.parameters, l = o === 0 && i !== 0 ? new as(r * 0.5, i, s) : new DodecahedronGeometry(r * 0.5, o);
    return l.scale(1, e / r, t / r), Object.assign(l, { userData: { ...n, type: "DodecahedronGeometry" } });
  }
};
var as = class extends fo {
  constructor(r = 1, e = 0.2, t = 4) {
    let o = (1 + Math.sqrt(5)) / 2, i = 1 / o, s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -o, 0, -i, o, 0, i, -o, 0, i, o, -i, -o, 0, -i, o, 0, i, -o, 0, i, o, 0, -o, 0, -i, o, 0, -i, -o, 0, i, o, 0, i], l = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], c = "DodecahedronGeometry";
    super(s, l, c, r, e, t), this.type = c;
  }
  static fromJSON(r) {
    return new as(r.radius, r.corner, r.cornerSides);
  }
};
var ls = 1e-12;
var jn = class {
  constructor(r) {
    this.position = new Vector2();
    this.startPosition = new Vector2();
    this.uuid = MathUtils.generateUUID();
    this.position = r.clone();
  }
  start() {
    this.reset();
  }
  reset() {
    this.startPosition.copy(this.position);
  }
  applyOffset(r) {
    this.position.copy(this.startPosition).add(r);
  }
  copy(r) {
    return this.position.copy(r.position), this.startPosition.copy(r.startPosition), this;
  }
  clone() {
    return new jn(this.position).copy(this);
  }
  toJSON() {
    return [this.position.x, this.position.y];
  }
};
var Fn = class extends jn {
  constructor(e) {
    super(e.position);
    this.parent = e;
  }
  copy(e) {
    return super.copy(e), this;
  }
  clone() {
    return new Fn(this.parent).copy(this);
  }
};
var nr = class extends jn {
  constructor(e, t) {
    super(t);
    this.controls = [];
    this.roundness = 0;
    this.areControlsDirectionsMirrored = true;
    this.uuid = e, this.controls.push(new Fn(this), new Fn(this));
  }
  static create(e, t) {
    let o = new nr(e, new Vector2(...t.position));
    return o.controls[0].position.set(...t.controlPrevious.position), o.controls[1].position.set(...t.controlNext.position), o.roundness = t.roundness, o.areControlsDirectionsMirrored = t.areControlsDirectionsMirrored, o;
  }
  getOppositeControl(e) {
    let t = this.controls.indexOf(e);
    return t === 0 ? this.controls[1] : t === 1 ? this.controls[0] : null;
  }
  applyOffsetToControls(e, t = 1) {
    for (let o = 0, i = this.controls.length; o < i; o++) {
      let s = this.controls[o];
      this.position.distanceTo(s.position) <= t ? s.position.copy(this.position) : s.applyOffset(e);
    }
  }
  controlsMoved() {
    return !(this.position.equals(this.controls[0].position) && this.position.equals(this.controls[1].position));
  }
  copy(e) {
    return super.copy(e), this.controls[0].copy(e.controls[0]), this.controls[1].copy(e.controls[1]), this.roundness = e.roundness, this.uuid = e.uuid, this;
  }
  clone() {
    return new nr(this.uuid, this.position).copy(this);
  }
  toJSON() {
    return super.toJSON().concat(this.controls[0].toJSON(), this.controls[1].toJSON(), [this.roundness]);
  }
  computeTangents() {
    var _a2, _b2;
    let e = (_a2 = this.curveBefore) == null ? void 0 : _a2.getTangentAt(1), t = (_b2 = this.curveAfter) == null ? void 0 : _b2.getTangentAt(0);
    return [e, t];
  }
  computeNormals(e = new Vector2(), t = new Vector2()) {
    let [o, i] = this.computeTangents();
    return o && i && (dh(o, e), dh(i, t)), [e, t];
  }
  computeTangent(e = new Vector2()) {
    let [t, o] = this.computeTangents();
    return t && o && e.copy(t).add(o).normalize(), e;
  }
  computeNormal(e = new Vector2()) {
    let [t, o] = this.computeNormals();
    return e.copy(t).add(o).normalize(), e;
  }
};
function dh(n, r = new Vector2()) {
  let e = n.length();
  return r.set(-n.y / e, n.x / e);
}
var Wc = (n) => n;
var kn = new Vector2();
var nl = new Vector2();
var eP = new Vector2();
var tP = new Vector2();
var rP = new Vector2();
var oP = new Vector2();
var fh = new Vector3();
var mh = new Vector3();
function hh(n) {
  let r = new Vector2();
  r.addVectors(n.v0, kn.subVectors(n.v1, n.v0).multiplyScalar(2 / 3));
  let e = new Vector2();
  return e.addVectors(n.v2, nl.subVectors(n.v1, n.v2).multiplyScalar(2 / 3)), new CubicBezierCurve(n.v0, r, e, n.v2);
}
function cs(n, r, e = Number.EPSILON) {
  return Math.abs(n - r) < e;
}
function nP(n, r, e = Number.EPSILON) {
  return n.distanceTo(r) < e;
}
function iP(n, r, e = Number.EPSILON) {
  return n.distanceTo(r) < e;
}
function $c(n, r, e) {
  let t = Math.sqrt(Math.pow(r.x - n.x, 2) + Math.pow(r.y - n.y, 2)), o = Math.sqrt(Math.pow(r.x - e.x, 2) + Math.pow(r.y - e.y, 2)), i = Math.sqrt(Math.pow(e.x - n.x, 2) + Math.pow(e.y - n.y, 2));
  return Math.acos((o * o + t * t - i * i) / (2 * o * t));
}
function yh(n, r, e) {
  return uh(n, r) && uh(r, e) && Hc(n.position, r.position, e.position);
}
function Hc(n, r, e) {
  return kn.copy(r).sub(n).cross(nl.copy(e).sub(n)) === 0;
}
function gh(n, r, e, t, o) {
  let i = Math.sqrt(Math.pow(r.x - n.x, 2) + Math.pow(r.y - n.y, 2)), s = (n.y + r.y) / 2, l = (n.x + r.x) / 2, c = Math.sqrt(Math.pow(e, 2) - Math.pow(i / 2, 2)) * (n.y - r.y) / i, u = Math.sqrt(Math.pow(e, 2) - Math.pow(i / 2, 2)) * (r.x - n.x) / i;
  return t.set(l + c, s + u), o.set(l - c, s - u), [t, o];
}
function xh(n, r, e) {
  let t = n.distanceTo(e), o = r.distanceTo(e);
  return t < o ? r : n;
}
function vh(n, r, e, t, o, i) {
  let s = r.x - n.x, l = r.y - n.y, c = e.x - n.x, u = e.y - n.y, a = Math.sqrt((s + c) * (s + c) + (l + u) * (l + u)), d;
  return $c(r, n, e) > Math.PI && (a *= -1), cs(u, l) ? d = (l + u) * (t / a - 0.5) * 8 / 3 / (s - c) : d = (s + c) * (t / a - 0.5) * 8 / 3 / (u - l), o.set(r.x - d * l, r.y + d * s), i.set(e.x + d * u, e.y - d * c), [o, i];
}
function Yc(n, r) {
  return n.position.equals(n.controls[1].position) && r.position.equals(r.controls[0].position);
}
function uh(n, r) {
  return Hc(n.position, n.controls[1].position, r.position) && Hc(n.position, r.controls[0].position, r.position);
}
function bh(n, r, e, t, o = 0.5) {
  let i = kn.subVectors(r, n).multiplyScalar(o).add(n), s = nl.subVectors(e, r).multiplyScalar(o).add(r), l = eP.subVectors(t, e).multiplyScalar(o).add(e), c = i, u = tP.subVectors(s, i).multiplyScalar(o).add(i), a = rP.subVectors(l, s).multiplyScalar(o).add(s), d = l, p = oP.subVectors(a, u).multiplyScalar(o).add(u);
  return [n.x, n.y, c.x, c.y, u.x, u.y, p.x, p.y, a.x, a.y, d.x, d.y, t.x, t.y];
}
function Sh(n, r, e = 12, t = true) {
  let o = mh.set(0, 0, 0), i, s = 0, l = [];
  for (let c = 0; c < r.length; c++) {
    let u = Wc(r[c]), a = kn, d = mo(u, e);
    l.push(d);
    for (let p = 0; p <= d; p++)
      if (u instanceof CubicBezierCurve || u instanceof QuadraticBezierCurve || u instanceof LineCurve) {
        if (u.getPoint(p / d, a), o.set(a.x, a.y, 0), i !== void 0 && iP(i, o))
          continue;
        i === void 0 && (i = fh), i.copy(o), n.setXYZ(s, o.x, o.y, o.z), s++;
      }
  }
  return t && s > 1 && !(n.getX(s - 1) === n.getX(0) && n.getY(s - 1) === n.getY(0) && n.getZ(s - 1) === n.getZ(0)) && (n.setXYZ(s, n.getX(0), n.getY(0), n.getZ(0)), s++), n;
}
function wh(n, r, e, t = 12, o = true) {
  let i = mh.set(0, 0, 0), s = 0, l = [];
  for (let c = 0; c < r.length; c++) {
    if (e[c] === false)
      continue;
    let u, a = Wc(r[c]), d = kn, p = mo(a, t);
    l.push(p);
    for (let f = 0; f <= p; f++)
      if (a instanceof CubicBezierCurve || a instanceof QuadraticBezierCurve || a instanceof LineCurve) {
        if (a.getPoint(f / p, d), i.set(d.x, d.y, 0), u == null ? void 0 : u.equals(i))
          continue;
        u === void 0 ? u = fh : (n.setXYZ(s, u.x, u.y, u.z), s++, n.setXYZ(s, i.x, i.y, i.z), s++), u.copy(i);
      }
  }
  return o && s > 1 && !(n.getX(s - 1) === n.getX(0) && n.getY(s - 1) === n.getY(0) && n.getZ(s - 1) === n.getZ(0)) && (n.setXYZ(s, n.getX(0), n.getY(0), n.getZ(0)), s++), l;
}
function Xc(n, r = 12, e = false) {
  let t = [];
  for (let o = 0, i = n.length; o < i; o++) {
    let s = n[o], l = 0;
    if (e && s.roundedCurveCorner !== void 0) {
      let c = mo(s.roundedCurveCorner, r) * 0.5;
      o > 0 && (t[o - 1] += c), l += c;
    }
    s.curveAfter !== void 0 && (l += mo(s.curveAfter, r)), t.push(l);
  }
  return n.length > 0 && e && n[0].roundedCurveCorner !== void 0 && (t[n.length - 1] += mo(n[0].roundedCurveCorner, r) * 0.5), t;
}
function mo(n, r = 12) {
  return n && n instanceof EllipseCurve ? r * 2 : n && (n instanceof LineCurve || n instanceof LineCurve3) ? 1 : n && n instanceof SplineCurve ? r * n.points.length : r;
}
function _h(n, r, e = 12, t = true) {
  let o, i = 0;
  for (let s = 0; s < r.length; s++) {
    let l = Wc(r[s]), c = mo(l, e), u = kn;
    for (let a = 0; a <= c; a++)
      if (l instanceof CubicBezierCurve || l instanceof QuadraticBezierCurve || l instanceof LineCurve) {
        if (l.getPoint(a / c, u), o !== void 0 && nP(o, u, ls))
          continue;
        o === void 0 && (o = nl), o.copy(u), n.push(u.x, u.y), i++;
      }
  }
  return cs(n[0], n[n.length - 2], ls) && cs(n[1], n[n.length - 1], ls) && (n.pop(), n.pop()), t && i > 1 && !(cs(n[i - 1], n[1], ls) && cs(n[i - 2], n[0], ls)) && (n.push(n[0], n[1]), i++), n;
}
var Qc = new Vector2();
var lP = new Vector2();
var cP = new Vector2();
var dP = new Vector2();
var uP = new Vector2();
var pP = new Vector2();
var we = class extends Shape {
  constructor(e = 100, t = 100) {
    super();
    this.points = [];
    this.shapeHoles = [];
    this.plane = new Plane(new Vector3(0, 0, -1));
    this.subdivision = 0;
    this.controlSnapDistance = 4;
    this.pointIDs = 0;
    this.isMesh2D = false;
    this._roundness = 0;
    this.isClosed = false;
    this.useCubicForRoundedCorners = true;
    this.uuid = MathUtils.generateUUID();
    this.needsUpdate = false;
    this.roundedCurves = [];
    this._width = e, this._height = t;
  }
  static createFromState(e, t, o) {
    let i = new we();
    return i.isClosed = e.isClosed, i.points = e.points.map((s) => nr.create(s.id, s.data)), typeof e.roundness == "number" && (i.roundness = e.roundness), i.shapeHoles = e.shapeHoles.map((s) => we.createFromState(s)), t !== void 0 && o !== void 0 && i.applySize(t, o), i.update(), i;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get roundness() {
    return this._roundness;
  }
  set roundness(e) {
    if (this._roundness !== e) {
      this._roundness = e;
      for (let t = 0, o = this.points.length; t < o; t++)
        this.points[t].roundness = e;
      this.needsUpdate = true;
    }
  }
  getPointsIndexesByIds(e) {
    return e.map((t) => this.getPointIndexById(t)).filter((t) => t >= 0);
  }
  getPointIndexById(e) {
    let t = this.points.length, o = this.points.findIndex((i) => i.uuid === e);
    if (o < 0) {
      let i = t;
      for (let s = 0, l = this.shapeHoles.length; s < l; s++) {
        let c = this.shapeHoles[s], u = c.points.length, a = c.getPointIndexById(e);
        if (a < 0)
          i += u;
        else
          return a + i;
      }
    }
    return o;
  }
  getLineIndexById(e) {
    return this.getPointIndexById(e);
  }
  getBezierPoint(e) {
    if (e <= this.points.length - 1)
      return this.points[e];
    if (this.shapeHoles.length > 0) {
      let t = this.points.length;
      for (let o = 0, i = this.shapeHoles.length; o < i; o++) {
        let s = this.shapeHoles[o], l = e - t;
        if (l <= s.points.length - 1)
          return s.points[l];
        t += s.points.length;
      }
    }
    throw new Error("This shape does not have a point for this index: " + e);
  }
  getBezierPointIndex(e) {
    let t = this.points.indexOf(e);
    if (t >= 0)
      return t;
    if (t = this.points.length, this.shapeHoles.length > 0)
      for (let o = 0, i = this.shapeHoles.length; o < i; o++) {
        let s = this.shapeHoles[o], l = s.points.indexOf(e);
        if (l >= 0)
          return t + l;
        t += s.points.length;
      }
    return -1;
  }
  getAllPoints() {
    let e = [].concat(...this.shapeHoles.map((t) => t.points));
    return [...this.points, ...e];
  }
  applySize(e, t) {
    e === 0 && (e = 1e-3), t === 0 && (t = 1e-3), this._width = e, this._height = t;
  }
  applyScale(e, t) {
    let o = Qc.set(e, t);
    for (let i = 0, s = this.points.length; i < s; i++) {
      let l = this.points[i];
      l.position.multiply(o), l.controls[0].position.multiply(o), l.controls[1].position.multiply(o);
    }
    for (let i = 0, s = this.shapeHoles.length; i < s; i++)
      this.shapeHoles[i].applyScale(e, t);
    this._update();
  }
  createPoint(e, t = 0, o = MathUtils.generateUUID()) {
    let i;
    e instanceof Vector2 ? i = e : i = new Vector2(e, t);
    let s = new nr(o, i);
    return s.roundness = this.roundness, s;
  }
  addPoint(e) {
    this.points.push(e), this.needsUpdate = true;
  }
  addPointAt(e, t) {
    this.points.splice(t, 0, e), this.needsUpdate = true;
  }
  getPointByUuid(e) {
    for (let t = 0, o = this.points.length; t < o; t++) {
      let i = this.points[t];
      if (i.uuid === e)
        return i;
    }
    for (let t = 0, o = this.shapeHoles.length; t < o; t++) {
      let s = this.shapeHoles[t].getPointByUuid(e);
      if (s)
        return s;
    }
  }
  getFirstPoint() {
    return this.points[0];
  }
  getLastPoint() {
    return this.points[this.points.length - 1];
  }
  removePoint(e) {
    let t = this.points.indexOf(e);
    t >= 0 && this.points.splice(t, 1), this.needsUpdate = true;
  }
  removePointById(e) {
    let t = this.points.find((o) => o.uuid === e);
    t && this.removePoint(t);
  }
  update() {
    for (let e = 0, t = this.shapeHoles.length; e < t; e++)
      this.shapeHoles[e].update();
    this._update();
  }
  extractShapePointsToBuffer(e, t = 12, o = false) {
    this.subdivision = t, this.curveDivisions === void 0 && this.computeCurveDivisions(t);
    let i = o ? this.roundedCurveDivisions : this.curveDivisions;
    return Sh(e, o ? this.roundedCurves : this.curves, t, this.autoClose), i.reduce((s, l) => s + l, 0) + 1;
  }
  computeCurveDivisions(e = 12) {
    return this.curveDivisions = Xc(this.points, e, false), this.roundedCurveDivisions = Xc(this.points, e, true), this.curveDivisions;
  }
  extractFilteredShapePointsToBuffer(e, t, o = 12) {
    return wh(e, this.curves, t, o, this.autoClose).reduce((s, l) => s + l, 0) * 2;
  }
  extractShapePointsToFlatArray(e, t = 12) {
    return this.subdivision = t, this.curveDivisions === void 0 && this.computeCurveDivisions(t), _h(e, this.roundedCurves, t, this.autoClose);
  }
  getCurveIndexFromVertexId(e, t = false) {
    let o = 0;
    this.curveDivisions === void 0 && this.computeCurveDivisions(this.subdivision);
    let i = t ? this.roundedCurveDivisions : this.curveDivisions, s = 0;
    t && this.points[0].roundedCurveCorner !== void 0 && (s = mo(this.points[0].roundedCurveCorner, this.subdivision) * 0.5);
    let l = e - s;
    l < 0 && (l += i.reduce((c, u) => c + u, 0));
    for (let c = 0, u = i.length; c < u; c++) {
      let a = i[c];
      if (l < o + a)
        return [c, (l - o + 1) / a];
      o += a;
    }
    return [0, 1];
  }
  getCurveT(e, t, o) {
    let i = this.points[e], s = this.points[e >= this.points.length - 1 ? 0 : e + 1], l = this.curveDivisions, c = l[e];
    if (Yc(i, s)) {
      let d = i.position.distanceTo(s.position);
      return i.position.distanceTo(Qc.set(o.x, o.y)) / d;
    }
    let u = 0;
    for (let d = 0; d < e; d++)
      u += l[d];
    return (t - u) / c;
  }
  dispose() {
  }
  _applyCurveForPoint(e, t) {
    Yc(t, e) ? this.lineTo(e.position.x, e.position.y) : this.bezierCurveTo(t.controls[1].position.x, t.controls[1].position.y, e.controls[0].position.x, e.controls[0].position.y, e.position.x, e.position.y);
    let o = this.curves[this.curves.length - 1];
    e.curveBefore = o, t.curveAfter = o;
    let i = o.clone();
    e.roundedCurveBefore = i, t.roundedCurveAfter = i, e.roundedCurveCorner = void 0, this.roundedCurves.push(i);
  }
  _update() {
    if (this.curves = [], this.roundedCurves = [], !this.points.length)
      return;
    for (let t = 0, o = this.points.length; t < o; t++) {
      let i = this.points[t];
      if (t === 0)
        this.moveTo(i.position.x, i.position.y);
      else {
        let s = this.points[t - 1];
        this._applyCurveForPoint(i, s);
      }
    }
    let e = this.getLastPoint();
    if ((e == null ? void 0 : e.curveAfter) && (e.curveAfter = void 0), this.isClosed) {
      let t = this.points[0], o = this.points[this.points.length - 1];
      this._applyCurveForPoint(t, o);
    }
    if (this.points.length > 2) {
      let t = 0;
      for (let o = 0, i = this.points.length; o < i; o++) {
        let s = this.points[o], l = this.points[o - 1] ?? this.points[this.points.length - 1], c = this.points[o + 1] ?? this.points[0], u = s.roundness, a = l && c && yh(l, s, c);
        if (!s.controlsMoved() && u > 0 && !a) {
          let d = s.curveBefore, p = s.curveAfter;
          if (d === void 0 || p === void 0)
            continue;
          let f = s.roundedCurveBefore, m = s.roundedCurveAfter, h = d.getLength(), y = p.getLength(), g = Math.min(u, h * 0.499), v = Math.min(u, y * 0.499), b = Math.min(g, v), w = 1 - b / h, S = b / y, P = d.getPointAt(w, Qc), _ = p.getPointAt(S, lP);
          this._subSplitCurve(d, f, w, P, void 0), this._subSplitCurve(p, m, S, void 0, _);
          let x;
          if (this.useCubicForRoundedCorners) {
            let C = $c(P, s.position, _) / 2, T = Math.tan(C) * P.distanceTo(s.position), [N, O] = gh(P, _, T, cP, dP), A = xh(N, O, s.position), [R, k] = vh(A, P, _, T, uP, pP);
            x = new CubicBezierCurve(P.clone(), R.clone(), k.clone(), _.clone());
          } else
            x = new QuadraticBezierCurve(P.clone(), s.position.clone(), _.clone());
          s.roundedCurveCorner = x, this.roundedCurves.splice(o + t, 0, x), t++;
        }
      }
    }
  }
  _subSplitCurve(e, t, o, i, s) {
    if (e instanceof LineCurve)
      i !== void 0 && t.v2.copy(i), s !== void 0 && t.v1.copy(s);
    else {
      let l = e, c = t, u = l.getUtoTmapping(o, 0), a = bh(l.v0, l.v1, l.v2, l.v3, u);
      return i !== void 0 && (c.v0.set(a[0], a[1]), c.v1.set(a[2], a[3]), c.v2.set(a[4], a[5]), c.v3.set(a[6], a[7])), s !== void 0 && (c.v0.set(a[6], a[7]), c.v1.set(a[8], a[9]), c.v2.set(a[10], a[11]), c.v3.set(a[12], a[13])), c;
    }
    return t;
  }
  clone() {
    let e = new we(this._width, this._height);
    return e.points = this.points.map((t) => t.clone()), e.isClosed = this.isClosed, e.roundness = this.roundness, e.isMesh2D = this.isMesh2D, e.shapeHoles = this.shapeHoles.map((t) => t.clone()), e;
  }
  toJSON() {
    return { points: this.points.reduce((e, t) => e.concat(t.toJSON()), []), shapeHoles: this.shapeHoles.map((e) => e.toJSON()), isClosed: this.isClosed, roundness: this.roundness };
  }
  fromJSON(e) {
    var _a2;
    this.points = [], this.pointIDs = 0;
    let t = e.points.length / 7;
    for (let o = 0; o < t; o++) {
      let i = o * 7, s = e.points[i + 0], l = e.points[i + 1], c = e.points[i + 2], u = e.points[i + 3], a = e.points[i + 4], d = e.points[i + 5], p = e.points[i + 6], f = new nr(MathUtils.generateUUID(), new Vector2(s, l));
      f.controls[0].position.set(c, u), f.controls[1].position.set(a, d), f.roundness = p, this.points.push(f);
    }
    return this.shapeHoles = ((_a2 = e.shapeHoles) == null ? void 0 : _a2.length) ? e.shapeHoles.map((o) => {
      let i = new we();
      return i.fromJSON(o), i;
    }) : [], this.isClosed = e.isClosed, this._roundness = e.roundness, this._update(), this;
  }
  fromShape(e) {
    let t = (i, s) => {
      s instanceof CubicBezierCurve && s.v3.equals(i.position) && i.controls[0].position.copy(s.v2);
    }, o = (i) => {
      let s = [], l, c;
      for (l = 0, c = i.length; l < c; l++)
        i[l] instanceof QuadraticBezierCurve && (i[l] = hh(i[l]));
      for (l = 0, c = i.length; l < c; l++) {
        let d = i[l], p = l > 0 ? i[l - 1] : null, f;
        d instanceof CubicBezierCurve ? (f = this.createPoint(d.v0), f.controls[1].position.copy(d.v1)) : d instanceof LineCurve && (f = this.createPoint(d.v1)), f !== void 0 && (p !== null && t(f, p), s.push(f));
      }
      let u = i[i.length - 1], a = false;
      return u instanceof CubicBezierCurve ? u.v3.equals(s[0].position) && (s[0].controls[0].position.copy(u.v2), a = true) : u instanceof LineCurve && u.v2.equals(s[0].position) && (a = true), this.isClosed = a, s;
    };
    return this.points = o(e.curves), e instanceof Shape && (this.shapeHoles = e.holes.map((i) => {
      let s = new we();
      return s.fromShape(i), s;
    })), this.update(), this;
  }
  updatePoint(e, t) {
    let o = this.getPointByUuid(e);
    o && (t.position !== void 0 && o.position.fromArray(t.position), t.roundness !== void 0 && (o.roundness = t.roundness), t.areControlsDirectionsMirrored !== void 0 && (o.areControlsDirectionsMirrored = t.areControlsDirectionsMirrored), this.needsUpdate = true);
  }
  updatePreviousControl(e, t) {
    var _a2;
    let i = (_a2 = this.getPointByUuid(e)) == null ? void 0 : _a2.controls[0];
    i && (t.position && i.position.fromArray(t.position), this.needsUpdate = true);
  }
  updateNextControl(e, t) {
    var _a2;
    let i = (_a2 = this.getPointByUuid(e)) == null ? void 0 : _a2.controls[1];
    i && (t.position && i.position.fromArray(t.position), this.needsUpdate = true);
  }
};
var ed = Math.PI * 2;
function Jc({ x: n, y: r }, e, t, o, i) {
  return { x: n * e + o, y: r * t + i };
}
function fP(n, r) {
  let e = r === 1.5707963267948966 ? 0.551915024494 : r === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(r / 4), t = Math.cos(n), o = Math.sin(n), i = Math.cos(n + r), s = Math.sin(n + r);
  return [{ x: t - o * e, y: o + t * e }, { x: i + s * e, y: s - i * e }, { x: i, y: s }];
}
function Oh(n, r, e, t) {
  let o = n * t - r * e < 0 ? -1 : 1, i = Math.min(1, Math.max(-1, n * e + r * t));
  return o * Math.acos(i);
}
function mP(n, r, e, t, o, i, s, l, c, u) {
  let a = Math.pow(o, 2), d = Math.pow(i, 2), p = Math.pow(s, 2), f = Math.pow(l, 2), m = a * d - a * f - d * p;
  m < 0 && (m = 0), m /= a * f + d * p, m = Math.sqrt(m) * (c === u ? -1 : 1);
  let h = m * o / i * l, y = m * -i / o * s, g = h + (n + e) / 2, v = y + (r + t) / 2, b = (s - h) / o, w = (l - y) / i, S = (-s - h) / o, P = (-l - y) / i, _ = Oh(1, 0, b, w), x = Oh(b, w, S, P);
  return !u && x > 0 && (x -= ed), u && x < 0 && (x += ed), { centerx: g, centery: v, ang1: _, ang2: x };
}
function Ah({ px: n, py: r, cx: e, cy: t, rx: o, ry: i, largeArcFlag: s, sweepFlag: l }) {
  let c = [];
  if (o === 0 || i === 0)
    return [];
  let u = (n - e) / 2, a = (r - t) / 2;
  if (u === 0 && a === 0)
    return [];
  o = Math.abs(o), i = Math.abs(i);
  let d = Math.pow(u, 2) / Math.pow(o, 2) + Math.pow(a, 2) / Math.pow(i, 2);
  d > 1 && (o *= Math.sqrt(d), i *= Math.sqrt(d));
  let p = mP(n, r, e, t, o, i, u, a, s, l), { ang1: f, ang2: m } = p, { centerx: h, centery: y } = p, g = Math.abs(m) / (ed / 4);
  Math.abs(1 - g) < 1e-7 && (g = 1);
  let v = Math.max(Math.ceil(g), 1);
  m /= v;
  for (let b = 0; b < v; b++)
    c.push(fP(f, m)), f += m;
  return c.map((b) => {
    let { x: w, y: S } = Jc(b[0], o, i, h, y), { x: P, y: _ } = Jc(b[1], o, i, h, y), { x, y: C } = Jc(b[2], o, i, h, y);
    return { x1: w, y1: S, x2: P, y2: _, x, y: C };
  });
}
var be;
(function(n) {
  n[n.ODD = 0] = "ODD", n[n.NONZERO = 1] = "NONZERO", n[n.POSITIVE = 2] = "POSITIVE", n[n.NEGATIVE = 3] = "NEGATIVE", n[n.ABS_GEQ_TWO = 4] = "ABS_GEQ_TWO";
})(be || (be = {}));
var Ge;
(function(n) {
  n[n.POLYGONS = 0] = "POLYGONS", n[n.CONNECTED_POLYGONS = 1] = "CONNECTED_POLYGONS", n[n.BOUNDARY_CONTOURS = 2] = "BOUNDARY_CONTOURS";
})(Ge || (Ge = {}));
function ue(n, r) {
  if (!n)
    throw r || "Assertion Failed!";
}
var le = function() {
  function n() {
  }
  return n.vertEq = function(r, e) {
    return r.s === e.s && r.t === e.t;
  }, n.vertLeq = function(r, e) {
    return r.s < e.s || r.s === e.s && r.t <= e.t;
  }, n.transLeq = function(r, e) {
    return r.t < e.t || r.t === e.t && r.s <= e.s;
  }, n.edgeGoesLeft = function(r) {
    return n.vertLeq(r.Dst, r.Org);
  }, n.edgeGoesRight = function(r) {
    return n.vertLeq(r.Org, r.Dst);
  }, n.vertL1dist = function(r, e) {
    return Math.abs(r.s - e.s) + Math.abs(r.t - e.t);
  }, n.edgeEval = function(r, e, t) {
    ue(n.vertLeq(r, e) && n.vertLeq(e, t));
    var o = e.s - r.s, i = t.s - e.s;
    return o + i > 0 ? o < i ? e.t - r.t + (r.t - t.t) * (o / (o + i)) : e.t - t.t + (t.t - r.t) * (i / (o + i)) : 0;
  }, n.edgeSign = function(r, e, t) {
    ue(n.vertLeq(r, e) && n.vertLeq(e, t));
    var o = e.s - r.s, i = t.s - e.s;
    return o + i > 0 ? (e.t - t.t) * o + (e.t - r.t) * i : 0;
  }, n.transEval = function(r, e, t) {
    ue(n.transLeq(r, e) && n.transLeq(e, t));
    var o = e.t - r.t, i = t.t - e.t;
    return o + i > 0 ? o < i ? e.s - r.s + (r.s - t.s) * (o / (o + i)) : e.s - t.s + (t.s - r.s) * (i / (o + i)) : 0;
  }, n.transSign = function(r, e, t) {
    ue(n.transLeq(r, e) && n.transLeq(e, t));
    var o = e.t - r.t, i = t.t - e.t;
    return o + i > 0 ? (e.s - t.s) * o + (e.s - r.s) * i : 0;
  }, n.vertCCW = function(r, e, t) {
    return r.s * (e.t - t.t) + e.s * (t.t - r.t) + t.s * (r.t - e.t) >= 0;
  }, n.interpolate = function(r, e, t, o) {
    return r = r < 0 ? 0 : r, t = t < 0 ? 0 : t, r <= t ? t === 0 ? (e + o) / 2 : e + (o - e) * (r / (r + t)) : o + (e - o) * (t / (r + t));
  }, n.intersect = function(r, e, t, o, i) {
    var s, l, c;
    n.vertLeq(r, e) || (c = r, r = e, e = c), n.vertLeq(t, o) || (c = t, t = o, o = c), n.vertLeq(r, t) || (c = r, r = t, t = c, c = e, e = o, o = c), n.vertLeq(t, e) ? n.vertLeq(e, o) ? (s = n.edgeEval(r, t, e), l = n.edgeEval(t, e, o), s + l < 0 && (s = -s, l = -l), i.s = n.interpolate(s, t.s, l, e.s)) : (s = n.edgeSign(r, t, e), l = -n.edgeSign(r, o, e), s + l < 0 && (s = -s, l = -l), i.s = n.interpolate(s, t.s, l, o.s)) : i.s = (t.s + e.s) / 2, n.transLeq(r, e) || (c = r, r = e, e = c), n.transLeq(t, o) || (c = t, t = o, o = c), n.transLeq(r, t) || (c = r, r = t, t = c, c = e, e = o, o = c), n.transLeq(t, e) ? n.transLeq(e, o) ? (s = n.transEval(r, t, e), l = n.transEval(t, e, o), s + l < 0 && (s = -s, l = -l), i.t = n.interpolate(s, t.t, l, e.t)) : (s = n.transSign(r, t, e), l = -n.transSign(r, o, e), s + l < 0 && (s = -s, l = -l), i.t = n.interpolate(s, t.t, l, o.t)) : i.t = (t.t + e.t) / 2;
  }, n;
}();
var ds = function() {
  function n() {
    this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = false, this.inside = false;
  }
  return n;
}();
var sl = function() {
  function n(r) {
    this.side = r, this.next = null, this.Org = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Lface = null, this.activeRegion = null, this.winding = 0;
  }
  return Object.defineProperty(n.prototype, "Rface", { get: function() {
    return this.Sym.Lface;
  }, set: function(r) {
    this.Sym.Lface = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(n.prototype, "Dst", { get: function() {
    return this.Sym.Org;
  }, set: function(r) {
    this.Sym.Org = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(n.prototype, "Oprev", { get: function() {
    return this.Sym.Lnext;
  }, set: function(r) {
    this.Sym.Lnext = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(n.prototype, "Lprev", { get: function() {
    return this.Onext.Sym;
  }, set: function(r) {
    this.Onext.Sym = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(n.prototype, "Dprev", { get: function() {
    return this.Lnext.Sym;
  }, set: function(r) {
    this.Lnext.Sym = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(n.prototype, "Rprev", { get: function() {
    return this.Sym.Onext;
  }, set: function(r) {
    this.Sym.Onext = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(n.prototype, "Dnext", { get: function() {
    return this.Sym.Onext.Sym;
  }, set: function(r) {
    this.Sym.Onext.Sym = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(n.prototype, "Rnext", { get: function() {
    return this.Sym.Lnext.Sym;
  }, set: function(r) {
    this.Sym.Lnext.Sym = r;
  }, enumerable: true, configurable: true }), n;
}();
var Un = function() {
  function n() {
    this.next = null, this.prev = null, this.anEdge = null, this.coords = [0, 0, 0], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0;
  }
  return n;
}();
var Nh = function() {
  function n() {
    var r = new Un(), e = new ds(), t = new sl(0), o = new sl(1);
    r.next = r.prev = r, r.anEdge = null, e.next = e.prev = e, t.next = t, t.Sym = o, o.next = o, o.Sym = t, this.vHead = r, this.fHead = e, this.eHead = t, this.eHeadSym = o;
  }
  return n.prototype.makeEdge_ = function(r) {
    var e = new sl(0), t = new sl(1);
    r.Sym.side < r.side && (r = r.Sym);
    var o = r.Sym.next;
    return t.next = o, o.Sym.next = e, e.next = r, r.Sym.next = t, e.Sym = t, e.Onext = e, e.Lnext = t, e.Org = null, e.Lface = null, e.winding = 0, e.activeRegion = null, t.Sym = e, t.Onext = t, t.Lnext = e, t.Org = null, t.Lface = null, t.winding = 0, t.activeRegion = null, e;
  }, n.prototype.splice_ = function(r, e) {
    var t = r.Onext, o = e.Onext;
    t.Sym.Lnext = e, o.Sym.Lnext = r, r.Onext = o, e.Onext = t;
  }, n.prototype.makeVertex_ = function(r, e, t) {
    var o = r;
    ue(o, "Vertex can't be null!");
    var i = t.prev;
    o.prev = i, i.next = o, o.next = t, t.prev = o, o.anEdge = e;
    var s = e;
    do
      s.Org = o, s = s.Onext;
    while (s !== e);
  }, n.prototype.makeFace_ = function(r, e, t) {
    var o = r;
    ue(o, "Face can't be null");
    var i = t.prev;
    o.prev = i, i.next = o, o.next = t, t.prev = o, o.anEdge = e, o.trail = null, o.marked = false, o.inside = t.inside;
    var s = e;
    do
      s.Lface = o, s = s.Lnext;
    while (s !== e);
  }, n.prototype.killEdge_ = function(r) {
    r.Sym.side < r.side && (r = r.Sym);
    var e = r.next, t = r.Sym.next;
    e.Sym.next = t, t.Sym.next = e;
  }, n.prototype.killVertex_ = function(r, e) {
    var t = r.anEdge, o = t;
    do
      o.Org = e, o = o.Onext;
    while (o !== t);
    var i = r.prev, s = r.next;
    s.prev = i, i.next = s;
  }, n.prototype.killFace_ = function(r, e) {
    var t = r.anEdge, o = t;
    do
      o.Lface = e, o = o.Lnext;
    while (o !== t);
    var i = r.prev, s = r.next;
    s.prev = i, i.next = s;
  }, n.prototype.makeEdge = function() {
    var r = new Un(), e = new Un(), t = new ds(), o = this.makeEdge_(this.eHead);
    return this.makeVertex_(r, o, this.vHead), this.makeVertex_(e, o.Sym, this.vHead), this.makeFace_(t, o, this.fHead), o;
  }, n.prototype.splice = function(r, e) {
    var t = false, o = false;
    if (r !== e) {
      if (e.Org !== r.Org && (o = true, this.killVertex_(e.Org, r.Org)), e.Lface !== r.Lface && (t = true, this.killFace_(e.Lface, r.Lface)), this.splice_(e, r), !o) {
        var i = new Un();
        this.makeVertex_(i, e, r.Org), r.Org.anEdge = r;
      }
      if (!t) {
        var s = new ds();
        this.makeFace_(s, e, r.Lface), r.Lface.anEdge = r;
      }
    }
  }, n.prototype.delete = function(r) {
    var e = r.Sym, t = false;
    if (r.Lface !== r.Rface && (t = true, this.killFace_(r.Lface, r.Rface)), r.Onext === r)
      this.killVertex_(r.Org, null);
    else if (r.Rface.anEdge = r.Oprev, r.Org.anEdge = r.Onext, this.splice_(r, r.Oprev), !t) {
      var o = new ds();
      this.makeFace_(o, r, r.Lface);
    }
    e.Onext === e ? (this.killVertex_(e.Org, null), this.killFace_(e.Lface, null)) : (r.Lface.anEdge = e.Oprev, e.Org.anEdge = e.Onext, this.splice_(e, e.Oprev)), this.killEdge_(r);
  }, n.prototype.addEdgeVertex = function(r) {
    var e = this.makeEdge_(r), t = e.Sym;
    this.splice_(e, r.Lnext), e.Org = r.Dst;
    var o = new Un();
    return this.makeVertex_(o, t, e.Org), e.Lface = t.Lface = r.Lface, e;
  }, n.prototype.splitEdge = function(r) {
    var e = this.addEdgeVertex(r), t = e.Sym;
    return this.splice_(r.Sym, r.Sym.Oprev), this.splice_(r.Sym, t), r.Dst = t.Org, t.Dst.anEdge = t.Sym, t.Rface = r.Rface, t.winding = r.winding, t.Sym.winding = r.Sym.winding, t.idx = r.idx, t.Sym.idx = r.Sym.idx, t;
  }, n.prototype.connect = function(r, e) {
    var t = false, o = this.makeEdge_(r), i = o.Sym;
    if (e.Lface !== r.Lface && (t = true, this.killFace_(e.Lface, r.Lface)), this.splice_(o, r.Lnext), this.splice_(i, e), o.Org = r.Dst, i.Org = e.Org, o.Lface = i.Lface = r.Lface, r.Lface.anEdge = i, !t) {
      var s = new ds();
      this.makeFace_(s, o, r.Lface);
    }
    return o;
  }, n.prototype.zapFace = function(r) {
    var e = r.anEdge, t, o, i, s, l;
    o = e.Lnext;
    do
      t = o, o = t.Lnext, t.Lface = null, t.Rface === null && (t.Onext === t ? this.killVertex_(t.Org, null) : (t.Org.anEdge = t.Onext, this.splice_(t, t.Oprev)), i = t.Sym, i.Onext === i ? this.killVertex_(i.Org, null) : (i.Org.anEdge = i.Onext, this.splice_(i, i.Oprev)), this.killEdge_(t));
    while (t != e);
    s = r.prev, l = r.next, l.prev = s, s.next = l;
  }, n.prototype.countFaceVerts_ = function(r) {
    var e = r.anEdge, t = 0;
    do
      t++, e = e.Lnext;
    while (e !== r.anEdge);
    return t;
  }, n.prototype.mergeConvexFaces = function(r) {
    var e, t, o, i, s, l, c;
    for (e = this.fHead.next; e !== this.fHead; e = e.next)
      if (!!e.inside)
        for (t = e.anEdge, s = t.Org; o = t.Lnext, i = t.Sym, i && i.Lface && i.Lface.inside && (l = this.countFaceVerts_(e), c = this.countFaceVerts_(i.Lface), l + c - 2 <= r && le.vertCCW(t.Lprev.Org, t.Org, i.Lnext.Lnext.Org) && le.vertCCW(i.Lprev.Org, i.Org, t.Lnext.Lnext.Org) && (o = i.Lnext, this.delete(i), t = null, i = null)), !(t && t.Lnext.Org === s); )
          t = o;
    return true;
  }, n.prototype.check = function() {
    var r = this.fHead, e = this.vHead, t = this.eHead, o, i, s, l, c, u;
    for (i = r, i = r; (o = i.next) !== r; i = o) {
      ue(o.prev === i), c = o.anEdge;
      do
        ue(c.Sym !== c), ue(c.Sym.Sym === c), ue(c.Lnext.Onext.Sym === c), ue(c.Onext.Sym.Lnext === c), ue(c.Lface === o), c = c.Lnext;
      while (c !== o.anEdge);
    }
    for (ue(o.prev === i && o.anEdge === null), l = e, l = e; (s = l.next) !== e; l = s) {
      ue(s.prev === l), c = s.anEdge;
      do
        ue(c.Sym !== c), ue(c.Sym.Sym === c), ue(c.Lnext.Onext.Sym === c), ue(c.Onext.Sym.Lnext === c), ue(c.Org === s), c = c.Onext;
      while (c !== s.anEdge);
    }
    for (ue(s.prev === l && s.anEdge === null), u = t, u = t; (c = u.next) !== t; u = c)
      ue(c.Sym.next === u.Sym), ue(c.Sym !== c), ue(c.Sym.Sym === c), ue(c.Org !== null), ue(c.Dst !== null), ue(c.Lnext.Onext.Sym === c), ue(c.Onext.Sym.Lnext === c);
    ue(c.Sym.next === u.Sym && c.Sym === this.eHeadSym && c.Sym.Sym === c && c.Org === null && c.Dst === null && c.Lface === null && c.Rface === null);
  }, n;
}();
var Ch = function() {
  function n() {
    this.handle = null;
  }
  return n;
}();
var Ih = function() {
  function n() {
    this.key = null, this.node = 0;
  }
  return n;
}();
var hP = function() {
  function n(r, e) {
    this.leq = e, this.max = 0, this.nodes = [], this.handles = [], this.initialized = false, this.freeList = 0, this.size = 0, this.max = r, this.nodes = [], this.handles = [];
    for (var t = 0; t < r + 1; t++)
      this.nodes[t] = new Ch(), this.handles[t] = new Ih();
    this.initialized = false, this.nodes[1].handle = 1, this.handles[1].key = null;
  }
  return n.prototype.floatDown_ = function(r) {
    var e = this.nodes, t = this.handles, o, i, s;
    for (o = e[r].handle; ; ) {
      if (s = r << 1, s < this.size && this.leq(t[e[s + 1].handle].key, t[e[s].handle].key) && ++s, ue(s <= this.max), i = e[s].handle, s > this.size || this.leq(t[o].key, t[i].key)) {
        e[r].handle = o, t[o].node = r;
        break;
      }
      e[r].handle = i, t[i].node = r, r = s;
    }
  }, n.prototype.floatUp_ = function(r) {
    var e = this.nodes, t = this.handles, o, i, s;
    for (o = e[r].handle; ; ) {
      if (s = r >> 1, i = e[s].handle, s === 0 || this.leq(t[i].key, t[o].key)) {
        e[r].handle = o, t[o].node = r;
        break;
      }
      e[r].handle = i, t[i].node = r, r = s;
    }
  }, n.prototype.init = function() {
    for (var r = this.size; r >= 1; --r)
      this.floatDown_(r);
    this.initialized = true;
  }, n.prototype.min = function() {
    return this.handles[this.nodes[1].handle].key;
  }, n.prototype.insert = function(r) {
    var e, t;
    if (e = ++this.size, e * 2 > this.max) {
      this.max *= 2;
      var o, i;
      for (i = this.nodes.length, this.nodes.length = this.max + 1, o = i; o < this.nodes.length; o++)
        this.nodes[o] = new Ch();
      for (i = this.handles.length, this.handles.length = this.max + 1, o = i; o < this.handles.length; o++)
        this.handles[o] = new Ih();
    }
    return this.freeList === 0 ? t = e : (t = this.freeList, this.freeList = this.handles[t].node), this.nodes[e].handle = t, this.handles[t].node = e, this.handles[t].key = r, this.initialized && this.floatUp_(e), t;
  }, n.prototype.extractMin = function() {
    var r = this.nodes, e = this.handles, t = r[1].handle, o = e[t].key;
    return this.size > 0 && (r[1].handle = r[this.size].handle, e[r[1].handle].node = 1, e[t].key = null, e[t].node = this.freeList, this.freeList = t, --this.size, this.size > 0 && this.floatDown_(1)), o;
  }, n.prototype.delete = function(r) {
    var e = this.nodes, t = this.handles, o;
    ue(r >= 1 && r <= this.max && t[r].key !== null), o = t[r].node, e[o].handle = e[this.size].handle, t[e[o].handle].node = o, --this.size, o <= this.size && (o <= 1 || this.leq(t[e[o >> 1].handle].key, t[e[o].handle].key) ? this.floatDown_(o) : this.floatUp_(o)), t[r].key = null, t[r].node = this.freeList, this.freeList = r;
  }, n;
}();
var td = function() {
  function n() {
    this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = false, this.sentinel = false, this.dirty = false, this.fixUpperEdge = false;
  }
  return n;
}();
var Mh = function() {
  function n() {
    this.key = null, this.next = null, this.prev = null;
  }
  return n;
}();
var yP = function() {
  function n(r, e) {
    this.frame = r, this.leq = e, this.head = new Mh(), this.head.next = this.head, this.head.prev = this.head;
  }
  return n.prototype.min = function() {
    return this.head.next;
  }, n.prototype.max = function() {
    return this.head.prev;
  }, n.prototype.insert = function(r) {
    return this.insertBefore(this.head, r);
  }, n.prototype.search = function(r) {
    var e = this.head;
    do
      e = e.next;
    while (e.key !== null && !this.leq(this.frame, r, e.key));
    return e;
  }, n.prototype.insertBefore = function(r, e) {
    do
      r = r.prev;
    while (r.key !== null && !this.leq(this.frame, r.key, e));
    var t = new Mh();
    return t.key = e, t.next = r.next, r.next.prev = t, t.prev = r, r.next = t, t;
  }, n.prototype.delete = function(r) {
    r.next.prev = r.prev, r.prev.next = r.next;
  }, n;
}();
var gP = function() {
  function n() {
  }
  return n.regionBelow = function(r) {
    return r.nodeUp.prev.key;
  }, n.regionAbove = function(r) {
    return r.nodeUp.next.key;
  }, n.debugEvent = function(r) {
  }, n.addWinding = function(r, e) {
    r.winding += e.winding, r.Sym.winding += e.Sym.winding;
  }, n.edgeLeq = function(r, e, t) {
    var o = r.event, i = e.eUp, s = t.eUp;
    if (i.Dst === o)
      return s.Dst === o ? le.vertLeq(i.Org, s.Org) ? le.edgeSign(s.Dst, i.Org, s.Org) <= 0 : le.edgeSign(i.Dst, s.Org, i.Org) >= 0 : le.edgeSign(s.Dst, o, s.Org) <= 0;
    if (s.Dst === o)
      return le.edgeSign(i.Dst, o, i.Org) >= 0;
    var l = le.edgeEval(i.Dst, o, i.Org), c = le.edgeEval(s.Dst, o, s.Org);
    return l >= c;
  }, n.deleteRegion = function(r, e) {
    e.fixUpperEdge && ue(e.eUp.winding === 0), e.eUp.activeRegion = null, r.dict.delete(e.nodeUp);
  }, n.fixUpperEdge = function(r, e, t) {
    ue(e.fixUpperEdge), r.mesh.delete(e.eUp), e.fixUpperEdge = false, e.eUp = t, t.activeRegion = e;
  }, n.topLeftRegion = function(r, e) {
    var t = e.eUp.Org, o;
    do
      e = n.regionAbove(e);
    while (e.eUp.Org === t);
    if (e.fixUpperEdge) {
      if (o = r.mesh.connect(n.regionBelow(e).eUp.Sym, e.eUp.Lnext), o === null)
        return null;
      n.fixUpperEdge(r, e, o), e = n.regionAbove(e);
    }
    return e;
  }, n.topRightRegion = function(r) {
    var e = r.eUp.Dst;
    do
      r = n.regionAbove(r);
    while (r.eUp.Dst === e);
    return r;
  }, n.addRegionBelow = function(r, e, t) {
    var o = new td();
    return o.eUp = t, o.nodeUp = r.dict.insertBefore(e.nodeUp, o), o.fixUpperEdge = false, o.sentinel = false, o.dirty = false, t.activeRegion = o, o;
  }, n.isWindingInside = function(r, e) {
    switch (r.windingRule) {
      case be.ODD:
        return (e & 1) !== 0;
      case be.NONZERO:
        return e !== 0;
      case be.POSITIVE:
        return e > 0;
      case be.NEGATIVE:
        return e < 0;
      case be.ABS_GEQ_TWO:
        return e >= 2 || e <= -2;
    }
    throw new Error("Invalid winding rulle");
  }, n.computeWinding = function(r, e) {
    e.windingNumber = n.regionAbove(e).windingNumber + e.eUp.winding, e.inside = n.isWindingInside(r, e.windingNumber);
  }, n.finishRegion = function(r, e) {
    var t = e.eUp, o = t.Lface;
    o.inside = e.inside, o.anEdge = t, n.deleteRegion(r, e);
  }, n.finishLeftRegions = function(r, e, t) {
    for (var o, i = null, s = e, l = e.eUp; s !== t; ) {
      if (s.fixUpperEdge = false, i = n.regionBelow(s), o = i.eUp, o.Org != l.Org) {
        if (!i.fixUpperEdge) {
          n.finishRegion(r, s);
          break;
        }
        o = r.mesh.connect(l.Lprev, o.Sym), n.fixUpperEdge(r, i, o);
      }
      l.Onext !== o && (r.mesh.splice(o.Oprev, o), r.mesh.splice(l, o)), n.finishRegion(r, s), l = i.eUp, s = i;
    }
    return l;
  }, n.addRightEdges = function(r, e, t, o, i, s) {
    var l, c, u, a, d = true;
    u = t;
    do
      ue(le.vertLeq(u.Org, u.Dst)), n.addRegionBelow(r, e, u.Sym), u = u.Onext;
    while (u !== o);
    for (i === null && (i = n.regionBelow(e).eUp.Rprev), c = e, a = i; l = n.regionBelow(c), u = l.eUp.Sym, u.Org === a.Org; )
      u.Onext !== a && (r.mesh.splice(u.Oprev, u), r.mesh.splice(a.Oprev, u)), l.windingNumber = c.windingNumber - u.winding, l.inside = n.isWindingInside(r, l.windingNumber), c.dirty = true, !d && n.checkForRightSplice(r, c) && (n.addWinding(u, a), n.deleteRegion(r, c), r.mesh.delete(a)), d = false, c = l, a = u;
    c.dirty = true, ue(c.windingNumber - u.winding === l.windingNumber), s && n.walkDirtyRegions(r, c);
  }, n.spliceMergeVertices = function(r, e, t) {
    r.mesh.splice(e, t);
  }, n.vertexWeights = function(r, e, t) {
    var o = le.vertL1dist(e, r), i = le.vertL1dist(t, r), s = 0.5 * i / (o + i), l = 0.5 * o / (o + i);
    r.coords[0] += s * e.coords[0] + l * t.coords[0], r.coords[1] += s * e.coords[1] + l * t.coords[1], r.coords[2] += s * e.coords[2] + l * t.coords[2];
  }, n.getIntersectData = function(r, e, t, o, i, s) {
    e.coords[0] = e.coords[1] = e.coords[2] = 0, e.idx = -1, n.vertexWeights(e, t, o), n.vertexWeights(e, i, s);
  }, n.checkForRightSplice = function(r, e) {
    var t = n.regionBelow(e), o = e.eUp, i = t.eUp;
    if (le.vertLeq(o.Org, i.Org)) {
      if (le.edgeSign(i.Dst, o.Org, i.Org) > 0)
        return false;
      le.vertEq(o.Org, i.Org) ? o.Org !== i.Org && (r.pq.delete(o.Org.pqHandle), n.spliceMergeVertices(r, i.Oprev, o)) : (r.mesh.splitEdge(i.Sym), r.mesh.splice(o, i.Oprev), e.dirty = t.dirty = true);
    } else {
      if (le.edgeSign(o.Dst, i.Org, o.Org) < 0)
        return false;
      n.regionAbove(e).dirty = e.dirty = true, r.mesh.splitEdge(o.Sym), r.mesh.splice(i.Oprev, o);
    }
    return true;
  }, n.checkForLeftSplice = function(r, e) {
    var t = n.regionBelow(e), o = e.eUp, i = t.eUp, s;
    if (ue(!le.vertEq(o.Dst, i.Dst)), le.vertLeq(o.Dst, i.Dst)) {
      if (le.edgeSign(o.Dst, i.Dst, o.Org) < 0)
        return false;
      n.regionAbove(e).dirty = e.dirty = true, s = r.mesh.splitEdge(o), r.mesh.splice(i.Sym, s), s.Lface.inside = e.inside;
    } else {
      if (le.edgeSign(i.Dst, o.Dst, i.Org) > 0)
        return false;
      e.dirty = t.dirty = true, s = r.mesh.splitEdge(i), r.mesh.splice(o.Lnext, i.Sym), s.Rface.inside = e.inside;
    }
    return true;
  }, n.checkForIntersect = function(r, e) {
    var t = n.regionBelow(e), o = e.eUp, i = t.eUp, s = o.Org, l = i.Org, c = o.Dst, u = i.Dst, a, d, p = new Un(), f, m;
    if (ue(!le.vertEq(u, c)), ue(le.edgeSign(c, r.event, s) <= 0), ue(le.edgeSign(u, r.event, l) >= 0), ue(s !== r.event && l !== r.event), ue(!e.fixUpperEdge && !t.fixUpperEdge), s === l || (a = Math.min(s.t, c.t), d = Math.max(l.t, u.t), a > d))
      return false;
    if (le.vertLeq(s, l)) {
      if (le.edgeSign(u, s, l) > 0)
        return false;
    } else if (le.edgeSign(c, l, s) < 0)
      return false;
    return n.debugEvent(r), le.intersect(c, s, u, l, p), ue(Math.min(s.t, c.t) <= p.t), ue(p.t <= Math.max(l.t, u.t)), ue(Math.min(u.s, c.s) <= p.s), ue(p.s <= Math.max(l.s, s.s)), le.vertLeq(p, r.event) && (p.s = r.event.s, p.t = r.event.t), f = le.vertLeq(s, l) ? s : l, le.vertLeq(f, p) && (p.s = f.s, p.t = f.t), le.vertEq(p, s) || le.vertEq(p, l) ? (n.checkForRightSplice(r, e), false) : !le.vertEq(c, r.event) && le.edgeSign(c, r.event, p) >= 0 || !le.vertEq(u, r.event) && le.edgeSign(u, r.event, p) <= 0 ? u === r.event ? (r.mesh.splitEdge(o.Sym), r.mesh.splice(i.Sym, o), e = n.topLeftRegion(r, e), o = n.regionBelow(e).eUp, n.finishLeftRegions(r, n.regionBelow(e), t), n.addRightEdges(r, e, o.Oprev, o, o, true), true) : c === r.event ? (r.mesh.splitEdge(i.Sym), r.mesh.splice(o.Lnext, i.Oprev), t = e, e = n.topRightRegion(e), m = n.regionBelow(e).eUp.Rprev, t.eUp = i.Oprev, i = n.finishLeftRegions(r, t, null), n.addRightEdges(r, e, i.Onext, o.Rprev, m, true), true) : (le.edgeSign(c, r.event, p) >= 0 && (n.regionAbove(e).dirty = e.dirty = true, r.mesh.splitEdge(o.Sym), o.Org.s = r.event.s, o.Org.t = r.event.t), le.edgeSign(u, r.event, p) <= 0 && (e.dirty = t.dirty = true, r.mesh.splitEdge(i.Sym), i.Org.s = r.event.s, i.Org.t = r.event.t), false) : (r.mesh.splitEdge(o.Sym), r.mesh.splitEdge(i.Sym), r.mesh.splice(i.Oprev, o), o.Org.s = p.s, o.Org.t = p.t, o.Org.pqHandle = r.pq.insert(o.Org), n.getIntersectData(r, o.Org, s, c, l, u), n.regionAbove(e).dirty = e.dirty = t.dirty = true, false);
  }, n.walkDirtyRegions = function(r, e) {
    for (var t = n.regionBelow(e), o, i; ; ) {
      for (; t.dirty; )
        e = t, t = n.regionBelow(t);
      if (!e.dirty && (t = e, e = n.regionAbove(e), e === null || !e.dirty))
        return;
      if (e.dirty = false, o = e.eUp, i = t.eUp, o.Dst !== i.Dst && n.checkForLeftSplice(r, e) && (t.fixUpperEdge ? (n.deleteRegion(r, t), r.mesh.delete(i), t = n.regionBelow(e), i = t.eUp) : e.fixUpperEdge && (n.deleteRegion(r, e), r.mesh.delete(o), e = n.regionAbove(t), o = e.eUp)), o.Org !== i.Org)
        if (o.Dst !== i.Dst && !e.fixUpperEdge && !t.fixUpperEdge && (o.Dst === r.event || i.Dst === r.event)) {
          if (n.checkForIntersect(r, e))
            return;
        } else
          n.checkForRightSplice(r, e);
      o.Org === i.Org && o.Dst === i.Dst && (n.addWinding(i, o), n.deleteRegion(r, e), r.mesh.delete(o), e = n.regionAbove(t));
    }
  }, n.connectRightVertex = function(r, e, t) {
    var o, i = t.Onext, s = n.regionBelow(e), l = e.eUp, c = s.eUp, u = false;
    if (l.Dst !== c.Dst && n.checkForIntersect(r, e), le.vertEq(l.Org, r.event) && (r.mesh.splice(i.Oprev, l), e = n.topLeftRegion(r, e), i = n.regionBelow(e).eUp, n.finishLeftRegions(r, n.regionBelow(e), s), u = true), le.vertEq(c.Org, r.event) && (r.mesh.splice(t, c.Oprev), t = n.finishLeftRegions(r, s, null), u = true), u) {
      n.addRightEdges(r, e, t.Onext, i, i, true);
      return;
    }
    le.vertLeq(c.Org, l.Org) ? o = c.Oprev : o = l, o = r.mesh.connect(t.Lprev, o), n.addRightEdges(r, e, o, o.Onext, o.Onext, false), o.Sym.activeRegion.fixUpperEdge = true, n.walkDirtyRegions(r, e);
  }, n.connectLeftDegenerate = function(r, e, t) {
    var o, i, s, l, c;
    if (o = e.eUp, le.vertEq(o.Org, t)) {
      ue(false), n.spliceMergeVertices(r, o, t.anEdge);
      return;
    }
    if (!le.vertEq(o.Dst, t)) {
      r.mesh.splitEdge(o.Sym), e.fixUpperEdge && (r.mesh.delete(o.Onext), e.fixUpperEdge = false), r.mesh.splice(t.anEdge, o), n.sweepEvent(r, t);
      return;
    }
    ue(false), e = n.topRightRegion(e), c = n.regionBelow(e), s = c.eUp.Sym, i = l = s.Onext, c.fixUpperEdge && (ue(i !== s), n.deleteRegion(r, c), r.mesh.delete(s), s = i.Oprev), r.mesh.splice(t.anEdge, s), le.edgeGoesLeft(i) || (i = null), n.addRightEdges(r, e, s.Onext, l, i, true);
  }, n.connectLeftVertex = function(r, e) {
    var t, o, i, s, l, c, u = new td();
    if (u.eUp = e.anEdge.Sym, t = r.dict.search(u).key, o = n.regionBelow(t), !!o) {
      if (s = t.eUp, l = o.eUp, le.edgeSign(s.Dst, e, s.Org) === 0) {
        n.connectLeftDegenerate(r, t, e);
        return;
      }
      if (i = le.vertLeq(l.Dst, s.Dst) ? t : o, t.inside || i.fixUpperEdge) {
        if (i === t)
          c = r.mesh.connect(e.anEdge.Sym, s.Lnext);
        else {
          var a = r.mesh.connect(l.Dnext, e.anEdge);
          c = a.Sym;
        }
        i.fixUpperEdge ? n.fixUpperEdge(r, i, c) : n.computeWinding(r, n.addRegionBelow(r, t, c)), n.sweepEvent(r, e);
      } else
        n.addRightEdges(r, t, e.anEdge, e.anEdge, null, true);
    }
  }, n.sweepEvent = function(r, e) {
    r.event = e, n.debugEvent(r);
    for (var t = e.anEdge; t.activeRegion === null; )
      if (t = t.Onext, t === e.anEdge) {
        n.connectLeftVertex(r, e);
        return;
      }
    var o = n.topLeftRegion(r, t.activeRegion);
    ue(o !== null);
    var i = n.regionBelow(o), s = i.eUp, l = n.finishLeftRegions(r, i, null);
    l.Onext === s ? n.connectRightVertex(r, o, l) : n.addRightEdges(r, o, l.Onext, s, s, true);
  }, n.addSentinel = function(r, e, t, o) {
    var i = new td(), s = r.mesh.makeEdge();
    s.Org.s = t, s.Org.t = o, s.Dst.s = e, s.Dst.t = o, r.event = s.Dst, i.eUp = s, i.windingNumber = 0, i.inside = false, i.fixUpperEdge = false, i.sentinel = true, i.dirty = false, i.nodeUp = r.dict.insert(i);
  }, n.initEdgeDict = function(r) {
    r.dict = new yP(r, n.edgeLeq);
    var e = r.bmax[0] - r.bmin[0], t = r.bmax[1] - r.bmin[1], o = r.bmin[0] - e, i = r.bmax[0] + e, s = r.bmin[1] - t, l = r.bmax[1] + t;
    n.addSentinel(r, o, i, s), n.addSentinel(r, o, i, l);
  }, n.doneEdgeDict = function(r) {
    for (var e, t = 0; (e = r.dict.min().key) !== null; )
      e.sentinel || (ue(e.fixUpperEdge), ue(++t === 1)), ue(e.windingNumber === 0), n.deleteRegion(r, e);
  }, n.removeDegenerateEdges = function(r) {
    var e, t, o, i = r.mesh.eHead;
    for (e = i.next; e !== i; e = t)
      t = e.next, o = e.Lnext, le.vertEq(e.Org, e.Dst) && e.Lnext.Lnext !== e && (n.spliceMergeVertices(r, o, e), r.mesh.delete(e), e = o, o = e.Lnext), o.Lnext === e && (o !== e && ((o === t || o === t.Sym) && (t = t.next), r.mesh.delete(o)), (e === t || e === t.Sym) && (t = t.next), r.mesh.delete(e));
  }, n.initPriorityQ = function(r) {
    var e, t, o, i = 0;
    for (o = r.mesh.vHead, t = o.next; t !== o; t = t.next)
      i++;
    for (i += 8, e = r.pq = new hP(i, le.vertLeq), o = r.mesh.vHead, t = o.next; t !== o; t = t.next)
      t.pqHandle = e.insert(t);
    return t !== o ? false : (e.init(), true);
  }, n.donePriorityQ = function(r) {
    r.pq = null;
  }, n.removeDegenerateFaces = function(r, e) {
    var t, o, i;
    for (t = e.fHead.next; t !== e.fHead; t = o)
      o = t.next, i = t.anEdge, ue(i.Lnext !== i), i.Lnext.Lnext === i && (n.addWinding(i.Onext, i), r.mesh.delete(i));
    return true;
  }, n.computeInterior = function(r, e) {
    e === void 0 && (e = true);
    var t, o;
    if (n.removeDegenerateEdges(r), !n.initPriorityQ(r))
      return false;
    for (n.initEdgeDict(r); (t = r.pq.extractMin()) !== null; ) {
      for (; o = r.pq.min(), !(o === null || !le.vertEq(o, t)); )
        o = r.pq.extractMin(), n.spliceMergeVertices(r, t.anEdge, o.anEdge);
      n.sweepEvent(r, t);
    }
    return r.event = r.dict.min().key.eUp.Org, n.debugEvent(r), n.doneEdgeDict(r), n.donePriorityQ(r), n.removeDegenerateFaces(r, r.mesh) ? (e && r.mesh.check(), true) : false;
  }, n;
}();
var xP = function() {
  function n() {
    this.mesh = new Nh(), this.normal = [0, 0, 0], this.sUnit = [0, 0, 0], this.tUnit = [0, 0, 0], this.bmin = [0, 0], this.bmax = [0, 0], this.windingRule = be.ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0;
  }
  return n.prototype.dot_ = function(r, e) {
    return r[0] * e[0] + r[1] * e[1] + r[2] * e[2];
  }, n.prototype.normalize_ = function(r) {
    var e = r[0] * r[0] + r[1] * r[1] + r[2] * r[2];
    if (!e)
      throw "Zero-size vector!";
    e = Math.sqrt(e), r[0] /= e, r[1] /= e, r[2] /= e;
  }, n.prototype.longAxis_ = function(r) {
    var e = 0;
    return Math.abs(r[1]) > Math.abs(r[0]) && (e = 1), Math.abs(r[2]) > Math.abs(r[e]) && (e = 2), e;
  }, n.prototype.computeNormal_ = function(r) {
    var e, t, o, i, s, l, c = [0, 0, 0], u = [0, 0, 0], a = [0, 0, 0], d = [0, 0, 0], p = [0, 0, 0], f = [null, null, null], m = [null, null, null], h = this.mesh.vHead;
    e = h.next;
    for (var y = 0; y < 3; ++y)
      i = e.coords[y], u[y] = i, m[y] = e, c[y] = i, f[y] = e;
    for (e = h.next; e !== h; e = e.next)
      for (var g = 0; g < 3; ++g)
        i = e.coords[g], i < u[g] && (u[g] = i, m[g] = e), i > c[g] && (c[g] = i, f[g] = e);
    var v = 0;
    if (c[1] - u[1] > c[0] - u[0] && (v = 1), c[2] - u[2] > c[v] - u[v] && (v = 2), u[v] >= c[v]) {
      r[0] = 0, r[1] = 0, r[2] = 1;
      return;
    }
    for (l = 0, t = m[v], o = f[v], a[0] = t.coords[0] - o.coords[0], a[1] = t.coords[1] - o.coords[1], a[2] = t.coords[2] - o.coords[2], e = h.next; e !== h; e = e.next)
      d[0] = e.coords[0] - o.coords[0], d[1] = e.coords[1] - o.coords[1], d[2] = e.coords[2] - o.coords[2], p[0] = a[1] * d[2] - a[2] * d[1], p[1] = a[2] * d[0] - a[0] * d[2], p[2] = a[0] * d[1] - a[1] * d[0], s = p[0] * p[0] + p[1] * p[1] + p[2] * p[2], s > l && (l = s, r[0] = p[0], r[1] = p[1], r[2] = p[2]);
    l <= 0 && (r[0] = r[1] = r[2] = 0, r[this.longAxis_(a)] = 1);
  }, n.prototype.checkOrientation_ = function() {
    for (var r = this.mesh.fHead, e, t = this.mesh.vHead, o, i = 0, s = r.next; s !== r; s = s.next)
      if (o = s.anEdge, !(o.winding <= 0))
        do
          i += (o.Org.s - o.Dst.s) * (o.Org.t + o.Dst.t), o = o.Lnext;
        while (o !== s.anEdge);
    if (i < 0) {
      for (e = t.next; e !== t; e = e.next)
        e.t = -e.t;
      this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2];
    }
  }, n.prototype.projectPolygon_ = function() {
    var r = this.mesh.vHead, e = [0, 0, 0], t, o, i = false;
    e[0] = this.normal[0], e[1] = this.normal[1], e[2] = this.normal[2], !e[0] && !e[1] && !e[2] && (this.computeNormal_(e), i = true), t = this.sUnit, o = this.tUnit;
    var s = this.longAxis_(e);
    t[s] = 0, t[(s + 1) % 3] = 1, t[(s + 2) % 3] = 0, o[s] = 0, o[(s + 1) % 3] = 0, o[(s + 2) % 3] = e[s] > 0 ? 1 : -1;
    for (var l = r.next; l !== r; l = l.next)
      l.s = this.dot_(l.coords, t), l.t = this.dot_(l.coords, o);
    i && this.checkOrientation_();
    for (var c = true, u = r.next; u !== r; u = u.next)
      c ? (this.bmin[0] = this.bmax[0] = u.s, this.bmin[1] = this.bmax[1] = u.t, c = false) : (u.s < this.bmin[0] && (this.bmin[0] = u.s), u.s > this.bmax[0] && (this.bmax[0] = u.s), u.t < this.bmin[1] && (this.bmin[1] = u.t), u.t > this.bmax[1] && (this.bmax[1] = u.t));
  }, n.prototype.addWinding_ = function(r, e) {
    r.winding += e.winding, r.Sym.winding += e.Sym.winding;
  }, n.prototype.tessellateMonoRegion_ = function(r, e) {
    var t, o;
    if (t = e.anEdge, !(t.Lnext !== t && t.Lnext.Lnext !== t))
      throw "Mono region invalid";
    for (; le.vertLeq(t.Dst, t.Org); t = t.Lprev)
      ;
    for (; le.vertLeq(t.Org, t.Dst); t = t.Lnext)
      ;
    o = t.Lprev;
    for (var i = void 0; t.Lnext !== o; )
      if (le.vertLeq(t.Dst, o.Org)) {
        for (; o.Lnext !== t && (le.edgeGoesLeft(o.Lnext) || le.edgeSign(o.Org, o.Dst, o.Lnext.Dst) <= 0); )
          i = r.connect(o.Lnext, o), o = i.Sym;
        o = o.Lprev;
      } else {
        for (; o.Lnext !== t && (le.edgeGoesRight(t.Lprev) || le.edgeSign(t.Dst, t.Org, t.Lprev.Org) >= 0); )
          i = r.connect(t, t.Lprev), t = i.Sym;
        t = t.Lnext;
      }
    if (o.Lnext === t)
      throw "Mono region invalid";
    for (; o.Lnext.Lnext !== t; )
      i = r.connect(o.Lnext, o), o = i.Sym;
    return true;
  }, n.prototype.tessellateInterior_ = function(r) {
    for (var e, t = r.fHead.next; t !== r.fHead; t = e)
      if (e = t.next, t.inside && !this.tessellateMonoRegion_(r, t))
        return false;
    return true;
  }, n.prototype.discardExterior_ = function(r) {
    for (var e, t = r.fHead.next; t !== r.fHead; t = e)
      e = t.next, t.inside || r.zapFace(t);
  }, n.prototype.setWindingNumber_ = function(r, e, t) {
    for (var o, i = r.eHead.next; i !== r.eHead; i = o)
      o = i.next, i.Rface.inside !== i.Lface.inside ? i.winding = i.Lface.inside ? e : -e : t ? r.delete(i) : i.winding = 0;
  }, n.prototype.getNeighbourFace_ = function(r) {
    return !r.Rface || !r.Rface.inside ? -1 : r.Rface.n;
  }, n.prototype.outputPolymesh_ = function(r, e, t, o) {
    var i, s = 0, l = 0, c;
    t > 3 && r.mergeConvexFaces(t);
    for (var u = r.vHead.next; u !== r.vHead; u = u.next)
      u.n = -1;
    for (var a = r.fHead.next; a !== r.fHead; a = a.next)
      if (a.n = -1, !!a.inside) {
        i = a.anEdge, c = 0;
        do {
          var u = i.Org;
          u.n === -1 && (u.n = l, l++), c++, i = i.Lnext;
        } while (i !== a.anEdge);
        if (c > t)
          throw "Face vertex greater that support polygon";
        a.n = s, ++s;
      }
    this.elementCount = s, e === Ge.CONNECTED_POLYGONS && (s *= 2), this.elements = [], this.elements.length = s * t, this.vertexCount = l, this.vertices = [], this.vertices.length = l * o, this.vertexIndices = [], this.vertexIndices.length = l;
    for (var u = r.vHead.next; u !== r.vHead; u = u.next)
      if (u.n !== -1) {
        var d = u.n * o;
        this.vertices[d + 0] = u.coords[0], this.vertices[d + 1] = u.coords[1], o > 2 && (this.vertices[d + 2] = u.coords[2]), this.vertexIndices[u.n] = u.idx;
      }
    for (var p = 0, a = r.fHead.next; a !== r.fHead; a = a.next)
      if (!!a.inside) {
        i = a.anEdge, c = 0;
        do {
          var u = i.Org;
          this.elements[p++] = u.n, c++, i = i.Lnext;
        } while (i !== a.anEdge);
        for (var f = c; f < t; ++f)
          this.elements[p++] = -1;
        if (e === Ge.CONNECTED_POLYGONS) {
          i = a.anEdge;
          do
            this.elements[p++] = this.getNeighbourFace_(i), i = i.Lnext;
          while (i !== a.anEdge);
          for (var m = c; m < t; ++m)
            this.elements[p++] = -1;
        }
      }
  }, n.prototype.outputContours_ = function(r, e) {
    var t, o, i = 0, s = 0;
    this.vertexCount = 0, this.elementCount = 0;
    for (var l = r.fHead.next; l !== r.fHead; l = l.next)
      if (!!l.inside) {
        o = t = l.anEdge;
        do
          this.vertexCount++, t = t.Lnext;
        while (t !== o);
        this.elementCount++;
      }
    this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * e, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
    var c = 0, u = 0, a = 0;
    i = 0;
    for (var l = r.fHead.next; l !== r.fHead; l = l.next)
      if (!!l.inside) {
        s = 0, o = t = l.anEdge;
        do
          this.vertices[c++] = t.Org.coords[0], this.vertices[c++] = t.Org.coords[1], e > 2 && (this.vertices[c++] = t.Org.coords[2]), this.vertexIndices[u++] = this.vertexIdCallback ? this.vertexIdCallback(t) : t.Org.idx, s++, t = t.Lnext;
        while (t !== o);
        this.elements[a++] = i, this.elements[a++] = s, i += s;
      }
  }, n.prototype.addContour = function(r, e) {
    this.mesh === null && (this.mesh = new Nh()), r < 2 && (r = 2), r > 3 && (r = 3);
    for (var t = null, o = 0; o < e.length; o += r)
      t === null ? (t = this.mesh.makeEdge(), this.mesh.splice(t, t.Sym)) : (this.mesh.splitEdge(t), t = t.Lnext), t.Org.coords[0] = e[o + 0], t.Org.coords[1] = e[o + 1], r > 2 ? t.Org.coords[2] = e[o + 2] : t.Org.coords[2] = 0, t.Org.idx = this.vertexIndexCounter++, this.edgeCreateCallback && this.edgeCreateCallback(t), t.winding = 1, t.Sym.winding = -1;
  }, n.prototype.tesselate = function(r, e, t, o, i, s) {
    if (r === void 0 && (r = be.ODD), e === void 0 && (e = Ge.POLYGONS), s === void 0 && (s = true), this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, i && (this.normal[0] = i[0], this.normal[1] = i[1], this.normal[2] = i[2]), this.windingRule = r, o < 2 && (o = 2), o > 3 && (o = 3), !this.mesh)
      return false;
    this.projectPolygon_(), gP.computeInterior(this, s);
    var l = this.mesh;
    return e === Ge.BOUNDARY_CONTOURS ? this.setWindingNumber_(l, 1, true) : this.tessellateInterior_(l), s && l.check(), e === Ge.BOUNDARY_CONTOURS ? this.outputContours_(l, o) : this.outputPolymesh_(l, e, t, o), true;
  }, n;
}();
function ir(n) {
  var r = n.windingRule, e = r === void 0 ? be.ODD : r, t = n.elementType, o = t === void 0 ? Ge.POLYGONS : t, i = n.polySize, s = i === void 0 ? 3 : i, l = n.vertexSize, c = l === void 0 ? 2 : l, u = n.normal, a = u === void 0 ? [0, 0, 1] : u, d = n.contours, p = d === void 0 ? [] : d, f = n.strict, m = f === void 0 ? true : f, h = n.debug, y = h === void 0 ? false : h;
  if (!p && m)
    throw new Error("Contours can't be empty");
  if (!!p) {
    var g = new xP();
    n.edgeCreateCallback && (g.edgeCreateCallback = n.edgeCreateCallback), n.vertexIdCallback && (g.vertexIdCallback = n.vertexIdCallback);
    for (var v = 0; v < p.length; v++)
      g.addContour(c || 2, p[v]);
    return g.tesselate(e, o, s, c, a, m), { vertices: g.vertices, vertexIndices: g.vertexIndices, vertexCount: g.vertexCount, elements: g.elements, elementCount: g.elementCount, mesh: y ? g.mesh : void 0 };
  }
}
var bz = be.ODD;
var Sz = be.NONZERO;
var wz = be.POSITIVE;
var _z = be.NEGATIVE;
var Pz = be.ABS_GEQ_TWO;
var Tz = Ge.POLYGONS;
var Oz = Ge.CONNECTED_POLYGONS;
var Az = Ge.BOUNDARY_CONTOURS;
var al = class {
  constructor(r = 256, e = false) {
    this.capacity = r, this.size = 0, this.debug = e, this.debug && console.log(`allocating with cap ${r}`);
    let t = r * al.eSize;
    this.buffer = new ArrayBuffer(t);
    let o = Float32Array.BYTES_PER_ELEMENT, i = 0;
    this.positions = new Float32Array(this.buffer, i * o, 3 * r), i += 3 * r, this.normals = new Float32Array(this.buffer, i * o, 3 * r), i += 3 * r, this.uvs = new Float32Array(this.buffer, i * o, 2 * r);
  }
  realloc(r, e = false) {
    if (r < this.size)
      throw Error("cannot shrink buffer");
    if (r <= this.capacity && !e)
      return;
    this.debug && console.log(`resizing from ${this.capacity}  ${r}`);
    let t = r * al.eSize, o = new ArrayBuffer(t), i = Float32Array.BYTES_PER_ELEMENT, s = 0, l = new Float32Array(o, s * i, 3 * r);
    s += 3 * r;
    let c = new Float32Array(o, s * i, 3 * r);
    s += 3 * r;
    let u = new Float32Array(o, s * i, 2 * r);
    l.set(this.positions.slice(0, this.size * 3)), c.set(this.normals.slice(0, this.size * 3)), u.set(this.uvs.slice(0, this.size * 2)), this.buffer = o, this.positions = l, this.normals = c, this.uvs = u, this.capacity = r;
  }
  get(r = 1) {
    let e = this.size + r;
    if (e > this.capacity) {
      let o = this.capacity;
      for (; e > o; )
        o *= 2;
      this.realloc(o);
    }
    let t = this.size;
    return this.size = e, t;
  }
  reserve(r) {
    let e = this.size + r;
    e > this.capacity && this.realloc(e);
  }
  shrink() {
    this.debug && console.log(`shrinking ${this.capacity}  ${this.size}`), this.realloc(this.size, true);
  }
};
var us = al;
us.eSize = (3 + 3 + 2) * Float32Array.BYTES_PER_ELEMENT;
var ps = { vertices: [160, 160, -160, 160, -160, -160, 160, -160], vertexIndices: [1, 0, 3, 2], vertexCount: 4, elements: [0, 4], elementCount: 1, mesh: void 0 };
var od = { vertices: [], vertexIndices: [], vertexCount: 0, elements: [], elementCount: 0, mesh: void 0 };
var nd = { vertices: [-160, 160, 160, -160, 160, 160, -160, -160], vertexIndices: [1, 3, 0, 2], vertexCount: 4, elements: [0, 1, 2, 1, 0, 3], elementCount: 2, mesh: void 0 };
var rd = (n, r) => ([e, t]) => (t < e && (t += r), (n >= e ? n : n + r) <= t);
var Hn = class extends BufferGeometry {
  constructor(e, t, o = 0, i = 12, s = 3, l = be.ODD) {
    super();
    this.type = "ShapeGeometry";
    this.vertexCache = {};
    this._shape = e, this._depth = t, this._bevel = o, this._curveSegments = i, this._bevelSegmentsInput = s, o <= 0 ? (this._bevelSize = 0, this._bevelSegments = 0) : (this._bevelSize = Math.min(o, t / 2 - 1e-12), this._bevelSegments = Math.floor(s));
    let c = this._shape.extractShapePointsToFlatArray([], i), u = this._shape.shapeHoles.map((_) => {
      let x = _.extractShapePointsToFlatArray([], i), C = [];
      for (let T = x.length - 1; T >= 1; T -= 2) {
        let N = x[T - 1], O = x[T - 0];
        C.push(N, O);
      }
      return C;
    }), a;
    try {
      a = ir({ windingRule: l, elementType: Ge.BOUNDARY_CONTOURS, vertexSize: 2, strict: true, contours: [c] });
    } catch {
      a = ps;
    }
    let d;
    try {
      d = ir({ windingRule: be.ODD, elementType: Ge.BOUNDARY_CONTOURS, vertexSize: 2, strict: true, contours: [...u] });
    } catch {
      d = od;
    }
    if (!a)
      throw new Error("error generating geometry");
    let p = a.elementCount;
    if (d) {
      a.elementCount += d.elementCount;
      for (let _ = 0; _ < d.elements.length; _++) {
        let x = d.elements[_], C = _ % 2 === 0 ? a.vertexCount : 0;
        a.elements.push(x + C);
      }
      for (let _ = 0; _ < d.vertexIndices.length; _++) {
        let x = d.vertexIndices[_], C = a.vertexCount;
        a.vertexIndices.push(x + C);
      }
      for (let _ = 0; _ < d.vertices.length; _++) {
        let x = d.vertices[_];
        a.vertices.push(x);
      }
    }
    let f = 1 / 0, m = -1 / 0, h = 1 / 0, y = -1 / 0;
    for (let _ = 0, x = a.vertexCount; _ < x; _++) {
      let C = _ * 2, T = a.vertices[C + 0], N = a.vertices[C + 1];
      T < f && (f = T), T > m && (m = T), N < h && (h = N), N > y && (y = N);
    }
    this._minX = f, this._minY = h, this._width = m - f, this._height = y - h, this._buffer = new us(this._computeBufferEstimatedSize(a));
    let g = [], v = [];
    for (let _ = a.elementCount - 1; _ >= 0; _--) {
      let x = _ >= p, C = _ * 2, T = a.elements[C + 0], N = a.elements[C + 1], O = T + N, A = { start: T, count: N, normals: [], continuous: [], concave: [] }, R = T, k = O - 1, $ = T + 1, te = this._shape.roundedCurves.length;
      do {
        let V = R - T, G = a.vertices[k * 2 + 0], B = a.vertices[k * 2 + 1], L = a.vertices[R * 2 + 0], D = a.vertices[R * 2 + 1], X = a.vertices[$ * 2 + 0], q = a.vertices[$ * 2 + 1], j = L - G, F = D - B, M = Math.sqrt(j * j + F * F);
        j /= M, F /= M;
        let Q = L - X, re = D - q, oe = Math.sqrt(Q * Q + re * re);
        Q /= oe, re /= oe, A.normals[V * 2 + 0] = -re, A.normals[V * 2 + 1] = Q, A.concave[V] = j * re - F * Q > 0;
        let K = a.vertexIndices[R];
        if (Array.isArray(K))
          A.continuous[V] = false;
        else {
          let [ee, J] = this._shape.getCurveIndexFromVertexId(K - 1, true);
          if (J > 0 && J < 1)
            A.continuous[V] = true;
          else {
            let ie = J === 1 ? ee + 1 : ee - 1;
            ie = (ie + te) % te;
            let ce = J === 1 ? 0 : 1, se = this._shape.roundedCurves[ee].getTangent(J), fe = this._shape.roundedCurves[ie].getTangent(ce);
            A.continuous[V] = se.dot(fe) > 0.95;
          }
        }
        x && (A.normals[V * 2 + 0] *= -1, A.normals[V * 2 + 1] *= -1), [k, R, $] = [R, $, $ + 1], $ >= O && ($ -= N);
      } while ($ !== T + 1);
      let Y = [];
      Y.push({ bevelI: 0, angle: 0, size: 0, boundary: { vertices: a.vertices.slice(T * 2, O * 2), vertexCount: N, vertexIndices: new Array(N).fill(true).map((V, G) => [G, G]), elements: [0, N], elementCount: 1, mesh: null }, reverseMap: [], insetPoints: a.vertices.slice(T * 2, O * 2) });
      for (let V = 1; V <= this._bevelSegments; V++) {
        let G = V / this._bevelSegments * Math.PI / 2, B = (1 - Math.cos(G)) * this._bevelSize, L = [], D = [], X = [], q = [], j = 0;
        for (let M = 0; M < N; M++) {
          let Q = M * 2, re = (M - 1 + N) % N * 2, oe = a.vertices[A.start * 2 + Q + 0], K = a.vertices[A.start * 2 + Q + 1], ee = -A.normals[re + 0] * B, J = -A.normals[re + 1] * B, ie = -A.normals[Q + 0] * B, ce = -A.normals[Q + 1] * B;
          if (A.concave[M] || !A.concave[M] && x) {
            let se = Math.atan2(J, ee), fe = Math.atan2(ce, ie);
            fe > se && (fe -= Math.PI * 2);
            let Re = fe - se;
            if (A.continuous[M] || x) {
              let ge = se + Re / 2, qe = Math.cos(ge) * B, Te = Math.sin(ge) * B;
              L[2 * j + 0] = oe + qe * (x ? -1 : 1), L[2 * j + 1] = K + Te * (x ? -1 : 1), q[j] = M, j++;
            } else {
              let ge = Math.max(1, Math.floor(i / 4 * Math.abs(Re) / Math.PI));
              for (let qe = 0; qe <= ge; qe++) {
                let Te = se + Re * (qe / ge), wt = Math.cos(Te) * B, Ft = Math.sin(Te) * B;
                L[2 * j + 0] = oe + wt, L[2 * j + 1] = K + Ft, q[j] = M, j++;
              }
            }
          } else
            L[2 * j + 0] = oe + ee, L[2 * j + 1] = K + J, q[j] = M, D[M] = j, j++, L[2 * j + 0] = oe, L[2 * j + 1] = K, q[j] = M, j++, L[2 * j + 0] = oe + ie, L[2 * j + 1] = K + ce, q[j] = M, X[M] = j, j++;
        }
        let F = ir({ windingRule: be.POSITIVE, elementType: Ge.BOUNDARY_CONTOURS, vertexSize: 2, strict: true, contours: [L], edgeCreateCallback: (M) => {
          let re = M.Org.idx, oe = q[re], K = q[(re + 1) % q.length];
          M.idx = [oe, K], M.Sym.idx = [K, oe];
        }, vertexIdCallback: (M) => {
          let Q = M.Lprev.idx;
          return [Q ? Q[1] : 0, M.idx ? M.idx[0] : 0];
        } });
        if (!F)
          throw console.log("Error"), new Error(`error generating bevel geometry for ${V}'th loop`);
        if (!F.vertexCount)
          break;
        for (let M = 0; M < F.vertexIndices.length; M++) {
          let [Q, re] = F.vertexIndices[M];
          if (Q === re)
            continue;
          let oe = re;
          re < Q && (oe += N);
          for (let K = Q; K < oe; K++) {
            let ee = K % N, J = (K + 1) % N;
            if (!A.continuous[ee] || !A.continuous[J]) {
              F.vertexIndices[M] = [Q, ee], F.vertexIndices.splice(M + 1, 0, [J, re]), F.vertices.splice((M + 1) * 2, 0, F.vertices[M * 2], F.vertices[M * 2 + 1]);
              break;
            }
          }
        }
        Y.push({ bevelI: V, angle: G, size: B, boundary: F, reverseMap: q, insetPoints: L });
      }
      let W = (V, G, B) => {
        let L = 0, D = V.boundary.vertexIndices.length;
        for (; L < D && B(V.boundary.vertexIndices[G]); )
          G = (G + 1) % D, L++;
        return L;
      }, H = g.length;
      for (let V = 1; V < Y.length; V++) {
        let G = Y[V - 1], B = Y[V], L = G.boundary.vertexIndices.length, D = B.boundary.vertexIndices.length;
        if (!L || !D)
          break;
        let X = A.concave.length, q = 0, j = rd(q, N);
        for (; !G.boundary.vertexIndices.filter(j).length || !B.boundary.vertexIndices.filter(j).length; )
          q++, j = rd(q, N);
        let F = G.boundary.vertexIndices.findIndex(j), M = B.boundary.vertexIndices.findIndex(j);
        do
          F = (F + 1) % L;
        while (j(G.boundary.vertexIndices[F]));
        do
          M = (M + 1) % D;
        while (j(B.boundary.vertexIndices[M]));
        q = (q + 1) % N;
        let Q = q, re = this._buildBevelVert(A, G, (F - 1 + L) % L), oe = this._buildBevelVert(A, B, (M - 1 + D) % D), K = re, ee = oe, J, ie, ce = false;
        do {
          j = rd(q, N);
          let se = W(G, F, j), fe = W(B, M, j), Re = ce;
          if (ce = false, se && !fe) {
            for (let ge = 0; ge < se; ge++)
              J = this._buildBevelVert(A, G, (F + ge) % L, ge / (se - 1)), g.push(K.topN, J.topP, ee.topN), g.push(J.bottomP, K.bottomN, ee.bottomN), K = J;
            ce = true;
          } else if (!se && fe)
            for (let ge = 0; ge < fe; ge++)
              ie = this._buildBevelVert(A, B, (M + ge) % D, ge / (fe - 1)), g.push(ee.topN, K.topP, ie.topP), g.push(K.bottomP, ee.bottomN, ie.bottomP), ee = ie;
          else if (se && fe)
            if (J = this._buildBevelVert(A, G, F, 0), ie = this._buildBevelVert(A, B, M, 0), Re ? (g.push(K.topN, ie.topP, ee.topN), g.push(K.topN, J.topP, ie.topP), g.push(ie.bottomP, K.bottomN, ee.bottomN), g.push(ie.bottomP, J.bottomP, K.bottomN)) : (g.push(ee.topN, K.topN, J.topP), g.push(ee.topN, J.topP, ie.topP), g.push(J.bottomP, K.bottomN, ee.bottomN), g.push(J.bottomP, ee.bottomN, ie.bottomP)), K = J, ee = ie, se === fe)
              for (let ge = 1; ge < se; ge++)
                J = this._buildBevelVert(A, G, (F + ge) % L, ge / (se - 1)), ie = this._buildBevelVert(A, B, (M + ge) % D, ge / (fe - 1)), g.push(K.topN, J.topP, ee.topN), g.push(ee.topN, J.topP, ie.topP), g.push(J.bottomP, K.bottomN, ee.bottomN), g.push(J.bottomP, ee.bottomN, ie.bottomP), K = J, ee = ie;
            else if (se > fe) {
              let ge = se / fe, qe = 0;
              for (let Te = 1; Te < se; Te++)
                J = this._buildBevelVert(A, G, (F + Te) % L, Te / (se - 1)), g.push(K.topN, J.topP, ee.topN), g.push(J.bottomP, K.bottomN, ee.bottomN), K = J, Te > (qe + 1) * ge && (qe++, ie = this._buildBevelVert(A, B, (M + qe) % D, qe / (fe - 1)), g.push(ee.topN, J.topP, ie.topP), g.push(J.bottomP, ee.bottomN, ie.bottomP), ee = ie);
            } else {
              let ge = fe / se, qe = 0;
              for (let Te = 1; Te < fe; Te++)
                ie = this._buildBevelVert(A, B, (M + Te) % D, Te / (fe - 1)), g.push(ee.topN, J.topP, ie.topP), g.push(J.bottomP, ee.bottomN, ie.bottomP), ee = ie, Te > (qe + 1) * ge && (qe++, J = this._buildBevelVert(A, G, (F + qe) % L, qe / (se - 1)), g.push(K.topN, J.topP, ee.topN), g.push(J.bottomP, K.bottomN, ee.bottomN), K = J);
            }
          F = (F + se) % L, M = (M + fe) % D, q = (q + 1) % X;
        } while (q !== Q);
      }
      if (this._buildWall(Y, A, g), x) {
        let V = [];
        for (let G = g.length - 1; G >= H + 2; G -= 3) {
          let B = g[G - 2], L = g[G - 1], D = g[G - 0];
          V.push(D, L, B);
        }
        g.splice(H, g.length - H, ...V);
      }
      if (x) {
        let V = [];
        for (let G = Y[Y.length - 1].boundary.vertices.length - 1; G >= 1; G -= 2) {
          let B = Y[Y.length - 1].boundary.vertices[G - 1], L = Y[Y.length - 1].boundary.vertices[G - 0];
          V.push(B, L);
        }
        v.push(V);
      }
      if (!x) {
        let V = Y[Y.length - 1], G;
        try {
          G = ir({ windingRule: Y.length > 1 ? be.POSITIVE : be.ODD, elementType: Ge.POLYGONS, vertexSize: 2, strict: true, contours: [V.insetPoints, ...v] });
        } catch {
          G = nd;
        }
        if (!G)
          throw new Error("Error generating geometry for surface");
        u.length === 0 && Object.assign(this, { capStartIndex: g.length });
        for (let B = 0; B < G.elementCount * 3; B += 3) {
          let L = this._buildSurfaceVert(G, G.elements[B + 0]), D = this._buildSurfaceVert(G, G.elements[B + 1]), X = this._buildSurfaceVert(G, G.elements[B + 2]);
          g.push(L.top, D.top, X.top), g.push(X.bottom, D.bottom, L.bottom);
        }
      }
      this.vertexCache = {};
    }
    this._buffer.shrink();
    let b = new BufferAttribute(Uint32Array.from(g), 1), w = new BufferAttribute(this._buffer.positions, 3), S = new BufferAttribute(this._buffer.normals, 3), P = new BufferAttribute(this._buffer.uvs, 2);
    w.needsUpdate = true, S.needsUpdate = true, P.needsUpdate = true, b.needsUpdate = true, this.setAttribute("position", w), this.setAttribute("normal", S), this.setAttribute("uv", P), this.setIndex(b);
  }
  _computeBufferEstimatedSize(e) {
    return e.vertexCount * 2 * (2 + this._bevelSegments);
  }
  _buildWall(e, t, o) {
    let i = e[0];
    for (let s = 0, l = i.boundary.vertexCount; s < l; s++) {
      let c = this._buildBevelVert(t, i, s), u = this._buildBevelVert(t, i, (s + 1) % l);
      o.push(u.topP, c.topN, c.bottomN), o.push(u.topP, c.bottomN, u.bottomP);
    }
  }
  _buildSurfaceVert(e, t) {
    let o = t.toString();
    if (o in this.vertexCache)
      return this.vertexCache[o];
    let i = e.vertices[t * 2 + 0], s = e.vertices[t * 2 + 1], l = (i - this._minX) / this._width, c = (s - this._minY) / this._height, u = this._buffer.get(2), a = u * 3, d = u * 2, p = { top: u + 0, bottom: u + 1 };
    return this._buffer.positions[a + 0] = i, this._buffer.positions[a + 1] = s, this._buffer.positions[a + 2] = this._depth, this._buffer.normals[a + 0] = 0, this._buffer.normals[a + 1] = 0, this._buffer.normals[a + 2] = 1, this._buffer.uvs[d + 0] = l, this._buffer.uvs[d + 1] = c, this._buffer.positions[a + 3] = i, this._buffer.positions[a + 4] = s, this._buffer.positions[a + 5] = 0, this._buffer.normals[a + 3] = 0, this._buffer.normals[a + 4] = 0, this._buffer.normals[a + 5] = -1, this._buffer.uvs[d + 2] = l, this._buffer.uvs[d + 3] = c, this.vertexCache[o] = p, p;
  }
  _buildBevelVert(e, t, o, i = 1) {
    let s = `${t.bevelI}:${o}`;
    if (s in this.vertexCache)
      return this.vertexCache[s];
    let [l, c] = t.boundary.vertexIndices[o], u, a, d, p;
    l !== c ? (a = l, u = c, p = false, d = e.continuous[a] && e.continuous[u]) : (u = l, a = (u - 1 + e.count) % e.count, p = e.concave[u] && t.bevelI > 0, d = e.continuous[u] || p);
    let f = Math.cos(t.angle), m = Math.sin(t.angle), h = o * 2, y = u * 2, g = a * 2, v = t.boundary.vertices[h + 0], b = t.boundary.vertices[h + 1], w = (1 - m) * this._bevelSize, S = (v - this._minX) / this._width, P = (b - this._minY) / this._height, _ = e.normals[y + 0], x = e.normals[y + 1], C = e.normals[g + 0], T = e.normals[g + 1];
    if (p) {
      let k = C - _, $ = T - x;
      _ = _ + k * (1 - i), x = x + $ * (1 - i);
      let te = Math.sqrt(_ * _ + x * x);
      _ /= te, x /= te;
    }
    let N = this._buffer.get(d ? 2 : 4), O = N * 3, A = N * 2, R = { i: o, fi: u, topP: N + 0, topN: N + 0, bottomP: N + 1, bottomN: N + 1 };
    return this._buffer.positions[O + 0] = v, this._buffer.positions[O + 1] = b, this._buffer.positions[O + 2] = this._depth - w, this._buffer.normals[O + 0] = _ * f, this._buffer.normals[O + 1] = x * f, this._buffer.normals[O + 2] = m, this._buffer.uvs[A + 0] = S, this._buffer.uvs[A + 1] = P, this._buffer.positions[O + 3] = v, this._buffer.positions[O + 4] = b, this._buffer.positions[O + 5] = w, this._buffer.normals[O + 3] = _ * f, this._buffer.normals[O + 4] = x * f, this._buffer.normals[O + 5] = -m, this._buffer.uvs[A + 2] = P, this._buffer.uvs[A + 3] = S, d || (N += 2, O += 6, A += 4, R.topP = N + 0, R.bottomP = N + 1, this._buffer.positions[O + 0] = v, this._buffer.positions[O + 1] = b, this._buffer.positions[O + 2] = this._depth - w, this._buffer.normals[O + 0] = C * f, this._buffer.normals[O + 1] = T * f, this._buffer.normals[O + 2] = m, this._buffer.uvs[A + 0] = S, this._buffer.uvs[A + 1] = P, this._buffer.positions[O + 3] = v, this._buffer.positions[O + 4] = b, this._buffer.positions[O + 5] = w, this._buffer.normals[O + 3] = C * f, this._buffer.normals[O + 4] = T * f, this._buffer.normals[O + 5] = -m, this._buffer.uvs[A + 2] = P, this._buffer.uvs[A + 3] = S), this.vertexCache[s] = R, R;
  }
  clone() {
    let e = new Hn(this._shape, this._depth, this._bevel, this._curveSegments, this._bevelSegmentsInput);
    return e.userData = Ur(this.userData), e;
  }
};
var qn = class extends BufferGeometry {
  constructor(e, t = 12, o = {}) {
    super();
    this.type = "ShapeGeometry";
    this.windingRule = be.ODD;
    this.elementType = Ge.POLYGONS;
    this.polySize = 3;
    this.vertexSize = 2;
    this.strict = true;
    this._shape = e, this._curveSegments = t, this._triangulationOptions = Object.assign({ windingRule: be.ODD, elementType: Ge.POLYGONS, polySize: 3, vertexSize: 2, strict: true }, o);
    let i = this._shape.extractShapePointsToFlatArray([], this._curveSegments), s = this._shape.shapeHoles.map((m) => m.extractShapePointsToFlatArray([], this._curveSegments)), l, c = true, u = true, a, d;
    for (let m = 0, h = i.length / 2; m < h; m++) {
      let y = m * 2, g = i[y + 0], v = i[y + 1];
      if (a !== void 0 && g !== a && (c = false), d !== void 0 && v !== d && (u = false), a = g, d = v, !c && !u)
        break;
    }
    if (!c && !u)
      try {
        l = ir({ contours: [i, ...s], windingRule: this._triangulationOptions.windingRule, elementType: this._triangulationOptions.elementType, polySize: this._triangulationOptions.polySize, vertexSize: this._triangulationOptions.vertexSize, strict: this._triangulationOptions.strict });
      } catch {
        l = ps;
      }
    let p = (l == null ? void 0 : l.vertexCount) ?? 1, f = (l == null ? void 0 : l.elementCount) ?? 1;
    if (this._positionAttribute = new BufferAttribute(new Float32Array(p * 3), 3), this._normalAttribute = new BufferAttribute(new Float32Array(p * 3), 3), this._uvAttribute = new BufferAttribute(new Float32Array(p * 2), 2), this._indexAttribute = new BufferAttribute(new Uint32Array(f * 3), 1), l) {
      let m = 1 / 0, h = -1 / 0, y = 1 / 0, g = -1 / 0;
      for (let w = 0, S = p; w < S; w++) {
        let P = w * 2, _ = l.vertices[P + 0], x = l.vertices[P + 1];
        _ < m && (m = _), _ > h && (h = _), x < y && (y = x), x > g && (g = x);
      }
      let v = h - m, b = g - y;
      for (let w = 0, S = p; w < S; w++) {
        let P = w * 2, _ = l.vertices[P + 0], x = l.vertices[P + 1], C = (_ - m) / v, T = (x - y) / b;
        this._positionAttribute.setXYZ(w, _, x, 0), this._normalAttribute.setXYZ(w, 0, 0, 1), this._uvAttribute.setXY(w, C, T);
      }
      for (let w = 0, S = f; w < S; w++) {
        let P = w * 3, _ = l.elements[P + 0], x = l.elements[P + 1], C = l.elements[P + 2];
        this._indexAttribute.setX(P + 0, _), this._indexAttribute.setX(P + 1, x), this._indexAttribute.setX(P + 2, C);
      }
    }
    this.setAttribute("position", this._positionAttribute), this.setAttribute("normal", this._normalAttribute), this.setAttribute("uv", this._uvAttribute), this.setIndex(this._indexAttribute), this.setDrawRange(0, ((l == null ? void 0 : l.elementCount) ?? 1) * 3);
  }
  clone() {
    let e = new qn(this._shape, this._curveSegments);
    return e.userData = Ur(this.userData), e;
  }
};
var Wn = class extends Hn {
  constructor(e, t, o = 0, i = 12, s = 3, l = be.ODD) {
    super(e, t, o, i, s, l);
    this.type = "ShapeGeometry";
  }
  _computeBufferEstimatedSize(e) {
    return e.vertexCount * 2 * (2 + this._bevelSegments);
  }
  _buildWall(e, t, o) {
    let i = e[0];
    for (let s = 0, l = i.boundary.vertexCount; s < l; s++) {
      let c = this._buildBevelVert(t, i, s), u = this._buildBevelVert(t, i, (s + 1) % l);
      o.push(u.topP, c.topN, c.bottomN), o.push(u.topP, c.bottomN, u.bottomP);
    }
  }
  clone() {
    let e = new Wn(this._shape, this._depth, this._bevel, this._curveSegments, this._bevelSegmentsInput);
    return e.userData = Ur(this.userData), e;
  }
};
var At = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    var _a2, _b2;
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, subdivisions: 40, roundness: 0, extrudeBevelSize: 0, extrudeBevelSegments: 3, windingRule: be.ODD }, n.parameters), t = Math.abs(e.width), o = Math.abs(e.height ?? e.width), i = Math.abs(e.depth ?? 0), s = n.shape ?? (r == null ? void 0 : r.shape), l = (s == null ? void 0 : s.roundness) ?? e.roundness;
    s !== void 0 && (s instanceof we ? (s.width !== t || s.height !== o) && s.applySize(t, o) : s = new we(t, o).fromJSON(s), ((_a2 = n.parameters) == null ? void 0 : _a2.roundness) !== void 0 && ((_b2 = n.parameters) == null ? void 0 : _b2.roundness) > 0 && s.update());
    let c = s ?? new we(t, o);
    return { parameters: Object.assign(e, { width: t, height: o, depth: i, roundness: l }), shape: c };
  }
  static build(n) {
    let { depth: r, extrudeBevelSize: e, extrudeBevelSegments: t, subdivisions: o, roundness: i, windingRule: s } = n.parameters;
    n.shape.roundness = i;
    let l;
    return r <= 0 ? l = new qn(n.shape, o, { windingRule: s }) : l = new Wn(n.shape, r, e, o, t, s), Object.assign(l, { userData: { ...n, type: "VectorGeometry" } });
  }
};
var Dh = Math.PI * 2;
var Yn = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, depth: 0, spikes: 64, angle: 360, innerRadius: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, n.parameters);
    return { shape: n.shape && n.shape instanceof we ? n.shape : new we(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }) };
  }
  static build(n) {
    let { width: r, height: e, spikes: t, angle: o, innerRadius: i, depth: s, extrudeBevelSize: l, extrudeBevelSegments: c } = n.parameters, u = n.shape, a = r * 0.5, d = e * 0.5, p = SP(u, a, d, o * Math.PI / 180, t, i);
    u.isClosed = true, u.update();
    let f = At.create({ shape: u, parameters: { subdivisions: p, depth: s, extrudeBevelSize: l, extrudeBevelSegments: c } });
    return Object.assign(f, { userData: { ...n, type: "EllipseGeometry" } });
  }
};
function SP(n, r, e, t, o, i) {
  if (t >= Dh)
    return o > 30 || o % 4 === 0 ? (_P(n, r, e, i), Math.round(o / 4)) : Eh(n, t, o, r, e, i);
  t = Math.max(t, 1e-3);
  let s = { x: 0, y: e }, l = t + Math.PI * 0.5, c = { x: Math.cos(l) * r, y: Math.sin(l) * e }, u = Ah({ px: s.x, py: s.y, cx: c.x, cy: c.y, rx: r, ry: e, largeArcFlag: t > Math.PI, sweepFlag: true });
  return o > 30 || o % u.length === 0 ? wP(n, s.x, s.y, u, o, r, e, i) : Eh(n, t, o, r, e, i);
}
function wP(n, r, e, t, o, i, s, l) {
  let c = Math.round(o / t.length);
  n.addPoint($n(r, e));
  for (let u = 0, a = t.length; u < a; u++) {
    let d = t[u], p = n.points[u], f = $n(d.x, d.y);
    p.controls[1].position.set(d.x1, d.y1), f.controls[0].position.set(d.x2, d.y2), n.addPoint(f);
  }
  return l > 0 ? Gh(n, i, s, l) : n.addPoint($n(0, 0)), c;
}
function Eh(n, r, e, t, o, i) {
  let s = -r / e;
  for (let l = 0; l <= e; l++) {
    let c = s * l, u = Math.sin(c) * t, a = Math.cos(c) * o;
    n.addPoint($n(u, a));
  }
  return r < Dh ? i > 0 ? Gh(n, t, o, i) : n.addPoint($n(0, 0)) : (n.removePoint(n.points[n.points.length - 1]), i > 0 && Rh(n, t, o, i)), 1;
}
function _P(n, r, e, t = 0, o = 0, i = 0) {
  let s = 0.5522847498, l = r * s, c = e * s;
  n.addPoint(dl(o - r, i, o - r, i - c, o - r, i + c)), n.addPoint(dl(o, i + e, o - l, i + e, o + l, i + e)), n.addPoint(dl(o + r, i, o + r, i + c, o + r, i - c)), n.addPoint(dl(o, i - e, o + l, i - e, o - l, i - e)), t > 0 && Rh(n, r, e, t);
}
function $n(n, r) {
  return new nr(MathUtils.generateUUID(), new Vector2(n, r));
}
function dl(n, r, e, t, o, i) {
  let s = $n(n, r);
  return s.controls[0].position.set(e, t), s.controls[1].position.set(o, i), s;
}
function Gh(n, r, e, t) {
  Vh(n, r, e, t).forEach((i) => n.addPoint(i));
}
function Rh(n, r, e, t) {
  let o = Vh(n, r, e, t), i = new we();
  o.forEach((s) => i.addPoint(s)), i.isClosed = true, n.shapeHoles.push(i);
}
function Vh(n, r, e, t) {
  let o = t * r / 100, i = o * (Math.abs(e) / Math.abs(r)), s = new Vector2(o / r, i / e), l = n.points.map((c) => {
    let u = c.clone();
    return u.uuid = MathUtils.generateUUID(), u;
  }).reverse();
  return l.forEach((c) => {
    c.position.multiply(s);
    let u = c.controls[0].position.clone().multiply(s), a = c.controls[1].position.clone().multiply(s);
    c.controls[0].position.copy(a), c.controls[1].position.copy(u);
  }), l;
}
var jh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, revolutions: 2, segments: 40, pathRadius: 10, pathType: 0, pathSegments: 30, cornerRadius: 30, cornerSegments: 4 }, n.parameters), t = Math.abs(e.width), o = Math.abs(e.height ?? t), i = Math.abs(e.depth ?? t), s = Math.abs(Math.min(t, i)) / 2;
    return { parameters: Object.assign(e, { width: t, height: o, depth: i, radius: s, segments: Math.round(e.segments), pathSegments: Math.round(e.pathSegments), cornerSegments: Math.round(e.cornerSegments) }) };
  }
  static build(n) {
    let { width: r, height: e, depth: t, radius: o, revolutions: i, segments: s, pathRadius: l, pathType: c, pathSegments: u, cornerRadius: a, cornerSegments: d } = n.parameters, p = new fs(false, r, e, t, o, i, s, l, c, u, a, d);
    return Object.assign(p, { userData: { ...n, type: "HelixGeometry" } });
  }
};
var sd = new Uint32BufferAttribute([0, 0, 0], 1);
var fs = class extends BufferGeometry {
  constructor(r = true, e = 1, t = 1, o = 1, i = 1, s = 1, l = 1, c = 1, u = 1, a = 1, d = 1, p = 1) {
    if (super(), s === 0)
      return;
    let f = r && s === 1;
    f && (p = 0), d > 100 && (d = 100), d === 0 && (p = 0);
    let m = () => new Vector3(), h = new Vector3(), y = m(), g = m(), v = m(), b, w, S, P, _, x, C, T, N = m(), O = m(), A = m(), R = m(), k = m(), $ = m(), te = m(), Y = m(), W = t - 2 * c + 1e-3, H = W / s, V = Math.ceil(l * s), G = V + 1, B = W / V, L = -W / 2, D = a + 1, X = 2 * Math.PI / a, q = Math.PI / 2 / p, j = 0.01, F = Math.min((1 - d / 100) * c, c - j), M = c - F, Q = 0, re = 2, oe = p * re + re, K = D * oe / re, ee = K + D * G, J = D * (G + oe), [ie, ce, se] = [3, 3, 2].map((ke) => Array(J * ke).fill(0)), fe = [], Re = i - c;
    function ge(ke, Et) {
      let mr = Math.PI / 2;
      x = Et * B, T = 2 * Math.PI * (x % H) / H + mr, x += L, C = Math.sin(T) * Re, _ = Math.cos(T) * Re, r ? ke.set(_, C, x) : ke.set(_, x, C);
    }
    ge(h, -1e-10), ge(y, 0), N.copy(h), ge(h, 1);
    let qe = h.distanceTo(y), Te = f ? 0 : M + F, wt = qe * V + 2 * Te, Ft = F, Xo = wt - Te;
    for (let ke = 0; ke <= V; ke++) {
      ge(g, ke), Y.subVectors(g, N).normalize(), N.copy(g), $.copy(g).setComponent(+r + 1, 0).normalize(), te.crossVectors(Y, $).normalize();
      let Et = ke === 0, mr = ke === V, o0 = Et ? 3 * Math.PI / 2 : q, n0 = Et ? Ft : Xo, i0 = Et ? D : ee, s0 = Et ? 0 : J - D, a0 = Y.clone().multiplyScalar(Et ? -M : M).add(g), l0 = Y.clone().multiplyScalar(Et ? -1 : 1).normalize();
      for (let Rr = 0; Rr < D; Rr++) {
        let bu = Rr * X;
        if (O.addVectors(h.copy($).multiplyScalar(c * Math.cos(bu)), y.copy(te).multiplyScalar(c * Math.sin(bu))), A.copy(O).normalize(), Et || mr) {
          f || (Q = s0 + Rr, [0, 1, 2].forEach((_t) => {
            ie[Q * 3 + _t] = a0.getComponent(_t), ce[Q * 3 + _t] = l0.getComponent(_t);
          }), se[Q * 2] = +mr, se[Q * 2 + 1] = Rr / a), y.copy(A).multiplyScalar(F), v.addVectors(g, y);
          for (let _t = 0; _t < p; _t++) {
            let Zl = _t * q + o0;
            R.addVectors(h.copy(Y).multiplyScalar(M * Math.sin(Zl)), y.copy(A).multiplyScalar(M * Math.cos(Zl))), k.copy(R).normalize(), y.addVectors(v, R), R.normalize(), Q = i0 + _t * D + Rr, [0, 1, 2].forEach((Hs) => {
              ie[Q * 3 + Hs] = y.getComponent(Hs), ce[Q * 3 + Hs] = k.getComponent(Hs);
            });
            let c0 = +Et + Math.sin(Zl);
            se[Q * 2] = (n0 + M * c0) / wt, se[Q * 2 + 1] = Rr / a;
          }
        }
        y.addVectors(g, O), Q = K + ke * D + Rr, [0, 1, 2].forEach((_t) => {
          ie[Q * 3 + _t] = y.getComponent(_t), ce[Q * 3 + _t] = A.getComponent(_t);
        }), se[Q * 2] = (Te + ke * qe) / wt, se[Q * 2 + 1] = Rr / a;
      }
    }
    let Mt = G + 2 * p + re, Fs = 1, [ks, Us] = [+f, Mt - 1];
    for (let ke = ks; ke <= Us - 1; ke++) {
      let Et = f && ke === Us - 1;
      for (let mr = 0; mr < D - 1; mr++)
        b = ke * D + mr, w = b + 1, S = (Et ? mr : b) + D, P = (Et ? mr + 1 : w) + D, ke === 0 ? fe.push(w, P, S) : ke === Mt - 2 ? fe.push(b, w, S) : fe.push(b, w, S, w, P, S);
    }
    this.setIndex(fe), this.setAttribute("position", new Float32BufferAttribute(ie, 3)), this.setAttribute("normal", new Float32BufferAttribute(ce, 3)), this.setAttribute("uv", new Float32BufferAttribute(se, 2));
  }
  getClosedTorusIndicesForBooleanOrSubdiv() {
    let r = this.userData.parameters, e = Math.ceil(r.tubularSegments), t = r.radialSegments + 1, o = Array.from(this.getIndex().array), i, s, l, c, u = 6 * (e - 1) * r.radialSegments, a = e, d = a === e;
    for (let p = 0; p < r.radialSegments; p++)
      i = a * t + p, s = i + 1, l = (d ? p : i) + t, c = (d ? p + 1 : s) + t, o[u++] = i, o[u++] = s, o[u++] = l, o[u++] = s, o[u++] = c, o[u++] = l;
    return o.length = u, sd.array = o, sd.count = o.length, sd;
  }
};
var Fh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, detail: 0, corner: 0, cornerSides: 4 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { width: r, height: e, depth: t, detail: o, corner: i, cornerSides: s } = n.parameters, l = o === 0 && i !== 0 ? new ms(r * 0.5, i, s) : new IcosahedronGeometry(r * 0.5, o);
    return l.scale(1, e / r, t / r), Object.assign(l, { userData: { ...n, type: "IcosahedronGeometry" } });
  }
};
var ms = class extends fo {
  constructor(r = 1, e = 0.2, t = 4) {
    let o = (1 + Math.sqrt(5)) / 2, i = [-1, o, 0, 1, o, 0, -1, -o, 0, 1, -o, 0, 0, -1, o, 0, 1, o, 0, -1, -o, 0, 1, -o, o, 0, -1, o, 0, 1, -o, 0, -1, -o, 0, 1], s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], l = "IcosahedronGeometry";
    super(i, s, l, r, e, t), this.type = l;
  }
  static fromJSON(r) {
    return new ms(r.radius, r.corner, r.cornerSides);
  }
};
var kh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    var _a2;
    (((_a2 = n.parameters) == null ? void 0 : _a2.points) ?? []).forEach((t) => {
      Array.isArray(t) && (t.x = t[0], t.y = t[1]);
    });
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, segments: 64, verticalSegments: 64, points: [{ x: 0, y: -50, id: 0 }, { x: 50, y: -50, id: 1 }, { x: 50, y: 50, id: 2 }, { x: 0, y: 50, id: 3 }] }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { points: r, segments: e, verticalSegments: t } = n.parameters, o = new Shape();
    o.moveTo(r[0].x, r[0].y), o.bezierCurveTo(r[1].x, r[1].y, r[2].x, r[2].y, r[3].x, r[3].y);
    let i = new LatheGeometry(o.extractPoints(t).shape, e);
    return i.rotateZ(Math.PI), Object.assign(i, { userData: { ...n, type: "LatheGeometry" } });
  }
};
var Pr = new Matrix4();
var ad = new Object3D();
var ul = new Vector3();
var ho = class extends EventDispatcher {
  constructor() {
    super(), this.uuid = MathUtils.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = false, this.verticesNeedUpdate = false, this.uvsNeedUpdate = false, this.normalsNeedUpdate = false, this.colorsNeedUpdate = false, this.lineDistancesNeedUpdate = false, this.groupsNeedUpdate = false;
  }
  applyMatrix4(r) {
    let e = new Matrix3().getNormalMatrix(r);
    for (let t = 0, o = this.vertices.length; t < o; t++)
      this.vertices[t].applyMatrix4(r);
    for (let t = 0, o = this.faces.length; t < o; t++) {
      let i = this.faces[t];
      i.normal.applyMatrix3(e).normalize();
      for (let s = 0, l = i.vertexNormals.length; s < l; s++)
        i.vertexNormals[s].applyMatrix3(e).normalize();
    }
    return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.verticesNeedUpdate = true, this.normalsNeedUpdate = true, this;
  }
  rotateX(r) {
    return Pr.makeRotationX(r), this.applyMatrix4(Pr), this;
  }
  rotateY(r) {
    return Pr.makeRotationY(r), this.applyMatrix4(Pr), this;
  }
  rotateZ(r) {
    return Pr.makeRotationZ(r), this.applyMatrix4(Pr), this;
  }
  translate(r, e, t) {
    return Pr.makeTranslation(r, e, t), this.applyMatrix4(Pr), this;
  }
  scale(r, e, t) {
    return Pr.makeScale(r, e, t), this.applyMatrix4(Pr), this;
  }
  lookAt(r) {
    return ad.lookAt(r), ad.updateMatrix(), this.applyMatrix4(ad.matrix), this;
  }
  fromBufferGeometry(r) {
    let e = this, t = r.index !== null ? r.index : void 0, o = r.attributes;
    if (o.position === void 0)
      return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
    let i = o.position, s = o.normal, l = o.color, c = o.uv, u = o.uv2;
    u !== void 0 && (this.faceVertexUvs[1] = []);
    for (let p = 0; p < i.count; p++)
      e.vertices.push(new Vector3().fromBufferAttribute(i, p)), l !== void 0 && e.colors.push(new Color().fromBufferAttribute(l, p));
    function a(p, f, m, h) {
      let y = l === void 0 ? [] : [e.colors[p].clone(), e.colors[f].clone(), e.colors[m].clone()], g = s === void 0 ? [] : [new Vector3().fromBufferAttribute(s, p), new Vector3().fromBufferAttribute(s, f), new Vector3().fromBufferAttribute(s, m)], v = new Kn(p, f, m, g, y, h);
      e.faces.push(v), c !== void 0 && e.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(c, p), new Vector2().fromBufferAttribute(c, f), new Vector2().fromBufferAttribute(c, m)]), u !== void 0 && e.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(u, p), new Vector2().fromBufferAttribute(u, f), new Vector2().fromBufferAttribute(u, m)]);
    }
    let d = r.groups;
    if (d.length > 0)
      for (let p = 0; p < d.length; p++) {
        let f = d[p], m = f.start, h = f.count;
        for (let y = m, g = m + h; y < g; y += 3)
          t !== void 0 ? a(t.getX(y), t.getX(y + 1), t.getX(y + 2), f.materialIndex) : a(y, y + 1, y + 2, f.materialIndex);
      }
    else if (t !== void 0)
      for (let p = 0; p < t.count; p += 3)
        a(t.getX(p), t.getX(p + 1), t.getX(p + 2));
    else
      for (let p = 0; p < i.count; p += 3)
        a(p, p + 1, p + 2);
    return this.computeFaceNormals(), r.boundingBox !== null && (this.boundingBox = r.boundingBox.clone()), r.boundingSphere !== null && (this.boundingSphere = r.boundingSphere.clone()), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(ul).negate(), this.translate(ul.x, ul.y, ul.z), this;
  }
  normalize() {
    this.computeBoundingSphere();
    let r = this.boundingSphere.center, e = this.boundingSphere.radius, t = e === 0 ? 1 : 1 / e, o = new Matrix4();
    return o.set(t, 0, 0, -t * r.x, 0, t, 0, -t * r.y, 0, 0, t, -t * r.z, 0, 0, 0, 1), this.applyMatrix4(o), this;
  }
  computeFaceNormals() {
    let r = new Vector3(), e = new Vector3();
    for (let t = 0, o = this.faces.length; t < o; t++) {
      let i = this.faces[t], s = this.vertices[i.a], l = this.vertices[i.b], c = this.vertices[i.c];
      r.subVectors(c, l), e.subVectors(s, l), r.cross(e), r.normalize(), i.normal.copy(r);
    }
  }
  computeVertexNormals(r = true) {
    let e = new Array(this.vertices.length);
    for (let t = 0, o = this.vertices.length; t < o; t++)
      e[t] = new Vector3();
    if (r) {
      let t = new Vector3(), o = new Vector3();
      for (let i = 0, s = this.faces.length; i < s; i++) {
        let l = this.faces[i], c = this.vertices[l.a], u = this.vertices[l.b], a = this.vertices[l.c];
        t.subVectors(a, u), o.subVectors(c, u), t.cross(o), e[l.a].add(t), e[l.b].add(t), e[l.c].add(t);
      }
    } else {
      this.computeFaceNormals();
      for (let t = 0, o = this.faces.length; t < o; t++) {
        let i = this.faces[t];
        e[i.a].add(i.normal), e[i.b].add(i.normal), e[i.c].add(i.normal);
      }
    }
    for (let t = 0, o = this.vertices.length; t < o; t++)
      e[t].normalize();
    for (let t = 0, o = this.faces.length; t < o; t++) {
      let i = this.faces[t], s = i.vertexNormals;
      s.length === 3 ? (s[0].copy(e[i.a]), s[1].copy(e[i.b]), s[2].copy(e[i.c])) : (s[0] = e[i.a].clone(), s[1] = e[i.b].clone(), s[2] = e[i.c].clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = true);
  }
  computeFlatVertexNormals() {
    this.computeFaceNormals();
    for (let r = 0, e = this.faces.length; r < e; r++) {
      let t = this.faces[r], o = t.vertexNormals;
      o.length === 3 ? (o[0].copy(t.normal), o[1].copy(t.normal), o[2].copy(t.normal)) : (o[0] = t.normal.clone(), o[1] = t.normal.clone(), o[2] = t.normal.clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = true);
  }
  computeMorphNormals() {
    for (let e = 0, t = this.faces.length; e < t; e++) {
      let o = this.faces[e];
      o.__originalFaceNormal ? o.__originalFaceNormal.copy(o.normal) : o.__originalFaceNormal = o.normal.clone(), o.__originalVertexNormals || (o.__originalVertexNormals = []);
      for (let i = 0, s = o.vertexNormals.length; i < s; i++)
        o.__originalVertexNormals[i] ? o.__originalVertexNormals[i].copy(o.vertexNormals[i]) : o.__originalVertexNormals[i] = o.vertexNormals[i].clone();
    }
    let r = new ho();
    r.faces = this.faces;
    for (let e = 0, t = this.morphTargets.length; e < t; e++) {
      if (!this.morphNormals[e]) {
        this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
        let i = this.morphNormals[e].faceNormals, s = this.morphNormals[e].vertexNormals;
        for (let l = 0, c = this.faces.length; l < c; l++) {
          let u = new Vector3(), a = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
          i.push(u), s.push(a);
        }
      }
      let o = this.morphNormals[e];
      r.vertices = this.morphTargets[e].vertices, r.computeFaceNormals(), r.computeVertexNormals();
      for (let i = 0, s = this.faces.length; i < s; i++) {
        let l = this.faces[i], c = o.faceNormals[i], u = o.vertexNormals[i];
        c.copy(l.normal), u.a.copy(l.vertexNormals[0]), u.b.copy(l.vertexNormals[1]), u.c.copy(l.vertexNormals[2]);
      }
    }
    for (let e = 0, t = this.faces.length; e < t; e++) {
      let o = this.faces[e];
      o.normal = o.__originalFaceNormal, o.vertexNormals = o.__originalVertexNormals;
    }
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3()), this.boundingBox.setFromPoints(this.vertices);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere()), this.boundingSphere.setFromPoints(this.vertices);
  }
  merge(r, e, t = 0) {
    if (!(r && r.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", r);
      return;
    }
    let o, i = this.vertices.length, s = this.vertices, l = r.vertices, c = this.faces, u = r.faces, a = this.colors, d = r.colors;
    e !== void 0 && (o = new Matrix3().getNormalMatrix(e));
    for (let p = 0, f = l.length; p < f; p++) {
      let h = l[p].clone();
      e !== void 0 && h.applyMatrix4(e), s.push(h);
    }
    for (let p = 0, f = d.length; p < f; p++)
      a.push(d[p].clone());
    for (let p = 0, f = u.length; p < f; p++) {
      let m = u[p], h, y, g = m.vertexNormals, v = m.vertexColors, b = new Kn(m.a + i, m.b + i, m.c + i);
      b.normal.copy(m.normal), o !== void 0 && b.normal.applyMatrix3(o).normalize();
      for (let w = 0, S = g.length; w < S; w++)
        h = g[w].clone(), o !== void 0 && h.applyMatrix3(o).normalize(), b.vertexNormals.push(h);
      b.color.copy(m.color);
      for (let w = 0, S = v.length; w < S; w++)
        y = v[w], b.vertexColors.push(y.clone());
      b.materialIndex = m.materialIndex + t, c.push(b);
    }
    for (let p = 0, f = r.faceVertexUvs.length; p < f; p++) {
      let m = r.faceVertexUvs[p];
      this.faceVertexUvs[p] === void 0 && (this.faceVertexUvs[p] = []);
      for (let h = 0, y = m.length; h < y; h++) {
        let g = m[h], v = [];
        for (let b = 0, w = g.length; b < w; b++)
          v.push(g[b].clone());
        this.faceVertexUvs[p].push(v);
      }
    }
  }
  mergeMesh(r) {
    if (!(r && r.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", r);
      return;
    }
    r.matrixAutoUpdate && r.updateMatrix(), this.merge(r.geometry, r.matrix);
  }
  mergeVertices(r = 4) {
    let e = {}, t = [], o = [], i = Math.pow(10, r);
    for (let c = 0, u = this.vertices.length; c < u; c++) {
      let a = this.vertices[c], d = Math.round(a.x * i) + "_" + Math.round(a.y * i) + "_" + Math.round(a.z * i);
      e[d] === void 0 ? (e[d] = c, t.push(this.vertices[c]), o[c] = t.length - 1) : o[c] = o[e[d]];
    }
    let s = [];
    for (let c = 0, u = this.faces.length; c < u; c++) {
      let a = this.faces[c];
      a.a = o[a.a], a.b = o[a.b], a.c = o[a.c];
      let d = [a.a, a.b, a.c];
      for (let p = 0; p < 3; p++)
        if (d[p] === d[(p + 1) % 3]) {
          s.push(c);
          break;
        }
    }
    for (let c = s.length - 1; c >= 0; c--) {
      let u = s[c];
      this.faces.splice(u, 1);
      for (let a = 0, d = this.faceVertexUvs.length; a < d; a++)
        this.faceVertexUvs[a].splice(u, 1);
    }
    let l = this.vertices.length - t.length;
    return this.vertices = t, l;
  }
  setFromPoints(r) {
    this.vertices = [];
    for (let e = 0, t = r.length; e < t; e++) {
      let o = r[e];
      this.vertices.push(new Vector3(o.x, o.y, o.z || 0));
    }
    return this;
  }
  sortFacesByMaterialIndex() {
    let r = this.faces, e = r.length;
    for (let c = 0; c < e; c++)
      r[c]._id = c;
    function t(c, u) {
      return c.materialIndex - u.materialIndex;
    }
    r.sort(t);
    let o = this.faceVertexUvs[0], i = this.faceVertexUvs[1], s, l;
    o && o.length === e && (s = []), i && i.length === e && (l = []);
    for (let c = 0; c < e; c++) {
      let u = r[c]._id;
      s && s.push(o[u]), l && l.push(i[u]);
    }
    s && (this.faceVertexUvs[0] = s), l && (this.faceVertexUvs[1] = l);
  }
  toJSON() {
    let r = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } };
    if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.parameters !== void 0) {
      let m = this.parameters;
      for (let h in m)
        m[h] !== void 0 && (r[h] = m[h]);
      return r;
    }
    let e = [];
    for (let m = 0; m < this.vertices.length; m++) {
      let h = this.vertices[m];
      e.push(h.x, h.y, h.z);
    }
    let t = [], o = [], i = {}, s = [], l = {}, c = [], u = {};
    for (let m = 0; m < this.faces.length; m++) {
      let h = this.faces[m], y = true, g = false, v = this.faceVertexUvs[0][m] !== void 0, b = h.normal.length() > 0, w = h.vertexNormals.length > 0, S = h.color.r !== 1 || h.color.g !== 1 || h.color.b !== 1, P = h.vertexColors.length > 0, _ = 0;
      if (_ = a(_, 0, 0), _ = a(_, 1, y), _ = a(_, 2, g), _ = a(_, 3, v), _ = a(_, 4, b), _ = a(_, 5, w), _ = a(_, 6, S), _ = a(_, 7, P), t.push(_), t.push(h.a, h.b, h.c), t.push(h.materialIndex), v) {
        let x = this.faceVertexUvs[0][m];
        t.push(f(x[0]), f(x[1]), f(x[2]));
      }
      if (b && t.push(d(h.normal)), w) {
        let x = h.vertexNormals;
        t.push(d(x[0]), d(x[1]), d(x[2]));
      }
      if (S && t.push(p(h.color)), P) {
        let x = h.vertexColors;
        t.push(p(x[0]), p(x[1]), p(x[2]));
      }
    }
    function a(m, h, y) {
      return y ? m | 1 << h : m & ~(1 << h);
    }
    function d(m) {
      let h = m.x.toString() + m.y.toString() + m.z.toString();
      return i[h] !== void 0 || (i[h] = o.length / 3, o.push(m.x, m.y, m.z)), i[h];
    }
    function p(m) {
      let h = m.r.toString() + m.g.toString() + m.b.toString();
      return l[h] !== void 0 || (l[h] = s.length, s.push(m.getHex())), l[h];
    }
    function f(m) {
      let h = m.x.toString() + m.y.toString();
      return u[h] !== void 0 || (u[h] = c.length / 2, c.push(m.x, m.y)), u[h];
    }
    return r.data = {}, r.data.vertices = e, r.data.normals = o, s.length > 0 && (r.data.colors = s), c.length > 0 && (r.data.uvs = [c]), r.data.faces = t, r;
  }
  clone() {
    return new ho().copy(this);
  }
  copy(r) {
    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = r.name;
    let e = r.vertices;
    for (let p = 0, f = e.length; p < f; p++)
      this.vertices.push(e[p].clone());
    let t = r.colors;
    for (let p = 0, f = t.length; p < f; p++)
      this.colors.push(t[p].clone());
    let o = r.faces;
    for (let p = 0, f = o.length; p < f; p++)
      this.faces.push(o[p].clone());
    for (let p = 0, f = r.faceVertexUvs.length; p < f; p++) {
      let m = r.faceVertexUvs[p];
      this.faceVertexUvs[p] === void 0 && (this.faceVertexUvs[p] = []);
      for (let h = 0, y = m.length; h < y; h++) {
        let g = m[h], v = [];
        for (let b = 0, w = g.length; b < w; b++) {
          let S = g[b];
          v.push(S.clone());
        }
        this.faceVertexUvs[p].push(v);
      }
    }
    let i = r.morphTargets;
    for (let p = 0, f = i.length; p < f; p++) {
      let m = {};
      if (m.name = i[p].name, i[p].vertices !== void 0) {
        m.vertices = [];
        for (let h = 0, y = i[p].vertices.length; h < y; h++)
          m.vertices.push(i[p].vertices[h].clone());
      }
      if (i[p].normals !== void 0) {
        m.normals = [];
        for (let h = 0, y = i[p].normals.length; h < y; h++)
          m.normals.push(i[p].normals[h].clone());
      }
      this.morphTargets.push(m);
    }
    let s = r.morphNormals;
    for (let p = 0, f = s.length; p < f; p++) {
      let m = {};
      if (s[p].vertexNormals !== void 0) {
        m.vertexNormals = [];
        for (let h = 0, y = s[p].vertexNormals.length; h < y; h++) {
          let g = s[p].vertexNormals[h], v = {};
          v.a = g.a.clone(), v.b = g.b.clone(), v.c = g.c.clone(), m.vertexNormals.push(v);
        }
      }
      if (s[p].faceNormals !== void 0) {
        m.faceNormals = [];
        for (let h = 0, y = s[p].faceNormals.length; h < y; h++)
          m.faceNormals.push(s[p].faceNormals[h].clone());
      }
      this.morphNormals.push(m);
    }
    let l = r.skinWeights;
    for (let p = 0, f = l.length; p < f; p++)
      this.skinWeights.push(l[p].clone());
    let c = r.skinIndices;
    for (let p = 0, f = c.length; p < f; p++)
      this.skinIndices.push(c[p].clone());
    let u = r.lineDistances;
    for (let p = 0, f = u.length; p < f; p++)
      this.lineDistances.push(u[p]);
    let a = r.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    let d = r.boundingSphere;
    return d !== null && (this.boundingSphere = d.clone()), this.elementsNeedUpdate = r.elementsNeedUpdate, this.verticesNeedUpdate = r.verticesNeedUpdate, this.uvsNeedUpdate = r.uvsNeedUpdate, this.normalsNeedUpdate = r.normalsNeedUpdate, this.colorsNeedUpdate = r.colorsNeedUpdate, this.lineDistancesNeedUpdate = r.lineDistancesNeedUpdate, this.groupsNeedUpdate = r.groupsNeedUpdate, this;
  }
  toBufferGeometry() {
    let r = new ld().fromGeometry(this), e = new BufferGeometry(), t = new Float32Array(r.vertices.length * 3);
    if (e.setAttribute("position", pl.call(new BufferAttribute(t, 3), r.vertices)), r.normals.length > 0) {
      let o = new Float32Array(r.normals.length * 3);
      e.setAttribute("normal", pl.call(new BufferAttribute(o, 3), r.normals));
    }
    if (r.colors.length > 0) {
      let o = new Float32Array(r.colors.length * 3);
      e.setAttribute("color", qh.call(new BufferAttribute(o, 3), r.colors));
    }
    if (r.uvs.length > 0) {
      let o = new Float32Array(r.uvs.length * 2);
      e.setAttribute("uv", Wh.call(new BufferAttribute(o, 2), r.uvs));
    }
    if (r.uvs2.length > 0) {
      let o = new Float32Array(r.uvs2.length * 2);
      e.setAttribute("uv2", Wh.call(new BufferAttribute(o, 2), r.uvs2));
    }
    e.groups = r.groups;
    for (let o in r.morphTargets) {
      let i = [], s = r.morphTargets[o];
      for (let l = 0, c = s.length; l < c; l++) {
        let u = s[l], a = new Float32BufferAttribute(u.data.length * 3, 3);
        a.name = u.name, i.push(pl.call(a, u.data));
      }
      e.morphAttributes[o] = i;
    }
    if (r.skinIndices.length > 0) {
      let o = new Float32BufferAttribute(r.skinIndices.length * 4, 4);
      e.setAttribute("skinIndex", $h.call(o, r.skinIndices));
    }
    if (r.skinWeights.length > 0) {
      let o = new Float32BufferAttribute(r.skinWeights.length * 4, 4);
      e.setAttribute("skinWeight", $h.call(o, r.skinWeights));
    }
    return r.boundingSphere !== null && (e.boundingSphere = r.boundingSphere.clone()), r.boundingBox !== null && (e.boundingBox = r.boundingBox.clone()), e;
  }
  computeTangents() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  }
  computeLineDistances() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  }
  applyMatrix(r) {
    return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(r);
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  static createBufferGeometryFromObject(r) {
    let e = new BufferGeometry(), t = r.geometry;
    if (r.isPoints || r.isLine) {
      let o = new Float32BufferAttribute(t.vertices.length * 3, 3), i = new Float32BufferAttribute(t.colors.length * 3, 3);
      if (e.setAttribute("position", pl.call(o, t.vertices)), e.setAttribute("color", qh.call(i, t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
        let s = new Float32BufferAttribute(t.lineDistances.length, 1);
        e.setAttribute("lineDistance", DP.call(s, t.lineDistances));
      }
      t.boundingSphere !== null && (e.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (e.boundingBox = t.boundingBox.clone());
    } else
      r.isMesh && (e = t.toBufferGeometry());
    return e;
  }
};
ho.prototype.isGeometry = true;
var ld = class {
  constructor() {
    this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = false, this.normalsNeedUpdate = false, this.colorsNeedUpdate = false, this.uvsNeedUpdate = false, this.groupsNeedUpdate = false;
  }
  computeGroups(r) {
    let e = [], t, o, i, s = r.faces;
    for (o = 0; o < s.length; o++) {
      let l = s[o];
      l.materialIndex !== i && (i = l.materialIndex, t !== void 0 && (t.count = o * 3 - t.start, e.push(t)), t = { start: o * 3, materialIndex: i });
    }
    t !== void 0 && (t.count = o * 3 - t.start, e.push(t)), this.groups = e;
  }
  fromGeometry(r) {
    let e = r.faces, t = r.vertices, o = r.faceVertexUvs, i = o[0] && o[0].length > 0, s = o[1] && o[1].length > 0, l = r.morphTargets, c = l.length, u;
    if (c > 0) {
      u = [];
      for (let g = 0; g < c; g++)
        u[g] = { name: l[g].name, data: [] };
      this.morphTargets.position = u;
    }
    let a = r.morphNormals, d = a.length, p;
    if (d > 0) {
      p = [];
      for (let g = 0; g < d; g++)
        p[g] = { name: a[g].name, data: [] };
      this.morphTargets.normal = p;
    }
    let f = r.skinIndices, m = r.skinWeights, h = f.length === t.length, y = m.length === t.length;
    t.length > 0 && e.length === 0 && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    for (let g = 0; g < e.length; g++) {
      let v = e[g];
      this.vertices.push(t[v.a], t[v.b], t[v.c]);
      let b = v.vertexNormals;
      if (b.length === 3)
        this.normals.push(b[0], b[1], b[2]);
      else {
        let S = v.normal;
        this.normals.push(S, S, S);
      }
      let w = v.vertexColors;
      if (w.length === 3)
        this.colors.push(w[0], w[1], w[2]);
      else {
        let S = v.color;
        this.colors.push(S, S, S);
      }
      if (i === true) {
        let S = o[0][g];
        S !== void 0 ? this.uvs.push(S[0], S[1], S[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", g), this.uvs.push(new Vector2(), new Vector2(), new Vector2()));
      }
      if (s === true) {
        let S = o[1][g];
        S !== void 0 ? this.uvs2.push(S[0], S[1], S[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", g), this.uvs2.push(new Vector2(), new Vector2(), new Vector2()));
      }
      for (let S = 0; S < c; S++) {
        let P = l[S].vertices;
        u[S].data.push(P[v.a], P[v.b], P[v.c]);
      }
      for (let S = 0; S < d; S++) {
        let P = a[S].vertexNormals[g];
        p[S].data.push(P.a, P.b, P.c);
      }
      h && this.skinIndices.push(f[v.a], f[v.b], f[v.c]), y && this.skinWeights.push(m[v.a], m[v.b], m[v.c]);
    }
    return this.computeGroups(r), this.verticesNeedUpdate = r.verticesNeedUpdate, this.normalsNeedUpdate = r.normalsNeedUpdate, this.colorsNeedUpdate = r.colorsNeedUpdate, this.uvsNeedUpdate = r.uvsNeedUpdate, this.groupsNeedUpdate = r.groupsNeedUpdate, r.boundingSphere !== null && (this.boundingSphere = r.boundingSphere.clone()), r.boundingBox !== null && (this.boundingBox = r.boundingBox.clone()), this;
  }
};
var Kn = class {
  constructor(r, e, t, o, i, s = 0) {
    this.a = r, this.b = e, this.c = t, this.normal = o && o.isVector3 ? o : new Vector3(), this.vertexNormals = Array.isArray(o) ? o : [], this.color = i && i.isColor ? i : new Color(), this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = s;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    this.a = r.a, this.b = r.b, this.c = r.c, this.normal.copy(r.normal), this.color.copy(r.color), this.materialIndex = r.materialIndex;
    for (let e = 0, t = r.vertexNormals.length; e < t; e++)
      this.vertexNormals[e] = r.vertexNormals[e].clone();
    for (let e = 0, t = r.vertexColors.length; e < t; e++)
      this.vertexColors[e] = r.vertexColors[e].clone();
    return this;
  }
};
function DP(n) {
  return this.array.set(n), this;
}
function qh(n) {
  let r = this.array, e = 0;
  for (let t = 0, o = n.length; t < o; t++) {
    let i = n[t];
    i === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", t), i = new Color()), r[e++] = i.r, r[e++] = i.g, r[e++] = i.b;
  }
  return this;
}
function Wh(n) {
  let r = this.array, e = 0;
  for (let t = 0, o = n.length; t < o; t++) {
    let i = n[t];
    i === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", t), i = new Vector2()), r[e++] = i.x, r[e++] = i.y;
  }
  return this;
}
function pl(n) {
  let r = this.array, e = 0;
  for (let t = 0, o = n.length; t < o; t++) {
    let i = n[t];
    i === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", t), i = new Vector3()), r[e++] = i.x, r[e++] = i.y, r[e++] = i.z;
  }
  return this;
}
function $h(n) {
  let r = this.array, e = 0;
  for (let t = 0, o = n.length; t < o; t++) {
    let i = n[t];
    i === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", t), i = new Vector4()), r[e++] = i.x, r[e++] = i.y, r[e++] = i.z, r[e++] = i.w;
  }
  return this;
}
var RP = ["a", "b", "c"];
function VP(n, r) {
  switch (r) {
    case "c":
      return n.c;
    case "b":
      return n.b;
    case "a":
    default:
      return n.a;
  }
}
function ud(n, r, e) {
  let t = Math.min(n, r), o = Math.max(n, r), i = t + "_" + o;
  return e.get(i);
}
function pd(n, r, e, t, o, i) {
  let s = Math.min(n, r), l = Math.max(n, r), c = s + "_" + l, u;
  if (t.has(c))
    u = t.get(c);
  else {
    let a = e[s], d = e[l];
    u = { a, b: d, newEdge: null, faces: [] }, t.set(c, u);
  }
  u.faces.push(o), i[n].edges.push(u), i[r].edges.push(u);
}
function zP(n, r, e, t) {
  let o, i, s;
  for (o = 0, i = n.length; o < i; o++)
    e[o] = { edges: [] };
  for (o = 0, i = r.length; o < i; o++)
    s = r[o], pd(s.a, s.b, n, t, s, e), pd(s.b, s.c, n, t, s, e), pd(s.c, s.a, n, t, s, e);
}
function fl(n, r, e, t, o) {
  n.push(new Kn(r, e, t, void 0, void 0, o));
}
function Zn(n, r) {
  return Math.abs(r - n) / 2 + Math.min(n, r);
}
function ml(n, r, e, t) {
  n.push([r.clone(), e.clone(), t.clone()]);
}
var hl = class {
  constructor(r = 1) {
    this.subdivisions = r;
  }
  modify(r) {
    r instanceof BufferGeometry ? r = new ho().fromBufferGeometry(r) : r = r.clone(), r.mergeVertices();
    let e = this.subdivisions;
    for (; e-- > 0; )
      this._smooth(r);
    return r.computeFaceNormals(), r.computeVertexNormals(), r;
  }
  _smooth(r) {
    let e = new Vector3(), t, o, i, s, l, c = r.vertices, u = r.faces, a = r.faceVertexUvs[0], d = a !== void 0 && a.length > 0, p = [], f = /* @__PURE__ */ new Map();
    zP(c, u, p, f);
    let m = [], h, y, g, v, b, w, S;
    for (let j of Array.from(f.keys())) {
      for (y = f.get(j), g = new Vector3(), b = 3 / 8, w = 1 / 8, S = y.faces.length, S != 2 && (b = 0.5, w = 0, S != 1), g.addVectors(y.a, y.b).multiplyScalar(b), e.set(0, 0, 0), s = 0; s < S; s++) {
        for (v = y.faces[s], l = 0; l < 3 && (h = c[VP(v, RP[l])], !(h !== y.a && h !== y.b)); l++)
          ;
        h && e.add(h);
      }
      e.multiplyScalar(w), g.add(e), y.newEdge = m.length, m.push(g);
    }
    let P, _, x, C, T, N, O, A = [];
    for (o = 0, i = c.length; o < i; o++) {
      for (N = c[o], T = p[o].edges, t = T.length, t == 3 ? P = 3 / 16 : t > 3 && (P = 3 / (8 * t)), _ = 1 - t * Number(P), x = P, t <= 2 && (t == 2 ? (_ = 3 / 4, x = 1 / 8) : t == 1 || t == 0), O = N.clone().multiplyScalar(_), e.set(0, 0, 0), s = 0; s < t; s++)
        C = T[s], h = C.a !== N ? C.a : C.b, e.add(h);
      e.multiplyScalar(Number(x)), O.add(e), A.push(O);
    }
    let R = A.concat(m), k = A.length, $, te, Y, W = [], H = [], V, G, B, L, D = new Vector2(), X = new Vector2(), q = new Vector2();
    for (o = 0, i = u.length; o < i; o++)
      v = u[o], $ = Number(ud(v.a, v.b, f).newEdge) + k, te = Number(ud(v.b, v.c, f).newEdge) + k, Y = Number(ud(v.c, v.a, f).newEdge) + k, fl(W, $, te, Y, v.materialIndex), fl(W, v.a, $, Y, v.materialIndex), fl(W, v.b, te, $, v.materialIndex), fl(W, v.c, Y, te, v.materialIndex), d && (V = a[o], G = V[0], B = V[1], L = V[2], D.set(Zn(G.x, B.x), Zn(G.y, B.y)), X.set(Zn(B.x, L.x), Zn(B.y, L.y)), q.set(Zn(G.x, L.x), Zn(G.y, L.y)), ml(H, D, X, q), ml(H, G, D, q), ml(H, B, X, D), ml(H, L, q, X));
    r.vertices = R, r.faces = W, d && (r.faceVertexUvs[0] = H);
  }
};
var Ye = new Vector3();
var Qh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = n.geometry ?? (r == null ? void 0 : r.geometry) ?? new BufferGeometry().copy(new BoxGeometry(100, 100, 100)), t;
    r === void 0 ? (e.computeBoundingBox(), e.boundingBox.getSize(Ye), t = { width: Ye.x, height: Ye.y, depth: Ye.z, subdivisions: 0 }) : t = r.parameters;
    let o = { ...t, ...n.parameters };
    return { parameters: { width: Math.abs(o.width), height: Math.abs(o.height), depth: Math.abs(o.depth), subdivisions: Math.abs(o.subdivisions) }, geometry: e };
  }
  static build(n) {
    let { width: r, height: e, depth: t, subdivisions: o } = n.parameters, i = n.geometry ?? new BufferGeometry().copy(new BoxGeometry(100, 100, 100)), s = i.userData.parameters;
    s === void 0 ? (i.computeBoundingBox(), i.boundingBox.getSize(Ye)) : Ye.set(s.width, s.height, s.depth), (r !== Ye.x || e !== Ye.y || t !== Ye.z) && i.scale(Ye.x === 0 ? 1 : r / Ye.x, Ye.y === 0 ? 1 : e / Ye.y, Ye.z === 0 ? 1 : t / Ye.z);
    let l = i.originalGeometry;
    try {
      o > 0 ? (l === void 0 || (s == null ? void 0 : s.subdivisions) !== o) && (l === void 0 && (l = i), i = new hl(o).modify(l).toBufferGeometry()) : (l !== void 0 && (i = l), l = void 0, i.getAttribute("normal") === void 0 && i.computeVertexNormals());
    } catch {
      l !== void 0 && (i = l), l = void 0, i.getAttribute("normal") === void 0 && i.computeVertexNormals();
    }
    return l !== void 0 && Object.assign(i, { originalGeometry: l }), delete n.geometry, Object.assign(i, { userData: { ...n, type: "NonParametricGeometry" } });
  }
  static loadFromUrl(n, r, e) {
    new BufferGeometryLoader(e).load(n, (o) => {
      let i = this.normalizeInputs({ geometry: o });
      o.boundingBox.getSize(Ye);
      let s = 100 / Ye.x;
      Object.assign(i.parameters, { width: 100, height: Ye.y * s, depth: Ye.z * s }), r(this.build(i));
    });
  }
};
var yl = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, depth: 0, spikes: 5, cornerRadius: 0, extrudeBevelSize: 0, extrudeBevelSegments: 3 }, n.parameters);
    return { shape: n.shape && n.shape instanceof we ? n.shape : new we(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }) };
  }
  static build(n) {
    let { width: r, height: e, spikes: t, cornerRadius: o, depth: i, extrudeBevelSize: s, extrudeBevelSegments: l } = n.parameters, c = n.shape, u = r * 0.5, a = e * 0.5, d = 0, p = 0, f = 2 * Math.PI / t;
    for (let h = 0; h < t; h++) {
      let y = f * h, g = d + Math.sin(y) * u, v = p + Math.cos(y) * a;
      c.addPoint(c.createPoint(g, v));
    }
    c.isClosed = true;
    for (let h = 0, y = c.points.length; h < y; h++)
      c.points[h].roundness = o;
    c.roundness = o, c.update();
    let m = At.create({ shape: c, parameters: { roundness: o, depth: i, extrudeBevelSize: s, extrudeBevelSegments: l } });
    return Object.assign(m, { userData: { ...n, type: "PolygonGeometry" } });
  }
};
var Jh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, radialSegments: 4, heightSegments: 1, cornerRadius: 0, cornerSegments: 8, openEnded: false }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { width: r, height: e, depth: t, radialSegments: o, heightSegments: i, openEnded: s, cornerRadius: l, cornerSegments: c } = n.parameters, u = new hd(r * 0.5, e, o, i, s, l, c);
    return u.scale(1, 1, t / r), Object.assign(u, { userData: { ...n, type: "PyramidGeometry" } });
  }
};
function ys(n, r, e) {
  e.x = n.x * r.x, e.y = n.y, e.z = n.x * r.y;
}
function md(n, r, e, t, o, i) {
  let s = r.clone().sub(n), l = e.clone().sub(n), c = s.angleTo(l);
  if (s.normalize(), l.normalize(), t === o) {
    let u = s.add(l).normalize();
    i.copy(n).addScaledVector(u, t / Math.sin(c / 2));
  } else {
    let u = s.angleTo(l);
    i.copy(n), i.addScaledVector(s, o / Math.sin(u)), i.addScaledVector(l, t / Math.sin(u));
  }
}
function UP(n, r, e) {
  let t = n.clone().sub(r), o = e.clone().sub(r);
  return t.projectOnVector(o), t.add(r);
}
var hd = class extends BufferGeometry {
  constructor(r = 0.5, e = 1, t = 4, o = 1, i = false, s = 0, l = 4) {
    super(), t = Math.floor(Math.max(3, t)), o = Math.floor(o), l = Math.floor(l);
    let c = [], u = [], a = [], d = [], p = 0, f = e / 2, m = Math.PI / t, h = r * Math.cos(Math.PI / t), y = 2 * Math.PI / t, g = (t - 2) * Math.PI / t, v = Math.PI - g, b = new Vector3(0, -f, 0), w = new Vector3(0, f, 0), S = new Vector2(r, -f), P = new Vector2(h, -f), _ = new Vector2(0, w.y).sub(P), x = new Vector2(0, w.y).sub(S), C = new Vector2(_.y, -_.x).normalize(), T = new Vector2(x.y, -x.x).normalize(), O = r * Math.cos(Math.PI / t) * Math.tan((Math.PI - _.angle()) / 2) - 1e-8;
    s = Math.min(s, O);
    let A;
    {
      let H = new Vector3(C.x, C.y, 0), V = new Vector3(Math.cos(y) * H.x, H.y, Math.sin(y) * H.x);
      A = H.angleTo(V);
    }
    let R = s / Math.tan((Math.PI - _.angle()) / 2), k = s / Math.tan((Math.PI - A) / 2), $ = new Vector3();
    if (!i) {
      u.push(b.x, b.y, b.z), a.push(0, -1, 0), d.push(0, 0);
      let H = p++, V = [], G = S.clone(), B = R / Math.cos(Math.PI / t);
      G.x -= B;
      for (let L = 0; L < t; L++) {
        let D = L / t * Math.PI * 2 + m, X = new Vector2(Math.sin(D), Math.cos(D));
        ys(G, X, $), u.push($.x, $.y, $.z), a.push(0, -1, 0), d.push(0, 0), V.push(p++);
      }
      for (let L = 0; L < V.length; L++)
        c.push(V[L], H, V[(L + 1) % V.length]);
    }
    let te = [];
    {
      let H = new Vector3(), V = new Vector3(), G = new Vector3(), B = new Vector3(), L = new Vector3(), D = new Vector3();
      for (let X = 0; X < t; X++) {
        let q = X / t * Math.PI * 2 + m, j = (X + 0.5) / t * Math.PI * 2 + m, F = (X + 1) / t * Math.PI * 2 + m, M = new Vector2(Math.sin(q), Math.cos(q)), Q = new Vector2(Math.sin(j), Math.cos(j)), re = new Vector2(Math.sin(F), Math.cos(F));
        ys(S, M, V), ys(S, re, G), ys(C, Q, H), md(w, V, G, k, k, B), u.push(B.x, B.y, B.z), md(V, w, G, k, R, L), u.push(L.x, L.y, L.z), md(G, V, w, R, k, D), u.push(D.x, D.y, D.z), a.push(H.x, H.y, H.z), a.push(H.x, H.y, H.z), a.push(H.x, H.y, H.z), d.push(0, 0), d.push(0, 0), d.push(0, 0);
        let oe = p++, K = p++, ee = p++;
        if (c.push(oe, K, ee), s > 0) {
          {
            let ce = V.clone().add(G).multiplyScalar(0.5), se = w.clone().sub(ce).normalize(), Re = b.clone().sub(ce).normalize().add(se).normalize().multiplyScalar(-1), ge = D.clone().sub(L);
            Y(ce, ge, Re, _.angle());
          }
          let J, ie;
          {
            let ce = new Vector3();
            ys(T, re, ce);
            let se = D.clone().add(B).multiplyScalar(0.5);
            se = UP(se, G, w);
            let fe = D.clone().sub(B);
            [J, ie] = Y(se, fe, ce, A, B.y);
          }
          {
            let ce = J, se = ce.clone().setY(0).normalize(), fe = new Vector3(0, -1, 0), Re = se.clone().cross(fe);
            W(ce, se, fe, Re);
          }
          te.concat(ie);
          {
            let ce = _.angle(), se = Math.PI - ce, fe = w.clone();
            fe.y -= s / Math.sin(ce - Math.PI / 2);
            let Re = new Vector3(), ge = [];
            for (let Te = 0; Te < l; Te++) {
              let wt = [], Ft = Math.PI / 2 - se * Te / l, Xo = Math.cos(Ft), Mt = Math.sin(Ft), Fs = j;
              for (let ks = 0; ks <= Te; ks++) {
                let Us = Math.cos(Fs), ke = Math.sin(Fs);
                H.x = Xo * ke, H.y = Mt, H.z = Xo * Us, Re.copy(fe).addScaledVector(H, s), u.push(Re.x, Re.y, Re.z), a.push(H.x, H.y, H.z), d.push(0, 0), wt.push(p++), Fs += Math.PI * 2 / Te / t;
              }
              ge.push(wt);
            }
            ie.reverse(), ge.push(ie);
            let qe = ge.length - 1;
            for (let Te = 0; Te < qe; Te++) {
              let wt = ge[Te], Ft = ge[Te + 1], Xo = wt.length - 1;
              c.push(Ft[1], wt[0], Ft[0]);
              for (let Mt = 1; Mt <= Xo; Mt++)
                c.push(wt[Mt], wt[Mt - 1], Ft[Mt]), c.push(Ft[Mt + 1], wt[Mt], Ft[Mt]);
            }
          }
        }
      }
    }
    this.setIndex(c), this.setAttribute("position", new Float32BufferAttribute(u, 3)), this.setAttribute("normal", new Float32BufferAttribute(a, 3)), this.setAttribute("uv", new Float32BufferAttribute(d, 2));
    function Y(H, V, G, B, L) {
      let D = -B / 2, X = (Math.PI - B) / 2, q = V.clone().normalize().cross(G);
      H.addScaledVector(G, -s / Math.sin(X));
      let j = new Vector3(), F = new Vector3(), M = 1, Q = p, re = [];
      for (let oe = 0; oe <= l; oe++) {
        let K = D + oe / l * B;
        F.set(0, 0, 0), F.addScaledVector(q, Math.sin(K)), F.addScaledVector(G, Math.cos(K));
        for (let ee = 0; ee <= M; ee++) {
          let J = ee / M - 0.5;
          if (j.copy(H), j.addScaledVector(V, J), j.addScaledVector(F, s), L != null) {
            let ie = Math.max(0, j.y - L);
            j.addScaledVector(V, -ie / V.y);
          }
          u.push(j.x, j.y, j.z), a.push(F.x, F.y, F.z), d.push(0, 0), ee === 0 && re.push(p), p++;
        }
      }
      for (let oe = 0; oe < l; oe++)
        for (let K = 0; K < M; K++) {
          let ee = Q + K + (M + 1) * oe, J = ee + (M + 1), ie = J + 1, ce = ee + 1;
          c.push(ee, J, ce), c.push(J, ie, ce);
        }
      return [H.clone().addScaledVector(V, 0.5), re];
    }
    function W(H, V, G, B) {
      let L = Math.PI / 2, D = x.angle() - L, X = [], q = new Vector3(), j = new Vector3();
      for (let M = 0; M <= l; M++) {
        let Q = [], re = M / l;
        for (let oe = 0; oe <= M; oe++) {
          let ee = ((M ? oe / M : 0) - 0.5) * v, J = Math.cos(ee), ie = Math.sin(ee), ce = Math.atan(Math.tan(D) * J), se = (L + ce) * re, fe = Math.cos(se), Re = Math.sin(se);
          q.set(0, 0, 0), q.addScaledVector(V, Re * J), q.addScaledVector(G, fe), q.addScaledVector(B, Re * ie), j.copy(H).addScaledVector(q, s), u.push(j.x, j.y, j.z), a.push(q.x, q.y, q.z), d.push(0, 0), Q.push(p++);
        }
        X.push(Q);
      }
      let F = X.length - 1;
      for (let M = 0; M < F; M++) {
        let Q = X[M], re = X[M + 1], oe = Q.length - 1;
        c.push(Q[0], re[1], re[0]);
        for (let K = 1; K <= oe; K++)
          c.push(Q[K - 1], Q[K], re[K]), c.push(Q[K], re[K + 1], re[K]);
      }
    }
  }
};
var gl = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, depth: 0, cornerRadius: [0, 0, 0, 0], cornerType: 1, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, n.parameters), t = Object.assign((r == null ? void 0 : r.ui) ?? { enabledIndieCorners: false }, n.ui);
    return { shape: n.shape && n.shape instanceof we ? n.shape : new we(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }), ui: t };
  }
  static build(n) {
    let r = n.shape, { width: e, height: t, cornerRadius: o, cornerType: i, depth: s, extrudeBevelSize: l, extrudeBevelSegments: c } = n.parameters, u = { x: e * 0.5, y: t * 0.5 }, a = { x: -u.x, y: -u.y }, d = { x: u.x, y: u.y };
    function p(w, S, P) {
      return S > e && P > t ? Math.min(w * e / S, w * t / P) : S > e ? w * e / S : P > t ? w * t / P : w;
    }
    let f = [];
    f[0] = o[0] === 0 ? 0 : p(o[0], o[0] + o[3], o[0] + o[1]), f[1] = o[1] === 0 ? 0 : p(o[1], o[1] + o[2], o[1] + o[0]), f[2] = o[2] === 0 ? 0 : p(o[2], o[2] + o[1], o[2] + o[3]), f[3] = o[3] === 0 ? 0 : p(o[3], o[3] + o[0], o[3] + o[2]);
    let m = a.x, h = d.x, y = d.y, g = a.y;
    r.addPoint(r.createPoint(m, y)), r.addPoint(r.createPoint(h, y)), r.addPoint(r.createPoint(h, g)), r.addPoint(r.createPoint(m, g)), r.isClosed = true;
    let v = true;
    for (let w = 0, S = r.points.length; w < S; w++)
      r.points[w].roundness = f[w], w > 0 && f[w] !== f[w - 1] && (v = false);
    v && (r.roundness = f[0]), r.useCubicForRoundedCorners = i !== 1, r.update();
    let b = At.create({ shape: r, parameters: { depth: s, extrudeBevelSize: l, extrudeBevelSegments: c } });
    return Object.assign(b, { userData: { ...n, type: "RectangleGeometry" } });
  }
};
var ey = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, widthSegments: 64, heightSegments: 64, phiStart: 0, phiLength: 2 * Math.PI, thetaStart: 0, thetaLength: Math.PI }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { width: r = 100, height: e = r, depth: t = r, widthSegments: o = 64, heightSegments: i = 64, phiStart: s, phiLength: l, thetaStart: c, thetaLength: u } = n.parameters, a = new SphereGeometry(0.5 * r, o, i, s, l, c, u);
    return a.scale(1, e / r, t / r), Object.assign(a, { userData: { ...n, type: "SphereGeometry" } });
  }
};
var ty = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, depth: 0, widthSegments: 8, heightSegments: 8 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: 0 }) };
  }
  static build(n) {
    let { width: r = 100, height: e = r, widthSegments: t = 8, heightSegments: o = 8 } = n.parameters, i = new PlaneGeometry(r, e, t, o);
    return i.scale(1, 1, 1), Object.assign(i, { userData: { ...n, type: "PlaneGeometry" } });
  }
};
var ry = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, angle: 90, cornerRadius: 24, cornerSegments: 8 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { width: r, height: e, depth: t, angle: o, cornerRadius: i, cornerSegments: s } = n.parameters, l = new gd(r, e, t, o, i, s);
    return Object.assign(l, { userData: { ...n, type: "BackdropGeometry" } });
  }
};
var gd = class extends BufferGeometry {
  constructor(r = 1, e = 1, t = 1, o = 90, i = 10, s = 24) {
    super(), this.type = "BackdropGeometry";
    let l = [], c = [], u = [], a = 1e-3;
    i == 0 && (s = 1), s = Math.max(1, Math.floor(s)), i = Math.min(i, 100), o = Math.min(180 - a, o), o *= Math.PI / 180;
    let d = [], p = Math.PI / 2, f = (j = 0, F = 0, M = 0) => new Vector3(j, F, M), m = f(), h = f(), [y, g, v] = [e / 2, r / 2, t / 2], b = -g, w = +g, [S, P, _] = [f(b, -y, +v), f(b, -y, -v), f(b, +y, -v)], x = (j, F = false) => Math.sin(j - Math.PI / (1 + +F)), C = (j, F = false) => Math.cos(j - Math.PI / (1 + +F));
    _.y = Math.sin(o) * e - y;
    let T = Math.cos(o) * e - v, N = S.z - a;
    o <= p ? (_.z = Math.min(T, N), _.z == N && (_.y -= (T - N) / Math.tan(p - o))) : P.z = Math.min(P.z - T - v, S.z - a), m.subVectors(S, P), h.subVectors(_, P);
    let O = Math.min(m.length(), h.length()) * i / 100, A = O * Math.tan(o / 2), R = O / Math.cos(o / 2), k = m.clone().normalize().add(h.normalize()).setLength(R).add(P);
    m.set(0, x(o, true), C(o, true)), d.push([_, m.clone()]);
    let $ = (Math.PI - o) / s;
    for (let j = 0; j <= s; j++) {
      let F = p + o + j * $;
      m.set(0, Math.sin(F) * A, Math.cos(F) * A), m.add(k), h.set(0, x(F), C(F)), d.push([m.clone(), h.clone()]);
    }
    d.push([S, f(0, 1, 0)]);
    let te = Math.sin($ / 2) * A * 2, Y = d.length - 1, W = d[0][0].distanceTo(d[1][0]), H = d[Y - 1][0].distanceTo(d[Y][0]), V = W + te * s + H;
    d[0].push(1);
    for (let j = 0; j <= s; j++)
      d[j + 1].push(1 - (W + j * te) / V);
    d[Y].push(0);
    let [G, B, L] = d[0], D, X, q;
    for (let j = 1; j < d.length; j++)
      [D, X, q] = d[j], l.push(b, G.y, G.z, b, D.y, D.z, w, G.y, G.z, w, G.y, G.z, b, D.y, D.z, w, D.y, D.z), c.push(0, B.y, B.z, 0, X.y, X.z, 0, B.y, B.z, 0, B.y, B.z, 0, X.y, X.z, 0, X.y, X.z), u.push(0, L, 0, q, 1, L, 1, L, 0, q, 1, q), [G, B, L] = [D, X, q];
    this.setAttribute("position", new Float32BufferAttribute(l, 3)), this.setAttribute("normal", new Float32BufferAttribute(c, 3)), this.setAttribute("uv", new Float32BufferAttribute(u, 2));
  }
};
var xl = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, depth: 0, innerRadiusPercent: 38.19, spikes: 5, cornerRadius: 0, angle: 360, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, n.parameters);
    return { shape: n.shape && n.shape instanceof we ? n.shape : new we(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }) };
  }
  static build(n) {
    let { width: r, height: e, innerRadiusPercent: t, spikes: o, cornerRadius: i, angle: s, depth: l, extrudeBevelSize: c, extrudeBevelSegments: u } = n.parameters, a = n.shape, d = r * 0.5, p = e * 0.5, f = 0, m = 0, h = s * Math.PI / 360 / o, y = Math.PI / 2 * 3 * -1, g = d * t / 100, v = p * t / 100;
    if (o === 3 && t === 50) {
      h = 2 * Math.PI / o;
      for (let w = 0; w < o; w++) {
        let S = h * w, P = f + Math.sin(S) * d, _ = m + Math.cos(S) * p;
        a.addPoint(a.createPoint(P, _));
      }
    } else
      for (let w = 0; w < o; w++) {
        let S = f + Math.cos(y) * d, P = m + Math.sin(y) * p;
        a.addPoint(a.createPoint(S, P)), y += h, S = f + Math.cos(y) * g, P = m + Math.sin(y) * v, w <= o, a.addPoint(a.createPoint(S, P)), y += h;
      }
    a.isClosed = true;
    for (let w = 0, S = a.points.length; w < S; w++)
      a.points[w].roundness = i;
    a.roundness = i, a.update();
    let b = At.create({ shape: a, parameters: { roundness: i, depth: l, extrudeBevelSize: c, extrudeBevelSegments: u } });
    return Object.assign(b, { userData: { ...n, type: "StarGeometry" } });
  }
};
var oy = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, depth: 0 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }) };
  }
  static build(n) {
    let { width: r, height: e } = n.parameters, t = new PlaneGeometry(r, e);
    return Object.assign(t, { userData: { ...n, type: "TextFrameGeometry" } });
  }
};
var ny = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, radialSegments: 32, tubularSegments: 64, arc: Math.PI * 2, cornerRadius: 30, cornerSegments: 8 }, n.parameters), t = Math.abs(e.width), o = Math.abs(e.height ?? e.width), i = Math.round(Math.abs(e.depth ?? e.width * 0.25));
    return { parameters: Object.assign(e, { width: t, height: o, depth: i }) };
  }
  static build(n) {
    let { width: r, height: e, depth: t, radialSegments: o, tubularSegments: i, arc: s, cornerRadius: l, cornerSegments: c } = n.parameters, u = XP(r, e, t, r * 0.5, s, i, 0, 0, o, l, c);
    return u.scale(1, e / r, 1), Object.assign(u, { userData: { ...n, type: "TorusGeometry" } });
  }
};
function XP(n, r, e, t, o, i, s, l, c, u, a) {
  return [r, e] = [e, r], s = r / 2, o /= 2 * Math.PI, o == 1 && (u = 0), new fs(true, n, r, e, t, o, i, s, l, c, u, a);
}
var iy = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, tubularSegments: 64, radialSegments: 32, p: 2, q: 3 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width), tube: e.tube ?? e.width * 0.125 }) };
  }
  static build(n) {
    let { width: r, tube: e, tubularSegments: t, radialSegments: o, p: i, q: s } = n.parameters, l = r * 0.5;
    l !== e && (l -= e);
    let c = new TorusKnotGeometry(l, e, t, o, i, s);
    return Object.assign(c, { userData: { ...n, type: "TorusKnotGeometry" } });
  }
};
var sy = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, depth: 0, spikes: 5, cornerRadius: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1, isRect: false }, n.parameters);
    return { shape: n.shape && n.shape instanceof we ? n.shape : new we(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width * (e.isRect ? 1 : Math.sqrt(3) / 2)), depth: Math.abs(e.depth ?? 0) }) };
  }
  static build(n) {
    let { width: r = 100, height: e, cornerRadius: t, depth: o, extrudeBevelSize: i, extrudeBevelSegments: s, isRect: l } = n.parameters, c = n.shape, u = r * 0.5, a = e * 0.5;
    l ? (c.addPoint(c.createPoint(-u, a)), c.addPoint(c.createPoint(u, -a)), c.addPoint(c.createPoint(-u, -a))) : (c.addPoint(c.createPoint(0, a)), c.addPoint(c.createPoint(u, -a)), c.addPoint(c.createPoint(-u, -a))), c.isClosed = true;
    for (let p = 0, f = c.points.length; p < f; p++)
      c.points[p].roundness = t;
    c.roundness = t, c.update();
    let d = At.create({ shape: c, parameters: { roundness: t, depth: o, extrudeBevelSize: i, extrudeBevelSegments: s } });
    return Object.assign(d, { userData: { ...n, type: "TriangleGeometry" } });
  }
};
function ay(n, r) {
  let e = 2 * Math.PI;
  return (n % e + e) % e === (r % e + e) % e;
}
function ZP(n, r, e) {
  let t = [new Vector3(), new Vector3(), new Vector3()], o = [new Vector3(), new Vector3(), new Vector3()];
  return n.extractBasis(t[0], t[1], t[2]), r.extractBasis(o[0], o[1], o[2]), t.forEach((i, s) => {
    let l = o[s], c = MathUtils.lerp(i.length(), l.length(), e);
    i.lerp(l, e).setLength(c);
  }), new Matrix4().makeBasis(t[0], t[1], t[2]);
}
var dy = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, height: 100, depth: 1, subdivisions: 12, roundness: 0, extrudeBevelSize: 0, extrudeBevelSegments: 3 }, n.parameters), t = Math.abs(e.width), o = Math.abs(e.height ?? e.width), i = Math.abs(e.depth ?? 0), s = (r == null ? void 0 : r.shapeData) ?? Yn.create({ parameters: Tc }).userData.shape;
    return { path: n.path ?? In.defaultData(), parameters: Object.assign(e, { width: t, height: o, depth: i, extrusion: { ...ka, ...e.extrusion } }), shapeData: s };
  }
  static build(n) {
    if (n.path.points.length >= 2) {
      let e = new bd(n);
      return Object.assign(e, { userData: { ...n, type: "PathGeometry" } });
    } else
      return Object.assign(new BufferGeometry(), { userData: { ...n, type: "PathGeometry" } });
  }
};
var bd = class extends BufferGeometry {
  constructor(e) {
    super();
    this.type = "PathExtrusionGeometry", this.inputs = e, this.build();
  }
  _isGeometryClosed() {
    return this.inputs.path.isClosed && this.inputs.parameters.extrusion.depth === 1;
  }
  _isOpenEnded() {
    let e = this.inputs.parameters.extrusion;
    return !(this.inputs.path.isClosed && e.depth === 1) || !ay(e.twist, 0) || e.startScale !== e.endScale;
  }
  build() {
    let e = this._extractPathPoints();
    if (e.length < 2)
      return;
    let t = this._computeBasisMatrices(e), { depth: o, offset: i } = this.inputs.parameters.extrusion, s = this.inputs.path.isClosed ? e.length : e.length - 1, l = Math.floor(i * s), c = this.inputs.path.isClosed ? Math.ceil((o + i) * s) : Math.ceil(Math.min(1, o + i) * s), u = Math.min(Math.max(2, c - l + 1), s + 2), a = [], d = [];
    for (let O = 0; O < u; O++) {
      let A = this.inputs.path.isClosed ? (O + l) % e.length : Math.min(O + l, e.length - 1);
      a.push(e[A].clone()), d.push(t[A].clone());
    }
    let p = (O, A, R) => {
      a[O] = a[O].clone().lerp(a[A], R), d[O] = ZP(d[O], d[A], R);
    }, f = 0, m = i * s % 1;
    (!this.inputs.path.isClosed || o <= 1) && (m || i === 0) && (f = m, p(0, 1, f));
    let h = 0, y = (i + o) * s % 1;
    if ((this.inputs.path.isClosed && o <= 1 || !this.inputs.path.isClosed && i + o < 1) && y && (h = y, p(a.length - 1, a.length - 2, 1 - h)), o === 0) {
      let O = a.length - 1;
      a[O].copy(a[0]), d[O].copy(d[0]);
    }
    this._applyPathModifiers(d, f, h);
    let { regions: g, infos: v, vertices: b } = this._computeShapePoints(5), w = 0, S = 0;
    v.sort((O, A) => O.start - A.start), v.forEach((O) => {
      O.verticesStart = w, O.verticesCount = O.continuous.reduce((A, R, k) => A + (k === 0 || !R ? 2 : 1), 0), S += O.verticesCount, w = S;
    });
    let P = S * u, _, x = 0;
    if (this._isOpenEnded()) {
      try {
        _ = ir({ windingRule: be.ODD, elementType: Ge.POLYGONS, polySize: 3, vertexSize: 2, strict: true, contours: g });
      } catch {
        _ = nd;
      }
      x = _.vertexCount;
    }
    let C = P + 2 * x, T = { positions: new Float32Array(C * 3), normals: new Float32Array(C * 3), uvs: new Float32Array(C * 2) }, N = [];
    v.forEach((O) => {
      this._extrudeRegion(O, b, d, a, T, N, this._isGeometryClosed() && !this._isOpenEnded());
    }), _ && (this._closeEnd(_, P, N, T, d[0], a[0], false), this._closeEnd(_, P + x, N, T, d[d.length - 1], a[a.length - 1], true)), this.setAttribute("position", new BufferAttribute(T.positions, 3)), this.setAttribute("normal", new BufferAttribute(T.normals, 3)), this.setAttribute("uv", new BufferAttribute(T.uvs, 2)), this.setIndex(N);
  }
  _extractPathPoints() {
    let t = Qa(this.inputs.path).getPoints(this.inputs.path.subdivisions);
    if (t.length < 2)
      return [];
    let o = [t[0]];
    return t.forEach((s) => {
      o[o.length - 1].distanceToSquared(s) > 1e-3 && o.push(s);
    }), this.inputs.path.isClosed && o[o.length - 1].distanceTo(o[0]) < 1e-3 && o.pop(), o;
  }
  _computeBasisMatrices(e) {
    let t = [], o = e.length, i = this.inputs.path.isClosed, s = new Vector3(), l = new Vector3(), c = new Vector3(), u = new Vector3(), a = new Vector3(0, 1, 0);
    for (let y = 0; y < o; y++) {
      let g = e[y], v;
      y === 0 ? v = i ? e[e.length - 2] : g.clone().multiplyScalar(2).sub(e[1]) : v = e[y - 1];
      let b;
      y === o - 1 ? b = i ? e[1] : g.clone().multiplyScalar(2).sub(e[y - 1]) : b = e[y + 1];
      let w = g.clone().sub(v).normalize(), S = b.clone().sub(g).normalize(), P = w.clone().add(S).normalize();
      c.copy(P), y === 0 && (P.equals(a) || P.clone().negate().equals(a)) && a.set(0, 0, 1);
      let _ = a.clone().cross(P).normalize(), x = P.clone().cross(_).normalize();
      a.copy(x), u.copy(_), y === 0 && (s.copy(x), l.copy(P));
      let C = new Matrix4().makeBasis(_, x, P);
      t.push(C);
    }
    let d = i ? l : c, p = i ? s : new Vector3(0, 1, 0), f = d.clone().cross(u).normalize(), m = Math.acos(p.dot(f));
    if (isNaN(m))
      return t;
    let h = p.clone().cross(f);
    d.dot(h) > 0 && (m *= -1);
    for (let y = 1; y < t.length; y++) {
      let g = new Matrix4().makeRotationZ(m * y / t.length);
      t[y].multiply(g);
    }
    return t;
  }
  _applyPathModifiers(e, t, o) {
    let i = e.length, { angle: s, twist: l, startScale: c, endScale: u } = this.inputs.parameters.extrusion, a = new Matrix4(), d = new Matrix4();
    return e.forEach((p, f) => {
      let m = f === 0 ? 0 : f === i - 1 ? 1 : (f - t) / (i - (o === 0 ? 0 : 1) - (t + (1 - o)));
      a.makeRotationZ(MathUtils.lerp(s, s + l, m));
      let h = MathUtils.lerp(c, u, m);
      d.makeScale(h, h, h), p.multiply(a).multiply(d);
    }), e;
  }
  _computeShapePoints(e = 12, t = be.ODD) {
    let o = this.inputs.shapeData, i = o.extractShapePointsToFlatArray([], e), s = o.shapeHoles.map((h) => {
      let y = h.extractShapePointsToFlatArray([], e), g = [];
      for (let v = y.length - 1; v >= 1; v -= 2) {
        let b = y[v - 1], w = y[v - 0];
        g.push(b, w);
      }
      return g;
    }), l;
    try {
      l = ir({ windingRule: t, elementType: Ge.BOUNDARY_CONTOURS, vertexSize: 2, strict: true, contours: [i] });
    } catch {
      l = ps;
    }
    let c;
    try {
      c = ir({ windingRule: be.ODD, elementType: Ge.BOUNDARY_CONTOURS, vertexSize: 2, strict: true, contours: [...s] });
    } catch {
      c = od;
    }
    if (!l)
      throw new Error("error generating geometry");
    let u = l.elementCount;
    if (c) {
      l.elementCount += c.elementCount;
      for (let h = 0; h < c.elements.length; h++) {
        let y = c.elements[h], g = h % 2 === 0 ? l.vertexCount : 0;
        l.elements.push(y + g);
      }
      for (let h = 0; h < c.vertexIndices.length; h++) {
        let y = c.vertexIndices[h], g = l.vertexCount;
        l.vertexIndices.push(y + g);
      }
      for (let h = 0; h < c.vertices.length; h++) {
        let y = c.vertices[h];
        l.vertices.push(y);
      }
    }
    let a = 1 / 0, d = -1 / 0, p = 1 / 0, f = -1 / 0;
    for (let h = 0, y = l.vertexCount; h < y; h++) {
      let g = h * 2, v = l.vertices[g + 0], b = l.vertices[g + 1];
      v < a && (a = v), v > d && (d = v), b < p && (p = b), b > f && (f = b);
    }
    let m = [];
    for (let h = l.elementCount - 1; h >= 0; h--) {
      let y = h >= u, g = h * 2, v = l.elements[g + 0], b = l.elements[g + 1], w = v + b, S = { start: v, count: b, normals: [], isHole: y, continuous: [], verticesStart: 0, verticesCount: 0 };
      m.push(S);
      let P = v, _ = w - 1, x = v + 1, C = o.roundedCurves.length;
      do {
        let T = P - v, N = l.vertices[_ * 2 + 0], O = l.vertices[_ * 2 + 1], A = l.vertices[P * 2 + 0], R = l.vertices[P * 2 + 1], k = l.vertices[x * 2 + 0], $ = l.vertices[x * 2 + 1], te = A - N, Y = R - O, W = Math.sqrt(te * te + Y * Y);
        te /= W, Y /= W;
        let H = A - k, V = R - $, G = Math.sqrt(H * H + V * V);
        H /= G, V /= G, S.normals[T * 2 + 0] = -V, S.normals[T * 2 + 1] = H;
        let B = l.vertexIndices[P];
        if (Array.isArray(B))
          S.continuous[T] = false;
        else {
          let [L, D] = o.getCurveIndexFromVertexId(B - 1, true);
          if (D > 0 && D < 1)
            S.continuous[T] = true;
          else {
            let X = D === 1 ? L + 1 : L - 1;
            X = (X + C) % C;
            let q = D === 1 ? 0 : 1, j = o.roundedCurves[L].getTangent(D), F = o.roundedCurves[X].getTangent(q);
            S.continuous[T] = j.dot(F) > 0.95;
          }
        }
        y && (S.normals[T * 2 + 0] *= -1, S.normals[T * 2 + 1] *= -1), [_, P, x] = [P, x, x + 1], x >= w && (x -= b);
      } while (x !== v + 1);
    }
    return { regions: [i, ...s], infos: m, vertices: l.vertices };
  }
  _insertVertex(e, t, o, i, s) {
    let l = t * 2, c = t * 3;
    e.positions[c + 0] = o.x, e.positions[c + 1] = o.y, e.positions[c + 2] = o.z, e.normals[c + 0] = i.x, e.normals[c + 1] = i.y, e.normals[c + 2] = i.z, e.uvs[l + 0] = s.x, e.uvs[l + 1] = s.y;
  }
  _extrudeRegion(e, t, o, i, s, l, c) {
    let u = new Vector3(), a = new Vector3(), d = new Vector3(), p = new Vector3(), f = new Vector2();
    o.forEach((h, y) => {
      let g = i[y], v = e.verticesStart * o.length + e.verticesCount * y;
      for (let b = 0; b < e.count; b++) {
        let w = (e.start + b) * 2;
        if (u.set(t[w + 0], t[w + 1], 0), d.copy(u).applyMatrix4(h).add(g), e.continuous[b])
          p.set(e.normals[b * 2 + 0], e.normals[b * 2 + 1], 0);
        else {
          let S = b == 0 ? (e.start + e.count - 1) * 2 : w - 2;
          a.set(t[S + 0], t[S + 1], 0), p.copy(u).sub(a), p.set(-p.y, p.x, 0), e.isHole || p.negate();
        }
        if (p.applyMatrix4(h).normalize(), f.set(b === 0 ? 1 : b / e.count, y / (o.length - 1)), this._insertVertex(s, v, d, p, f), v++, !e.continuous[b] || b === 0) {
          if (b === 0)
            p.set(e.normals[b * 2 + 0], e.normals[b * 2 + 1], 0), f.set(0, y / (o.length - 1));
          else {
            let S = b === e.count - 1 ? e.start * 2 : w + 2;
            a.set(t[S + 0], t[S + 1], 0), p.copy(a).sub(u), p.set(-p.y, p.x, 0), e.isHole || p.negate();
          }
          p.applyMatrix4(h).normalize(), this._insertVertex(s, v, d, p, f), v++;
        }
      }
    });
    let m = o.length - 1;
    for (let h = 0; h < m; h++) {
      let y = e.verticesStart * o.length + e.verticesCount * h, g = e.verticesStart * o.length + e.verticesCount * (h + 1), v = 0;
      for (let b = 0; b < e.count; b++) {
        (!e.continuous[b] || b === 0) && v++;
        let w = b === e.count - 1 ? 0 : v + 1, S = y + v, P = y + w, _ = g + w, x = g + v;
        e.isHole ? l.push(S, _, P, S, x, _) : l.push(S, P, _, S, _, x), v++;
      }
    }
  }
  _closeEnd(e, t, o, i, s, l, c) {
    let u = e.vertexCount, a = new Vector3(0, 0, c ? -1 : 1).applyMatrix4(s), d = new Vector3(), p = new Vector2();
    for (let m = 0; m < u; m++) {
      let h = 2 * m;
      d.set(e.vertices[h + 0], e.vertices[h + 1], 0).applyMatrix4(s).add(l), this._insertVertex(i, t + m, d, a, p);
    }
    let f = e.elements;
    for (let m = 0; m < e.elementCount; m++) {
      let h = 3 * m, y = f[h + 0] + t, g = f[h + (c ? 1 : 2)] + t, v = f[h + (c ? 2 : 1)] + t;
      o.push(y, g, v);
    }
  }
};
function py() {
  let n = new BufferGeometry();
  return n.setAttribute("position", new BufferAttribute(new Float32Array([]), 3)), n.setIndex(new BufferAttribute(new Uint16Array([]), 1)), n;
}
var JP = py().attributes;
var eT = 12;
var tT = 1;
var Qn = class extends BufferGeometry {
  constructor(e, t) {
    super();
    this.charWidths = [];
    this.charCoords = [];
    this.wrappedText = [];
    this.isLowResolution = false;
    this.vectorShapes = [];
    Object.assign(this.attributes, JP), this.userData = { parameters: e, type: "TextGeometry" };
    let o = t.getFont(e.font);
    (o == null ? void 0 : o.isLoaded) ? (this.font = o, this.update(e)) : this.updateFont(e.font, t).then(() => {
      this.update(e), t == null ? void 0 : t.requestRender();
    });
  }
  async updateFont(e, t) {
    let o = t.getFont(e);
    o && (this.font = o, await o.loadingPromise);
  }
  update(e) {
    let t = this.font;
    if (this.userData = { parameters: e, type: "TextGeometry" }, !(t == null ? void 0 : t.isLoaded)) {
      console.warn("Cannot update text because its font is not loaded");
      return;
    }
    let { width: o, height: i, depth: s, extrudeBevelSize: l, extrudeBevelSegments: c, text: u, textTransform: a } = e, d = a === 2 ? u.toUpperCase() : a === 3 ? u.toLowerCase() : u, p = rT(e, t, d), { shapes: f, charWidths: m, charCoords: h } = t.generateShapes(p, e), y = o * 0.5, g = i * 0.5, v = f.map((S) => new we().fromShape(S));
    this.vectorShapes = v;
    let b = v.map((S) => At.create({ shape: S, parameters: { depth: s, extrudeBevelSegments: c, extrudeBevelSize: l, windingRule: s <= 0 ? be.NONZERO : be.ODD, subdivisions: this.isLowResolution && s > 0 ? tT : eT } })), w = b.length ? mergeBufferGeometries(b) : py();
    w.translate(-y, g, 0), this.dispose(), this.wrappedText = p, this.charCoords = h, this.charWidths = m, this.deleteAttribute("extrudeNormal"), Object.entries(w.attributes).forEach(([S, P]) => {
      this.setAttribute(S, P);
    }), this.setIndex(w.index), this.computeBoundingSphere();
  }
  clone() {
    let e = Vr(new BufferGeometry(), Qn.prototype);
    return e.copy(this), console.log("CloneGeometry", this, e), e;
  }
  copy(e) {
    return Object.entries(e.attributes).forEach(([t, o]) => {
      this.setAttribute(t, o);
    }), this.setIndex(e.index), this.userData = { parameters: { ...e.userData.parameters }, type: "TextGeometry" }, this;
  }
  async setText(e) {
    this.font && await this.font.loadingPromise, await this.update({ ...this.userData.parameters, text: e });
  }
  get text() {
    return this.userData.parameters.text ?? "";
  }
};
function rT(n, r, e) {
  e = e ?? n.text;
  let t = [""], o = "";
  for (let i of e)
    o += i, i === " " || i === `
` ? (t[t.length - 1] += o, o = "", i === `
` && t.push("")) : r.getTextWidth(t[t.length - 1] + o, n) > n.width && (t[t.length - 1].length && t.push(""), r.getTextWidth(t[t.length - 1] + o, n) > n.width && (o.length === 1 ? (t[t.length - 1] += o, o = "") : (t[t.length - 1] += o.slice(0, -1), o = o[o.length - 1], t.push(""))));
  return t[t.length - 1] += o, t;
}
var my;
var ei = new Promise((n) => {
  my = n;
});
var fy = false;
async function hy() {
  if (fy)
    return;
  let r = false ? "." : "https://unpkg.com/@splinetool/modelling-wasm@0.9.374/build", [e, t] = await Promise.all([import("./process-T6PFDORN.js"), fetch(`${r}/process.wasm`).then((s) => s.arrayBuffer())]), o = e.default, i = await o({ wasmBinary: t });
  my(i), fy = true;
}
function Lo(n, r, e) {
  let t = { parameters: n, type: n.type };
  if (n.type === "PathGeometry")
    t.path = n.path;
  else if (n.type === "VectorGeometry") {
    let i = we.createFromState(n.shape, n.width, n.height);
    t.shape = i;
  } else if (n.type === "NonParametricGeometry")
    n.data.groups && n.data.groups.forEach((i) => i.materialIndex = Math.max(i.materialIndex ?? 0, 0)), t.geometry = new BufferGeometryLoader().parse(n);
  else {
    if (n.type === "SubdivGeometry")
      return new He(n, e);
    if (n.type === "TextGeometry")
      return new Qn(n, r);
  }
  let o;
  try {
    o = wd(t);
  } catch (i) {
    console.error(i);
  }
  if (!o) {
    let i = we.createFromState(Cn.defaultData(), 100, 100);
    t.shape = i, o = wd(t);
  }
  return o;
}
var iT = new Matrix4();
function xs(n, r, e, t) {
  let o = n.position.array, i = n.normal.array, s = iT.makeScale(r, e, t).invert().elements, l, c, u;
  for (var a = 0, d = o.length; a < d; a += 3)
    o[a] *= r, o[a + 1] *= e, o[a + 2] *= t, l = i[a], c = i[a + 1], u = i[a + 2], i[a] = s[0] * l + s[4] * c + s[8] * u, i[a + 1] = s[1] * l + s[5] * c + s[9] * u, i[a + 2] = s[2] * l + s[6] * c + s[10] * u;
  n.position.needsUpdate = true, n.normal.needsUpdate = true;
}
var vl = new Box3();
var ti = new Vector3();
var de;
ei.then((n) => {
  de = n;
});
var gy = new Float32Array([10, 10, 0, -10, 10, 0, -10, -10, 0, 10, -10, 0]);
var xy = new Uint32Array([0, 1, 2, 3]);
var vy = new Uint8Array([4]);
var He = class extends BufferGeometry {
  constructor(e, t) {
    super();
    this.data = e;
    this.flatShading = t;
    this.subdivPointer = 0;
    this.rebuild(), this.freeSubdivPointer();
  }
  mutateDirectlyScaleBaked(e, t) {
    this.freeSubdivPointer();
    let o = this.data.scaleBaked, i = ao.div(t, o);
    this.subdividedGeometry && xs(this.subdividedGeometry.attributes, ...i), this.originalGeometry && xs(this.originalGeometry.attributes, ...i), this.data = e;
    let s = this.userData.parameters;
    this.userData.parameters = { width: s.width * i[0], height: s.height * i[1], depth: s.depth * i[2] }, this.originalGeometry.boundingSphere.center.multiply(ti.fromArray(i));
    let l = ti.set(s.width, s.height, s.depth).length();
    this.originalGeometry.boundingSphere.radius = l / 2;
  }
  ensureSubdivPointer() {
    return this.subdivPointer === 0 && this.rebuild(), this.subdivPointer;
  }
  rebuild() {
    let e, t, o;
    try {
      ({ originalGeometry: e, subdividedGeometry: t, subdivPointer: o } = He.build(this.data, void 0, !this.flatShading, void 0));
    } catch {
      e = new BoxGeometry(100, 100, 100), o = 0;
    }
    this.subdivPointer = o, this.originalGeometry = e, this.subdividedGeometry = t ?? void 0;
    let i = this.subdividedGeometry ?? this.originalGeometry;
    Object.assign(this, i), this.calcBoundingBox();
  }
  freeSubdivPointer() {
    this.subdivPointer && (He.freeSubdivPointer(this.subdivPointer), this.subdivPointer = 0);
  }
  dispose() {
    super.dispose(), this.freeSubdivPointer();
  }
  calcBoundingBox() {
    let e = this.originalGeometry;
    e.boundingSphere === null && (e.boundingSphere = new Sphere(), this.subdividedGeometry && (this.subdividedGeometry.boundingSphere = e.boundingSphere));
    let t = e.attributes.position, o = e.boundingSphere.center;
    vl.setFromBufferAttribute(t), vl.getCenter(o), e.boundingSphere.radius = o.distanceTo(vl.max), isNaN(e.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this), vl.getSize(ti);
    let i = { width: ti.x, height: ti.y, depth: ti.z };
    return this.userData.parameters = i, i;
  }
  static build(e, t, o, i) {
    let s, l, c, u = (e == null ? void 0 : e.phongAngle) ?? 35;
    o === false && (u = -1), t && (de.free_bvh(t), de.free_subdivision_surface(t));
    try {
      s = He.allocate(e, i);
    } catch (a) {
      console.error(a, e), s = He.allocate({ positionWASM: gy, indexWASM: xy, verticesPerFaceWASM: vy }, i);
    }
    if (de.set_destination_refinement_level(s, 0), l = He.buildLevel(s, true, u), e.subdivisions > 0)
      try {
        de.set_destination_refinement_level(s, e.subdivisions), c = He.buildLevel(s, false, u);
      } catch {
        try {
          de.set_destination_refinement_level(s, e.subdivisions - 1), c = He.buildLevel(s, false, u);
        } catch {
          c = null;
        }
      }
    else
      c = null;
    return { subdivPointer: s, originalGeometry: l, subdividedGeometry: c };
  }
  static primitiveToQuads(e, t, o) {
    e.widthSegments > 16 && (e.widthSegments = 16), e.heightSegments > 16 && (e.heightSegments = 16), e.depthSegments > 16 && (e.depthSegments = 16), e.radialSegments > 16 && (e.radialSegments = 16), e.type === "DodecahedronGeometry" && (e.detail = 0);
    let i = e.shape !== void 0 ? t.geometry : Lo(e, o, false), s;
    e.type === "TorusGeometry" && e.arc === Math.PI * 2 ? s = i.getClosedTorusIndicesForBooleanOrSubdiv() : s = i.getIndex();
    let l, c, u, a;
    ({ positions: l, triIndices: a } = Cd(i.getAttribute("position"), s));
    let d;
    if (e.type === "CylinderGeometry" && e.cornerRadius === 0 && e.hollow === 0 && e.openEnded === false) {
      let p = e.radialSegments * e.heightSegments * 3 * 2, f = p + e.radialSegments * 3;
      d = [p, f];
    }
    return { indices: c, verticesPerFace: u } = Id(l, a, i, d), { positions: l, indices: c, verticesPerFace: u };
  }
  static allocate(e, t) {
    var _a2;
    let o, i, s, l = [], c = [];
    e.positionWASM && e.positionWASM.length > 0 ? (o = e.positionWASM, i = e.indexWASM, s = e.verticesPerFaceWASM) : (o = gy, i = xy, s = vy);
    let u = o.length, a = i.length, d = s.length, p = o.length + l.length + c.length, f = i.length + s.length, m = p * Float32Array.BYTES_PER_ELEMENT + f * Uint32Array.BYTES_PER_ELEMENT, h = p * Float32Array.BYTES_PER_ELEMENT, y = f * Uint32Array.BYTES_PER_ELEMENT, g = de._malloc(m), v = new Float32Array(de.HEAPF32.buffer, g, p), b = new Uint32Array(de.HEAPU32.buffer, g + h, f);
    v.set(o, 0), v.set(l, o.length), v.set(c, o.length + l.length), b.set(i, 0), b.set(s, i.length);
    let w;
    ((_a2 = e == null ? void 0 : e.scaleBaked) == null ? void 0 : _a2.some((P) => P !== 1)) && (w = new Matrix4().makeScale(...e.scaleBaked)), t && (w ? w.premultiply(t) : w = t);
    let S = w ? de.alloc_subdivision_surface2(g, u, g + h, a, g + h + i.length * Uint32Array.BYTES_PER_ELEMENT, d, w.elements) : de.alloc_subdivision_surface(g, u, g + h, a, g + h + i.length * Uint32Array.BYTES_PER_ELEMENT, d);
    return de._free(g), S;
  }
  static buildLevel(e, t, o, i, s) {
    let l = s ? de.get_mesh_data2(e, t ? de.Level.CONTROL : de.Level.REFINED, o, s.elements) : de.get_mesh_data(e, t ? de.Level.CONTROL : de.Level.REFINED, o), c = 8, u = de.HEAPU32.subarray(l >> 2, (l >> 2) + c), a = u.subarray(4, 4 + 4), d = 0, p = de.HEAPU32[u[d] >> 2], f = de.HEAPF32.subarray(p >> 2, (p >> 2) + a[d]);
    d++;
    let m = de.HEAPU32[u[d] >> 2], h = de.HEAPF32.subarray(m >> 2, (m >> 2) + a[d]);
    d++;
    let y = de.HEAPU32[u[d] >> 2], g = de.HEAPU32.subarray(y >> 2, (y >> 2) + a[d]);
    d++;
    let v = de.HEAPU32[u[d] >> 2], b = de.HEAPU32.subarray(v >> 2, (v >> 2) + a[d]);
    if (d++, i === void 0) {
      let w = new BufferGeometry();
      if (w.setIndex(new Uint32BufferAttribute(b, 1)), w.setAttribute("position", new Float32BufferAttribute(f, 3)), w.setAttribute("normal", new Float32BufferAttribute(h, 3)), t) {
        w.setAttribute("faceMap", new Uint32BufferAttribute(g, 1));
        let S = new Float32Array(h.length / 3 * 4).fill(0);
        w.setAttribute("color", new BufferAttribute(S, 4));
      }
      return de.free_mesh_data(l), w.userData.type = "SubdivGeometry", w;
    }
    i.getAttribute("position").copyArray(f), i.getAttribute("normal").copyArray(h), i.attributes.position.needsUpdate = true, i.attributes.normal.needsUpdate = true, de.free_mesh_data(l);
  }
  static freeSubdivPointer(e) {
    de.free_bvh(e), de.free_subdivision_surface(e);
  }
  static buildControlCageWireframe(e, t, o) {
    let i = de.get_wireframe_data_for_base_level(e), s = 4, l = de.HEAPU32.subarray(i >> 2, (i >> 2) + s), c = l.subarray(2, 2 + 2), u = 0, a = de.HEAPU32[l[u] >> 2], d = de.HEAPF32.subarray(a >> 2, (a >> 2) + c[u]);
    u++;
    let p = de.HEAPU32[l[u] >> 2], f = de.HEAPU32.subarray(p >> 2, (p >> 2) + c[u]);
    if (t === void 0) {
      let m = new BufferGeometry();
      m.setAttribute("position", new Float32BufferAttribute(d, 3));
      let h = new Float32Array(d.length);
      for (let y = 0, g = d.length; y < g; )
        h[y++] = o.r, h[y++] = o.g, h[y++] = o.b;
      return m.setAttribute("color", new BufferAttribute(h, 3)), m.setIndex(new Uint32BufferAttribute(f, 1)), de.free_wireframe_data_for_base_level(i), m;
    }
    t.getAttribute("position").copyArray(d), t.attributes.position.needsUpdate = true, de.free_wireframe_data_for_base_level(i);
  }
  static updateCollabMesh(e, t, o) {
    let i = t === 0;
    i || de.set_destination_refinement_level(e, t);
    let s = o ? de.get_topological_data2(e, i ? de.Level.CONTROL : de.Level.REFINED, o.elements) : de.get_topological_data(e, i ? de.Level.CONTROL : de.Level.REFINED), l = 6, c = de.HEAPU32.subarray(s >> 2, (s >> 2) + l), u = c.subarray(3, 3 + 3), a = 0, d = de.HEAPU32[c[a] >> 2], p = new Float32Array(de.HEAPF32.subarray(d >> 2, (d >> 2) + u[a]));
    a++;
    let f = de.HEAPU32[c[a] >> 2], m = new Uint32Array(de.HEAPU32.subarray(f >> 2, (f >> 2) + u[a]));
    a++;
    let h = de.HEAPU32[c[a] >> 2], y = new Uint8Array(de.HEAPU32.subarray(h >> 2, (h >> 2) + u[a]));
    return de.free_topological_data(s), { positions: p, indices: m, verticesPerFace: y };
  }
};
var by = ["getX", "getY", "getZ"];
function Cd(n, r) {
  let e = {}, t = r ? r.count : n.count, o = 0, i = [], s = [], l = 1e4;
  for (let u = 0; u < t; u++) {
    let a = r ? r.getX(u) : u, d = "";
    for (let p = 0; p < 3; p++)
      d += `${~~(n[by[p]](a) * l)},`;
    if (d in e)
      i.push(e[d]);
    else {
      for (let p = 0; p < 3; p++)
        s.push(n[by[p]](a));
      e[d] = o, i.push(o), o++;
    }
  }
  let c = [];
  for (let u = 0; u < i.length; u += 3)
    i[u] === i[u + 1] || i[u] === i[u + 2] || i[u + 1] === i[u + 2] || c.push(i[u], i[u + 1], i[u + 2]);
  return { positions: s, triIndices: c };
}
var bl = new Vector3();
var Od = new Vector3();
var Ad = new Vector3();
var Nd = new Vector3();
function Id(n, r, e, t) {
  let o = [], i = [];
  if (e.userData.shape !== void 0 && e.userData.parameters.depth === 0 && e.userData.shape.shapeHoles.length === 0) {
    let s = e.userData.shape.extractShapePointsToFlatArray([]), l = e.userData.parameters.spikes;
    if (e.userData.type === "EllipseGeometry" && l <= 24 && l % 4 === 0 && e.userData.parameters.angle >= 360) {
      let a = s.length / 2 / l;
      s = s.filter((d, p) => Math.floor(p / 2) % a === 0);
    }
    let c = 0;
    for (let a = 0; a < s.length; a += 2)
      c += (s[a] - s[(a === 0 ? s.length : a) - 2]) * (s[a + 1] + s[(a === 0 ? s.length : a) - 1]);
    n.length = 0;
    let u = 0;
    if (c < 0)
      for (let a = 0; a < s.length; a += 2)
        n.push(s[a], s[a + 1], 0), o.push(u++);
    else
      for (let a = s.length - 2; a >= 0; a -= 2)
        n.push(s[a], s[a + 1], 0), o.push(u++);
    return i.push(u), { indices: o, verticesPerFace: i };
  }
  for (let s = 0, l = e.capStartIndex ?? r.length; s < l; )
    if (r[s + 1] === r[s + 3] && r[s + 2] === r[s + 5] || r[s + 0] === r[s + 3] && r[s + 2] === r[s + 4]) {
      bl.set(n[r[s] * 3], n[r[s] * 3 + 1], n[r[s] * 3 + 2]), Od.set(n[r[s + 1] * 3], n[r[s + 1] * 3 + 1], n[r[s + 1] * 3 + 2]), Ad.set(n[r[s + 4] * 3], n[r[s + 4] * 3 + 1], n[r[s + 4] * 3 + 2]), Nd.set(n[r[s + 5] * 3], n[r[s + 5] * 3 + 1], n[r[s + 5] * 3 + 2]), Od.sub(bl).normalize(), Ad.sub(bl).normalize(), Nd.sub(bl).normalize();
      let c = Od.cross(Ad).dot(Nd);
      Math.abs(c) > 5e-3 || t && t.some((u, a) => a % 2 === 1 ? false : s >= t[a] && s < t[a + 1]) ? (o.push(r[s], r[s + 1], r[s + 2]), i.push(3), s += 3) : (o.push(r[s], r[s + 1], r[s + 4], r[s + 5]), i.push(4), s += 6);
    } else
      o.push(r[s], r[s + 1], r[s + 2]), i.push(3), s += 3;
  if (e.capStartIndex !== void 0) {
    let s = [], l = [], c = 0, u = new Float32Array([e.userData.parameters.depth])[0];
    for (let a = 0, d = 0; a < n.length; a += 3, d++)
      n[a + 2] === 0 && (s.push(d), c++), n[a + 2] === u && l.push(d);
    if (e.userData.parameters.extrudeBevelSize === 0) {
      let a = l[0];
      l[0] = l[1], l[1] = a;
    }
    s.reverse(), o.push(...s, ...l), i.push(c, c);
  }
  return { indices: o, verticesPerFace: i };
}
var sr = {};
h0(sr, { calcBoolean: () => mT, calcBooleanTopological: () => fT, freeMeshSet: () => gT, getMeshSet: () => hT, transformMeshSet: () => yT });
var dT;
var Sy = new Promise((n) => {
  dT = n;
});
var xe;
var ri;
Sy.then((n) => xe = n);
function pT(n, r, e) {
  let t, o;
  n.userData.parameters.type === "TorusGeometry" && n.userData.parameters.arc === Math.PI * 2 ? o = n.getClosedTorusIndicesForBooleanOrSubdiv() : o = n.getIndex();
  let { positions: i, triIndices: s } = Cd(n.getAttribute("position"), o), l;
  if (r && e) {
    let { indices: c, verticesPerFace: u } = Id(i, s, n);
    l = u.length, t = [];
    for (let a = 0, d = 0; a < l; a++) {
      t.push(u[a]);
      for (let p = 0; p < u[a]; p++)
        t.push(c[d++]);
    }
  } else {
    let c = s.length;
    t = Array(c + c / 3), l = 0;
    for (let u = 0, a = 0; a < t.length; )
      t[a++] = 3, l++, t[a++] = s[u++], t[a++] = s[u++], t[a++] = s[u++];
  }
  return { positions: i, faceIndices: t, nFaces: l };
}
function _y(n) {
  let r = n.length, e = r * Uint32Array.BYTES_PER_ELEMENT, t = r * Float32Array.BYTES_PER_ELEMENT, o = Number.isInteger(n[0]) ? e : t, i = xe._malloc(o);
  return (Number.isInteger(n[0]) ? new Uint32Array(xe.HEAPU32.buffer, i, r) : new Float32Array(xe.HEAPF32.buffer, i, r)).set(n, 0), i;
}
function Py(n) {
  switch (n) {
    case 0:
      return xe.OP.UNION;
    case 1:
      return xe.OP.INTERSECTION;
    case 2:
      return xe.OP.A_MINUS_B;
    case 3:
      return xe.OP.B_MINUS_A;
    case 4:
      return xe.OP.SYMMETRIC_DIFFERENCE;
    case 5:
      return xe.OP.ALL;
    default:
      throw new Error("Unknown boolean operation " + n);
  }
}
function fT(n, r) {
  ri === void 0 && (ri = xe.init_csg());
  let e = _y(n), t = xe.csg_calc_topological(ri, e, n.length, Py(r));
  xe._free(e);
  let o = 6, i = xe.HEAPU32.subarray(t >> 2, (t >> 2) + o), s = i.subarray(3, 3 + 3), l = 0, c = xe.HEAPU32[i[l] >> 2], u = new Float32Array(xe.HEAPF32.subarray(c >> 2, (c >> 2) + s[l]));
  l++;
  let a = xe.HEAPU32[i[l] >> 2], d = new Uint32Array(xe.HEAPU32.subarray(a >> 2, (a >> 2) + s[l]));
  l++;
  let p = xe.HEAPU32[i[l] >> 2], f = new Uint8Array(xe.HEAPU32.subarray(p >> 2, (p >> 2) + s[l]));
  return xe.free_mesh_data(t), { positions: u, indices: d, verticesPerFace: f };
}
function mT(n, r, e, t) {
  ri === void 0 && (ri = xe.init_csg());
  let o = _y(n), i = xe.csg_calc(ri, o, n.length, t, Py(r));
  xe._free(o);
  let s = 5, l = xe.HEAPU32.subarray(i >> 2, (i >> 2) + s), c = l.subarray(2, 2 + 3), u = 0, a = xe.HEAPU32[l[u] >> 2], d = xe.HEAPF32.subarray(a >> 2, (a >> 2) + c[u]);
  u++;
  let p = xe.HEAPU32[l[u] >> 2], f = xe.HEAPF32.subarray(p >> 2, (p >> 2) + c[u]);
  u++;
  let m = c[u];
  e.setAttribute("position", new Float32BufferAttribute(d, 3)), e.setAttribute("normal", new Float32BufferAttribute(f, 3));
  let h = xe.HEAPF32.subarray((i >> 2) + 5, (i >> 2) + 5 + 6);
  return e.boundingSphere === null && (e.boundingSphere = new Sphere()), e.boundingSphere.center.set(h[0], h[1], h[2]), e.boundingSphere.radius = (h[3] ** 2 + h[4] ** 2 + h[5] ** 2) ** 0.5, e.userData.parameters = { width: h[3] * 2, height: h[4] * 2, depth: h[5] * 2 }, xe.free_mesh_data(i), m;
}
function hT(n, r, e) {
  if (xe === void 0)
    return -1;
  let t, o, i;
  if (r && n.userData.positions !== void 0) {
    let y = n.userData;
    i = y.verticesPerFace.length, t = y.positions, o = Array(y.verticesPerFace.reduce((g, v) => g + v, 0) + i);
    for (let g = 0, v = 0, b = 0; g < y.verticesPerFace.length; g++) {
      o[b++] = y.verticesPerFace[g];
      for (let w = 0; w < y.verticesPerFace[g]; w++)
        o[b++] = y.indices[v++];
    }
  } else
    ({ positions: t, faceIndices: o, nFaces: i } = pT(n, r, e));
  let s = t.length, l = o.length, c = t.length, u = o.length, a = c * Float32Array.BYTES_PER_ELEMENT + u * Uint32Array.BYTES_PER_ELEMENT, d = c * Float32Array.BYTES_PER_ELEMENT, p = u * Uint32Array.BYTES_PER_ELEMENT, f = xe._malloc(a), m = new Float32Array(xe.HEAPF32.buffer, f, c), h = new Uint32Array(xe.HEAPU32.buffer, f + d, u);
  return m.set(t, 0), h.set(o, 0), xe.get_csg_mesh(f, s, f + d, l, i);
}
function yT(n, r) {
  xe.transform_csg_mesh(n, r.elements);
}
function gT(n) {
  xe.free_csg_mesh(n);
}
var xT = { ConeGeometry: ah, CubeGeometry: lh, CylinderGeometry: sh, DodecahedronGeometry: ch, EllipseGeometry: Yn, HelixGeometry: jh, IcosahedronGeometry: Fh, LatheGeometry: kh, NonParametricGeometry: Qh, PolygonGeometry: yl, PyramidGeometry: Jh, RectangleGeometry: gl, SphereGeometry: ey, PlaneGeometry: ty, BackdropGeometry: ry, StarGeometry: xl, TextFrameGeometry: oy, TorusGeometry: ny, TorusKnotGeometry: iy, TriangleGeometry: sy, PathGeometry: dy, VectorGeometry: At };
var wd = (n) => xT[n.type].create(n);
function bs(n) {
  return n !== null && "booleanOp" in n;
}
var oi = class extends el(Mesh) {
  constructor() {
    super(...arguments);
    this.booleanMeshSetAddress = -1;
    this.booleanWasTransformed = false;
    this.booleanMatrixInvOld = new Matrix4();
  }
  updateVisible() {
    super.updateVisible(), this.visible = !bs(this.parent) && this.visible, bs(this.parent) && this.parent.invalidateDownstreamBooleanData();
  }
  freeBooleanPointer() {
    this.booleanMeshSetAddress !== -1 && (sr.freeMeshSet(this.booleanMeshSetAddress), this.booleanMeshSetAddress = -1);
  }
  invalidateDownstreamBooleanData(e = false) {
    return e ? this.booleanWasTransformed = true : this.freeBooleanPointer(), bs(this.parent) ? this.parent.invalidateDownstreamBooleanData() : this;
  }
  invalidateUpstreamBooleanData() {
    this.freeBooleanPointer();
    for (let e of this.children)
      e instanceof oi && (e.freeBooleanPointer(), bs(e) && e.invalidateUpstreamBooleanData());
  }
  updateTransformState(e) {
    let t = super.updateTransformState(e);
    return t && bs(this.parent) && this.invalidateDownstreamBooleanData(true), t;
  }
};
var Sl = new Box3();
function Ss(n, r = 0, e = n.count, t, o) {
  let i = 1 / 0, s = 1 / 0, l = 1 / 0, c = -1 / 0, u = -1 / 0, a = -1 / 0;
  for (let d = r; d < e; d++) {
    let p = n.getX(d), f = n.getY(d), m = n.getZ(d);
    p < i && (i = p), f < s && (s = f), m < l && (l = m), p > c && (c = p), f > u && (u = f), m > a && (a = m);
  }
  Sl.min.set(i, s, l), Sl.max.set(c, u, a), Sl.getCenter(t), Sl.getSize(o).multiplyScalar(0.5);
}
var PT = new BufferGeometry();
var TT = new MeshBasicMaterial();
var dt = class extends oi {
  constructor(r, e) {
    super(PT, TT), this.super_Entity(r, e);
  }
  updateState(r, e) {
    this.updateState_Entity(r, e);
  }
  updateEntityBoxSize(r, e) {
    let t = this.geometry.getAttribute("position");
    t !== void 0 ? Ss(t, this.geometry.drawRange.start, this.geometry.drawRange.count < 1 / 0 ? this.geometry.drawRange.count : t.count, r, e) : super.updateEntityBoxSize(r, e);
  }
};
var ws = class {
  constructor(r) {
    r = r ?? {}, this.name = r.name, this.type = r.type, this.node = r.node, this.size = r.size, this.needsUpdate = r.needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(r) {
    this.node.value = r;
  }
};
var rt = class {
  constructor(r) {
    this.hashProperties = void 0;
    this.isNode = true;
    this.shortcuts = {};
    this.uuid = MathUtils.generateUUID(), this.type = r, this.name = "";
  }
  analyze(r, e) {
    e = e ?? {}, r.analyzing = true, this.build(r.addFlow(e.slot, e.cache, e.context), "v4"), r.clearVertexNodeCode(), r.clearFragmentNodeCode(), r.removeFlow(), r.analyzing = false;
  }
  analyzeAndFlow(r, e, t) {
    return t = t ?? {}, this.analyze(r, t), this.flow(r, e, t);
  }
  flow(r, e, t) {
    t = t ?? {}, r.addFlow(t.slot, t.cache, t.context);
    let o = { result: this.build(r, e), code: r.clearNodeCode(), extra: r.context.extra };
    return r.removeFlow(), o;
  }
  build(r, e, t) {
    e = e ?? this.getType(r, e);
    let o = r.getNodeData(t ?? this);
    return r.analyzing && this.appendDepsNode(r, o, e), r.nodes.indexOf(this) === -1 && r.nodes.push(this), this.updateFrame !== void 0 && r.updaters.indexOf(this) === -1 && r.updaters.push(this), this.generate(r, e, t);
  }
  updateFrame(r) {
  }
  generateReadonly(r, e, t, o, i, s) {
    return "";
  }
  generate(r, e, t, o, i) {
    return "";
  }
  parse(r, e, t, o) {
  }
  appendDepsNode(r, e, t) {
    e.deps = (e.deps || 0) + 1;
    let o = r.getTypeLength(t);
    (o > (e.outputMax || 0) || this.getType(r, t)) && (e.outputMax = o, e.output = t);
  }
  setName(r) {
    this.name = r;
  }
  getName() {
    return this.name;
  }
  getType(r, e) {
    return e === "sampler2D" || e === "samplerCube" ? e : this.type;
  }
  getHash() {
    let r = "{", e, t;
    for (e in this)
      t = this[e], t instanceof rt && (r += '"' + e + '":' + t.getHash() + ",");
    if (this.hashProperties)
      for (let o = 0; o < this.hashProperties.length; o++)
        e = this.hashProperties[o], t = this[e], r += '"' + e + '":"' + String(t) + '",';
    return r += '"id":"' + this.uuid + '"}', r;
  }
};
var Md = class {
  constructor() {
    this.nodes = {};
    this.keywords = {};
  }
  add(r) {
    this.nodes[r.name] = r;
  }
  addKeyword(r, e, t) {
    t = t !== void 0 ? t : true, this.keywords[r] = { callback: e, cache: t };
  }
  remove(r) {
    delete this.nodes[r.name];
  }
  removeKeyword(r) {
    delete this.keywords[r];
  }
  get(r) {
    return this.nodes[r];
  }
  getKeyword(r, e) {
    return this.keywords[r].callback(e);
  }
  getKeywordData(r) {
    return this.keywords[r];
  }
  contains(r) {
    return this.nodes[r] !== void 0;
  }
  containsKeyword(r) {
    return this.keywords[r] !== void 0;
  }
};
var Xe = new Md();
var ae = class extends rt {
  constructor(e, t) {
    super(e);
    this.scope = "";
    t = t ?? {}, this.shared = t.shared !== void 0 ? t.shared : true, this.unique = t.unique !== void 0 ? t.unique : false;
  }
  build(e, t, o, i) {
    if (t = t ?? this.getType(e), this.getShared(e, t)) {
      let s = this.getUnique(e, t);
      s && this.uuid === void 0 && (this.uuid = MathUtils.generateUUID()), o = e.getUUID(o ?? this.getUUID(), !s);
      let l = e.getNodeData(o), c = l.output || this.getType(e);
      if (e.analyzing)
        return (l.deps || 0) > 0 || this.getLabel() ? (this.appendDepsNode(e, l, t), this.generate(e, t, o)) : super.build(e, t, o);
      if (s)
        return l.name = l.name || super.build(e, t, o), l.name;
      if (!this.getLabel() && (!this.getShared(e, c) || e.context.ignoreCache || l.deps === 1))
        return super.build(e, t, o);
      o = this.getUUID(false);
      let u = this.getTemp(e, o);
      if (u)
        return e.format(u, c, t);
      {
        u = super.generate(e, t, o, l.output, i);
        let a = this.generate(e, c, o);
        return e.addNodeCode(u + " = " + a + ";"), e.format(u, c, t);
      }
    }
    return super.build(e, t, o);
  }
  getShared(e, t) {
    return t !== "sampler2D" && t !== "samplerCube" && this.shared;
  }
  getUnique(e, t) {
    return this.unique;
  }
  setLabel(e) {
    return this.label = e, this;
  }
  getLabel() {
    return this.label;
  }
  getUUID(e) {
    let t = this.uuid;
    return typeof this.scope == "string" && (t = this.scope + "-" + t), t;
  }
  getTemp(e, t) {
    t = t || this.uuid;
    let o = e.getVars()[t];
    return o ? o.name : void 0;
  }
  generate(e, t, o, i, s) {
    return this.getShared(e, t) || console.error("TempNode is not shared"), o = o ?? this.uuid, e.getTempVar(o, i ?? this.getType(e), s, this.getLabel()).name;
  }
};
var Ne = class extends ae {
  constructor(e, t) {
    t = t ?? {}, t.shared = t.shared !== void 0 ? t.shared : false;
    super(e, t);
    this.readonly = false;
  }
  setReadonly(e) {
    return this.readonly = e, this.hashProperties = this.readonly ? ["value"] : void 0, this;
  }
  getReadonly() {
    return this.readonly;
  }
  generate(e, t, o, i, s, l) {
    o = e.getUUID(o ?? this.getUUID()), i = i ?? this.getType(e);
    let c = e.getNodeData(o);
    return this.getReadonly() && this.generateReadonly !== void 0 ? this.generateReadonly(e, t, o, i, s, l) : e.isShader("vertex") ? (c.vertex || (c.vertex = e.createVertexUniform(i, this, s, l, this.getLabel())), e.format(c.vertex.name, i, t)) : (c.fragment || (c.fragment = e.createFragmentUniform(i, this, s, l, this.getLabel())), e.format(c.fragment.name, i, t));
  }
};
var je = class extends Ne {
  constructor(e = 0, t) {
    super("v2");
    this.nodeType = "Vector2";
    this.value = e instanceof Vector2 ? e : new Vector2(e, t);
  }
  get x() {
    return this.value.x;
  }
  set x(e) {
    this.value.x = e;
  }
  get y() {
    return this.value.y;
  }
  set y(e) {
    this.value.y = e;
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format("vec2(" + this.value.x + ", " + this.value.y + ")", i, t);
  }
};
var ut = class extends Ne {
  constructor(e = 0, t, o) {
    super("v3");
    this.nodeType = "Vector3";
    this.value = e instanceof Vector3 ? e : new Vector3(e, t, o);
  }
  get x() {
    return this.value.x;
  }
  set x(e) {
    this.value.x = e;
  }
  get y() {
    return this.value.y;
  }
  set y(e) {
    this.value.y = e;
  }
  get z() {
    return this.value.z;
  }
  set z(e) {
    this.value.z = e;
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format("vec3(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ")", i, t);
  }
};
var Ke = class extends Color {
  constructor(e, t, o, i) {
    super(e, t, o);
    this.isColorA = true;
    this.a = i;
  }
  setRGBA(e, t, o, i) {
    super.setRGB(e, t, o), this.a = i;
  }
  copy(e) {
    return super.copy(e), this.a = "a" in e ? e.a : 1, this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
  setStyle(e, t = "srgb") {
    let o;
    if (e === "transparent")
      return this.setRGBA(0, 0, 0, 0), this;
    if (o = /^((?:rgb|hsl)a?)\(([^)]*)\)/.exec(e)) {
      let i, s = o[1], l = o[2];
      switch (s) {
        case "rgb":
        case "rgba":
          if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return this.a = s === "rgba" ? parseFloat(i[4]) : 1, super.setStyle(e, t);
          break;
        case "hsl":
        case "hsla":
          if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)%\s*,\s*(\d*\.?\d+)%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return this.a = s === "hsla" ? parseFloat(i[4]) : 1, super.setStyle(e, t);
          break;
      }
    }
    return super.setStyle(e, t);
  }
  get x() {
    return this.r;
  }
  get y() {
    return this.g;
  }
  get z() {
    return this.b;
  }
  get w() {
    return this.a;
  }
  set x(e) {
    this.r = e;
  }
  set y(e) {
    this.g = e;
  }
  set z(e) {
    this.b = e;
  }
  set w(e) {
    this.a = e;
  }
};
var Nt = class extends Ne {
  constructor(e) {
    super("v4");
    this.nodeType = "Vector4";
    this.value = e instanceof Ke ? e : new Ke(e.r, e.g, e.b, e.a);
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format("vec4(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ", " + this.value.a + ")", i, t);
  }
};
var CT = /^\s*([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i;
var Ay = /[a-z_0-9]+/gi;
var U = class extends ae {
  constructor(e, t, o, i, s) {
    super(s);
    this.src = "";
    this.nodeType = "Function";
    this.useKeywords = true;
    this.includes = [];
    this.extensions = {};
    this.keywords = {};
    this.isMethod = s === void 0, this.isInterface = false, this.parse(e, t, o, i);
  }
  getShared(e, t) {
    return !this.isMethod;
  }
  getType(e) {
    return e.getTypeByFormat(this.type);
  }
  getInputByName(e) {
    if (this.inputs) {
      let t = this.inputs.length;
      for (; t--; )
        if (this.inputs[t].name === e)
          return this.inputs[t];
    }
  }
  getIncludeByName(e) {
    if (this.includes) {
      let t = this.includes.length;
      for (; t--; )
        if (this.includes[t].name === e)
          return this.includes[t];
    }
  }
  generate(e, t, o, i, s) {
    let l, c = 0, u = this.src;
    if (this.includes)
      for (let d = 0; d < this.includes.length; d++)
        e.include(this.includes[d], this);
    for (let d in this.extensions)
      e.extensions[d] = true;
    let a = [];
    for (; l = Ay.exec(this.src); )
      a.push(l);
    for (let d = 0; d < a.length; d++) {
      let p = a[d], f = p[0], m = this.isMethod ? !this.getInputByName(f) : true, h = f;
      if (this.keywords[f] || this.useKeywords && m && Xe.containsKeyword(f)) {
        let y = this.keywords[f];
        if (!y) {
          let g = Xe.getKeywordData(f);
          g.cache && (y = e.keywords[f]), y = y || Xe.getKeyword(f, e), g.cache && (e.keywords[f] = y);
        }
        h = y.build(e);
      }
      f !== h && u[p.index + c - 1] !== "." && (u = u.substring(0, p.index + c) + h + u.substring(p.index + f.length + c), c += h.length - f.length), this.getIncludeByName(h) === void 0 && Xe.contains(h) && e.include(Xe.get(h));
    }
    return t === "source" ? u : this.isMethod ? (this.isInterface || e.include(this, void 0, u), this.name) : e.format("( " + u + " )", this.getType(e), t);
  }
  parse(e, t, o, i) {
    if (this.src = e || "", this.includes = t ?? [], this.extensions = o ?? {}, this.keywords = i ?? {}, this.isMethod) {
      let s = CT.exec(this.src);
      if (this.inputs = [], s && s.length == 4) {
        this.type = s[1], this.name = s[2];
        let l = s[3].match(Ay);
        if (l) {
          let c = 0;
          for (; c < l.length; ) {
            let u = l[c++], a;
            u === "in" || u === "out" || u === "inout" ? a = l[c++] : (a = u, u = "");
            let d = l[c++];
            this.inputs.push({ name: d, type: a, qualifier: u });
          }
        }
        this.isInterface = this.src.indexOf("{") === -1;
      } else
        this.type = "", this.name = "";
    }
  }
};
var IT = /^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i;
var Ed = class extends ae {
  constructor(e = "", t) {
    super();
    this.src = "";
    this.useDefine = false;
    this.nodeType = "Const";
    this.parse(e || Ed.PI, void 0, void 0, void 0, t);
  }
  getType(e) {
    return e.getTypeByFormat(this.type);
  }
  parse(e, t, o, i, s) {
    this.src = e || "";
    let l, c, u = "", a = IT.exec(e);
    this.useDefine = s ?? this.src.charAt(0) === "#", a && a.length > 1 ? (c = a[1], l = a[2], u = a[3]) : (l = this.src, c = "f"), this.name = l, this.type = c, this.value = u;
  }
  build(e, t) {
    if (t === "source") {
      if (this.value)
        return this.useDefine ? "#define " + this.name + " " + this.value : "const " + this.type + " " + this.name + " = " + this.value + ";";
      if (this.useDefine)
        return this.src;
    }
    return e.include(this), e.format(this.name, this.getType(e), t);
  }
  generate(e, t, o, i, s) {
    return e.format(this.name, this.getType(e), t);
  }
};
var Se = Ed;
Se.PI = "PI", Se.PI2 = "PI2", Se.RECIPROCAL_PI = "RECIPROCAL_PI", Se.RECIPROCAL_PI2 = "RECIPROCAL_PI2", Se.LOG2 = "LOG2", Se.EPSILON = "EPSILON";
var MT = new RegExp(`^structs*([a-z_0-9]+)s*{s*((.|
)*?)}`, "gim");
var ET = new RegExp("s*(w*?)s*(w*?)(=|;)", "gim");
var ni = class extends ae {
  constructor(e = "") {
    super();
    this.inputs = [];
    this.src = "";
    this.nodeType = "Struct";
    this.parse(e);
  }
  getType(e) {
    return e.getTypeByFormat(this.name);
  }
  getInputByName(e) {
    let t = this.inputs.length;
    for (; t--; )
      if (this.inputs[t].name === e)
        return this.inputs[t];
  }
  generate(e, t, o, i, s) {
    return t === "source" ? this.src + ";" : e.format("( " + this.src + " )", this.getType(e), t);
  }
  parse(e = "") {
    this.src = e, this.inputs = [];
    let t = MT.exec(e);
    if (t) {
      let o = t[2], i;
      for (; i = ET.exec(o); )
        this.inputs.push({ type: i[1], name: i[2] });
      this.name = t[1];
    } else
      this.name = "";
    this.type = this.name;
  }
};
var ii = class extends ae {
  constructor(e) {
    super("v2", { shared: false });
    this.nodeType = "UV";
    this.index = e ?? 0;
  }
  generate(e, t) {
    e.requires.uv[this.index] = true;
    let o = this.index > 0 ? this.index + 1 : "", i = e.isShader("vertex") ? "uv" + o : "vUv" + o;
    return e.format(i, this.getType(e), t);
  }
};
Xe.addKeyword("uv", function() {
  return new ii();
});
Xe.addKeyword("uv2", function() {
  return new ii(1);
});
var Bo = class extends ae {
  constructor(e, t) {
    super("v4");
    this.nodeType = "ColorSpace";
    this.input = e, this.method = t ?? Bo.LINEAR_TO_LINEAR, this.hashProperties = ["method"];
  }
  static getEncodingComponents(e) {
    switch (e) {
      case LinearEncoding:
        return ["Linear"];
      case sRGBEncoding:
        return ["sRGB"];
      default:
        return [];
    }
  }
  generate(e, t) {
    var _a2;
    let o = this.input.build(e, "v4"), i = this.getType(e), s = Bo.Nodes[this.method], l = e.include(s);
    if (l === Bo.LINEAR_TO_LINEAR)
      return e.format(o, i, t);
    if (((_a2 = s.inputs) == null ? void 0 : _a2.length) === 2) {
      let c = this.factor.build(e, "f");
      return e.format(l + "( " + o + ", " + c + " )", i, t);
    } else
      return e.format(l + "( " + o + " )", i, t);
  }
  fromEncoding(e) {
    let t = Bo.getEncodingComponents(e);
    this.method = "LinearTo" + t[0], this.factor = t[1];
  }
  fromDecoding(e) {
    let t = Bo.getEncodingComponents(e);
    this.method = t[0] + "ToLinear", this.factor = t[1];
  }
};
var vt = Bo;
vt.Nodes = { LinearToLinear: new U(["vec4 LinearToLinear( in vec4 value ) {", "	return value;", "}"].join(`
`)), sRGBToLinear: new U(["vec4 sRGBToLinear( in vec4 value ) {", "	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );", "}"].join(`
`)), LinearTosRGB: new U(["vec4 LinearTosRGB( in vec4 value ) {", "	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );", "}"].join(`
`)) }, vt.LINEAR_TO_LINEAR = "LinearToLinear", vt.SRGB_TO_LINEAR = "sRGBToLinear", vt.LINEAR_TO_SRGB = "LinearTosRGB";
var _e = class extends U {
  constructor(e = "", t, o, i, s) {
    super(e, s, i, o, t);
    this.nodeType = "Expression";
  }
};
var bt = class extends Ne {
  constructor(e = new Texture(), t, o, i) {
    super("v4", { shared: true });
    this.nodeType = "Texture";
    this.value = e, this.uv = t ?? new ii(), this.bias = o, this.project = i !== void 0 ? i : false;
  }
  getTexture(e, t) {
    return super.generate(e, t, this.value.uuid, "t");
  }
  generate(e, t) {
    if (t === "sampler2D")
      return this.getTexture(e, t);
    let o = this.getTexture(e, t), i = this.uv.build(e, this.project ? "v4" : "v2"), s = this.bias ? this.bias.build(e, "f") : void 0;
    s === void 0 && e.context.bias && (s = e.context.bias.setTexture(this).build(e, "f"));
    let l, c;
    this.project ? l = "texture2DProj" : l = s ? "tex2DBias" : "tex2D", s ? c = l + "( " + o + ", " + i + ", " + s + " )" : c = l + "( " + o + ", " + i + " )";
    let u = { include: e.isShader("vertex"), ignoreCache: true }, a = this.getType(e);
    return e.addContext(u), this.colorSpace = this.colorSpace ?? new vt(new _e("", a)), this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)), this.colorSpace.input.parse(c), c = this.colorSpace.build(e, a), e.removeContext(), e.format(c, a, t);
  }
};
var Z = class extends Ne {
  constructor(e) {
    super("f");
    this.nodeType = "Float";
    this.value = e ?? 0;
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format(this.value + (this.value % 1 ? "" : ".0"), i, t);
  }
};
var _s = class extends ae {
  constructor(e, t) {
    super();
    this.inputs = [];
    this.nodeType = "FunctionCall";
    this.value = e, this.inputs = t ?? [];
  }
  getFunction() {
    return this.value;
  }
  getType(e) {
    return this.value.getType(e);
  }
  generate(e, t, o, i, s) {
    i = this.getType(e);
    let l = this.value, c = l.build(e, t) + "( ", u = [];
    if (l.inputs) {
      for (let a = 0; a < l.inputs.length; a++) {
        let d = l.inputs[a], p = this.inputs[a] || this.inputs[d.name];
        u.push(p.build(e, e.getTypeByFormat(d.type)));
      }
      c += u.join(", ") + " )";
    }
    return e.format(c, i, t);
  }
};
var Ld = class extends ae {
  constructor(e, t, o = Ld.ADD) {
    super();
    this.nodeType = "Operator";
    this.type = e.type, this.a = e, this.b = t, this.op = o;
  }
  getType(e) {
    let t = this.a.getType(e), o = this.b.getType(e);
    return e.isTypeMatrix(t) ? "v4" : e.getTypeLength(o) > e.getTypeLength(t) ? o : t;
  }
  generate(e, t) {
    let o = this.getType(e);
    this.type = o;
    let i = this.a.build(e, o), s = this.b.build(e, o);
    return e.format("( " + i + " " + this.op + " " + s + " )", o, t);
  }
};
var ot = Ld;
ot.ADD = "+", ot.SUB = "-", ot.MUL = "*", ot.DIV = "/";
var Ce = class extends ae {
  constructor(e, t = Ce.ABS, o, i) {
    super();
    this.nodeType = "Math";
    this.a = e, typeof t != "string" ? this.b = t : i = t, typeof o != "string" ? this.c = o : i = o, this.method = i, this.hashProperties = ["method"];
  }
  getNumInputs(e) {
    switch (this.method) {
      case Ce.MIX:
      case Ce.CLAMP:
      case Ce.REFRACT:
      case Ce.SMOOTHSTEP:
      case Ce.FACEFORWARD:
        return 3;
      case Ce.MIN:
      case Ce.MAX:
      case Ce.MOD:
      case Ce.STEP:
      case Ce.REFLECT:
      case Ce.DISTANCE:
      case Ce.DOT:
      case Ce.CROSS:
      case Ce.POW:
        return 2;
      default:
        return 1;
    }
  }
  getInputType(e) {
    let t = e.getTypeLength(this.a.getType(e)), o = this.b ? e.getTypeLength(this.b.getType(e)) : 0, i = this.c ? e.getTypeLength(this.c.getType(e)) : 0;
    return t > o && t > i ? this.a.getType(e) : o > i ? this.b.getType(e) : this.c.getType(e);
  }
  getType(e) {
    switch (this.method) {
      case Ce.LENGTH:
      case Ce.DISTANCE:
      case Ce.DOT:
        return "f";
      case Ce.CROSS:
        return "v3";
    }
    return this.getInputType(e);
  }
  generate(e, t) {
    let o, i, s, l = this.a ? e.getTypeLength(this.a.getType(e)) : 0, c = this.b ? e.getTypeLength(this.b.getType(e)) : 0, u = this.c ? e.getTypeLength(this.c.getType(e)) : 0, a = this.getInputType(e), d = this.getType(e);
    switch (this.type = d, this.method) {
      case Ce.NEGATE:
        return e.format("( -" + this.a.build(e, a) + " )", a, t);
      case Ce.INVERT:
        return e.format("( 1.0 - " + this.a.build(e, a) + " )", a, t);
      case Ce.CROSS:
        o = this.a.build(e, "v3"), i = this.b.build(e, "v3");
        break;
      case Ce.STEP:
        o = this.a.build(e, l === 1 ? "f" : a), i = this.b.build(e, a);
        break;
      case Ce.MIN:
      case Ce.MAX:
      case Ce.MOD:
        o = this.a.build(e, a), i = this.b.build(e, c === 1 ? "f" : a);
        break;
      case Ce.REFRACT:
        o = this.a.build(e, a), i = this.b.build(e, a), s = this.c.build(e, "f");
        break;
      case Ce.MIX:
        o = this.a.build(e, a), i = this.b.build(e, a), s = this.c.build(e, u === 1 ? "f" : a);
        break;
      default:
        o = this.a.build(e, a), this.b && (i = this.b.build(e, a)), this.c && (s = this.c.build(e, a));
        break;
    }
    let p = [];
    p.push(o), i && p.push(i), s && p.push(s);
    let f = this.getNumInputs(e);
    if (p.length !== f)
      throw Error(`Arguments not match used in "${this.method}". Require ${f}, currently ${p.length}.`);
    return e.format(this.method + "( " + p.join(", ") + " )", d, t);
  }
};
var pe = Ce;
pe.RAD = "radians", pe.DEG = "degrees", pe.EXP = "exp", pe.EXP2 = "exp2", pe.LOG = "log", pe.LOG2 = "log2", pe.SQRT = "sqrt", pe.INV_SQRT = "inversesqrt", pe.FLOOR = "floor", pe.CEIL = "ceil", pe.NORMALIZE = "normalize", pe.FRACT = "fract", pe.SATURATE = "saturate", pe.SIN = "sin", pe.COS = "cos", pe.TAN = "tan", pe.ASIN = "asin", pe.ACOS = "acos", pe.ARCTAN = "atan", pe.ABS = "abs", pe.SIGN = "sign", pe.LENGTH = "length", pe.NEGATE = "negate", pe.INVERT = "invert", pe.MIN = "min", pe.MAX = "max", pe.MOD = "mod", pe.STEP = "step", pe.REFLECT = "reflect", pe.DISTANCE = "distance", pe.DOT = "dot", pe.CROSS = "cross", pe.POW = "pow", pe.MIX = "mix", pe.CLAMP = "clamp", pe.REFRACT = "refract", pe.SMOOTHSTEP = "smoothstep", pe.FACEFORWARD = "faceforward";
var si = class extends ae {
  constructor(e, t, o) {
    super("v4");
    this.nodeType = "TextureCubeUV";
    this.value = e, this.uv = t, this.bias = o;
  }
  bilinearCubeUV(e, t, o, i) {
    let s = new _s(si.Nodes.bilinearCubeUV, [t, o, i]);
    this.colorSpaceTL = this.colorSpaceTL ?? new vt(new _e("", "v4")), this.colorSpaceTL.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceTL.input.parse(s.build(e) + ".tl"), this.colorSpaceTR = this.colorSpaceTR ?? new vt(new _e("", "v4")), this.colorSpaceTR.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceTR.input.parse(s.build(e) + ".tr"), this.colorSpaceBL = this.colorSpaceBL ?? new vt(new _e("", "v4")), this.colorSpaceBL.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceBL.input.parse(s.build(e) + ".bl"), this.colorSpaceBR = this.colorSpaceBR ?? new vt(new _e("", "v4")), this.colorSpaceBR.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceBR.input.parse(s.build(e) + ".br");
    let l = { include: e.isShader("vertex"), ignoreCache: true };
    e.addContext(l), this.colorSpaceTLExp = new _e(this.colorSpaceTL.build(e, "v4"), "v4"), this.colorSpaceTRExp = new _e(this.colorSpaceTR.build(e, "v4"), "v4"), this.colorSpaceBLExp = new _e(this.colorSpaceBL.build(e, "v4"), "v4"), this.colorSpaceBRExp = new _e(this.colorSpaceBR.build(e, "v4"), "v4"), e.removeContext();
    let c = new _e("mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )", "v4");
    return c.keywords.cubeUV_TL = this.colorSpaceTLExp, c.keywords.cubeUV_TR = this.colorSpaceTRExp, c.keywords.cubeUV_BL = this.colorSpaceBLExp, c.keywords.cubeUV_BR = this.colorSpaceBRExp, c.keywords.cubeUV = s, c;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      let o = this.uv, i = this.bias || e.context.roughness, s = new _s(si.Nodes.roughnessToMip, [i]), l = new pe(s, si.Nodes.m0, si.Nodes.cubeUV_maxMipLevel, pe.CLAMP), c = new pe(l, pe.FLOOR), u = new pe(l, pe.FRACT), a = this.bilinearCubeUV(e, this.value, o, c), d = this.bilinearCubeUV(e, this.value, o, new ot(c, new Z(1).setReadonly(true), ot.ADD)), p = new pe(a, d, u, pe.MIX);
      return e.format(p.build(e), "v4", t);
    } else
      return console.warn("TextureCubeUVNode is not compatible with " + e.shader + " shader."), e.format("vec4( 0.0 )", this.getType(e), t);
  }
};
var ai = si;
ai.Nodes = function() {
  let e = new ni(`struct TextureCubeUVData {
			vec4 tl;
			vec4 tr;
			vec4 br;
			vec4 bl;
			vec2 f;
		}`), t = new Se("float cubeUV_maxMipLevel 8.0", true), o = new Se("float cubeUV_minMipLevel 4.0", true), i = new Se("float cubeUV_maxTileSize 256.0", true), s = new Se("float cubeUV_minTileSize 16.0", true), l = new U(`float getFace(vec3 direction) {
				vec3 absDirection = abs(direction);
				float face = -1.0;
				if (absDirection.x > absDirection.z) {
					if (absDirection.x > absDirection.y)
						face = direction.x > 0.0 ? 0.0 : 3.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				} else {
					if (absDirection.z > absDirection.y)
						face = direction.z > 0.0 ? 2.0 : 5.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				}
				return face;
		}`);
  l.useKeywords = false;
  let c = new U(`vec2 getUV(vec3 direction, float face) {
				vec2 uv;
				if (face == 0.0) {
					uv = vec2(direction.z, direction.y) / abs(direction.x); // pos x
				} else if (face == 1.0) {
					uv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y
				} else if (face == 2.0) {
					uv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z
				} else if (face == 3.0) {
					uv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x
				} else if (face == 4.0) {
					uv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y
				} else {
					uv = vec2(direction.x, direction.y) / abs(direction.z); // neg z
				}
				return 0.5 * (uv + 1.0);
		}`);
  c.useKeywords = false;
  let u = new U(`TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
			float face = getFace(direction);
			float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
			mipInt = max(mipInt, cubeUV_minMipLevel);
			float faceSize = exp2(mipInt);
			float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
			vec2 uv = getUV(direction, face) * (faceSize - 1.0);
			vec2 f = fract(uv);
			uv += 0.5 - f;
			if (face > 2.0) {
				uv.y += faceSize;
				face -= 3.0;
			}
			uv.x += face * faceSize;
			if(mipInt < cubeUV_maxMipLevel){
				uv.y += 2.0 * cubeUV_maxTileSize;
			}
			uv.y += filterInt * 2.0 * cubeUV_minTileSize;
			uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
			uv *= texelSize;
			vec4 tl = texture2D(envMap, uv);
			uv.x += texelSize;
			vec4 tr = texture2D(envMap, uv);
			uv.y += texelSize;
			vec4 br = texture2D(envMap, uv);
			uv.x -= texelSize;
			vec4 bl = texture2D(envMap, uv);
			return TextureCubeUVData( tl, tr, br, bl, f );
		}`, [e, l, c, t, o, i, s]);
  u.useKeywords = false;
  let a = new Se("float r0 1.0", true), d = new Se("float v0 0.339", true), p = new Se("float m0 -2.0", true), f = new Se("float r1 0.8", true), m = new Se("float v1 0.276", true), h = new Se("float m1 -1.0", true), y = new Se("float r4 0.4", true), g = new Se("float v4 0.046", true), v = new Se("float m4 2.0", true), b = new Se("float r5 0.305", true), w = new Se("float v5 0.016", true), S = new Se("float m5 3.0", true), P = new Se("float r6 0.21", true), _ = new Se("float v6 0.0038", true), x = new Se("float m6 4.0", true), C = [a, d, p, f, m, h, y, g, v, b, w, S, P, _, x], T = new U(`float roughnessToMip(float roughness) {
			float mip = 0.0;
			if (roughness >= r1) {
				mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
			} else if (roughness >= r4) {
				mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
			} else if (roughness >= r5) {
				mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
			} else if (roughness >= r6) {
				mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
			} else {
				mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
			}
			return mip;
		}`, C);
  return { bilinearCubeUV: u, roughnessToMip: T, m0: p, cubeUV_maxMipLevel: t };
}();
var Do = class extends ae {
  constructor(e) {
    super("v3");
    this.nodeType = "Normal";
    this.scope = e ?? Do.VIEW;
  }
  getShared() {
    return this.scope === Do.WORLD;
  }
  build(e, t, o, i) {
    let s = e.context[this.scope + "Normal"];
    return s ? s.build(e, t, o, i) : super.build(e, t, o);
  }
  generate(e, t, o, i, s) {
    let l;
    switch (this.scope) {
      case Do.VIEW:
        e.isShader("vertex") ? l = "transformedNormal" : l = "geometryNormal";
        break;
      case Do.LOCAL:
        e.isShader("vertex") ? l = "objectNormal" : (e.requires.normal = true, l = "vObjectNormal");
        break;
      case Do.WORLD:
        e.isShader("vertex") ? l = "inverseTransformDirection( transformedNormal, viewMatrix ).xyz" : (e.requires.worldNormal = true, l = "vWNormal");
        break;
    }
    return e.format(l, this.getType(e), t);
  }
};
var nt = Do;
nt.LOCAL = "local", nt.WORLD = "world", nt.VIEW = "view", nt.NORMAL = "normal";
Xe.addKeyword("viewNormal", function() {
  return new nt(nt.VIEW);
});
Xe.addKeyword("localNormal", function() {
  return new nt(nt.NORMAL);
});
Xe.addKeyword("worldNormal", function() {
  return new nt(nt.WORLD);
});
var Or = class extends ae {
  constructor(e) {
    super("v3");
    this.nodeType = "Position";
    this.scope = e ?? Or.LOCAL;
  }
  getType() {
    switch (this.scope) {
      case Or.PROJECTION:
        return "v4";
    }
    return this.type;
  }
  getShader() {
    switch (this.scope) {
      case Or.LOCAL:
      case Or.WORLD:
        return false;
    }
    return true;
  }
  generate(e, t, o, i, s) {
    let l;
    switch (this.scope) {
      case Or.LOCAL:
        e.isShader("vertex") ? l = "transformed" : (e.requires.position = true, l = "vPosition");
        break;
      case Or.WORLD:
        if (e.isShader("vertex"))
          return "( modelMatrix * vec4( transformed, 1.0 ) ).xyz";
        e.requires.worldPosition = true, l = "vWPosition";
        break;
      case Or.VIEW:
        l = e.isShader("vertex") ? "-mvPosition.xyz" : "vViewPosition";
        break;
      case Or.PROJECTION:
        l = e.isShader("vertex") ? "( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )" : "vec4( 0.0 )";
        break;
    }
    return e.format(l, this.getType(), t);
  }
};
var Ct = Or;
Ct.LOCAL = "local", Ct.WORLD = "world", Ct.VIEW = "view", Ct.PROJECTION = "projection";
Xe.addKeyword("position", function() {
  return new Ct();
});
Xe.addKeyword("worldPosition", function() {
  return new Ct(Ct.WORLD);
});
Xe.addKeyword("viewPosition", function() {
  return new Ct(Ct.VIEW);
});
var ar = class extends ae {
  constructor(e) {
    super("v3");
    this.nodeType = "Reflect";
    this.scope = e ?? ar.CUBE;
  }
  getUnique(e) {
    return !e.context.viewNormal;
  }
  getType() {
    switch (this.scope) {
      case ar.SPHERE:
        return "v2";
    }
    return this.type;
  }
  generate(e, t) {
    let o = this.getUnique(e);
    if (e.isShader("fragment")) {
      let i;
      switch (this.scope) {
        case ar.VECTOR: {
          let s = new nt(nt.VIEW), l = e.context.roughness, c = s.build(e, "v3"), u = new Ct(Ct.VIEW).build(e, "v3"), a = l ? l.build(e, "f") : void 0, d = `reflect( -normalize( ${u} ), ${c} )`;
          a && (d = `normalize( mix( ${d}, ${c}, ${a} * ${a} ) )`);
          let p = `inverseTransformDirection( ${d}, viewMatrix )`;
          o ? (e.addNodeCode(`vec3 reflectVec = ${p};`), i = "reflectVec") : i = p;
          break;
        }
        case ar.CUBE: {
          let s = new ar(ar.VECTOR).build(e, "v3"), l = "vec3( -" + s + ".x, " + s + ".yz )";
          o ? (e.addNodeCode(`vec3 reflectCubeVec = ${l};`), i = "reflectCubeVec") : i = l;
          break;
        }
        case ar.SPHERE: {
          let l = "normalize( ( viewMatrix * vec4( " + new ar(ar.VECTOR).build(e, "v3") + ", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5";
          o ? (e.addNodeCode(`vec2 reflectSphereVec = ${l};`), i = "reflectSphereVec") : i = l;
          break;
        }
      }
      return e.format(i, this.getType(), t);
    } else
      return console.warn("ReflectNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.type, t);
  }
};
var Ar = ar;
Ar.CUBE = "cube", Ar.SPHERE = "sphere", Ar.VECTOR = "vector";
var wl = class extends ae {
  constructor(e = new bt(), t, o) {
    super("v4");
    this.nodeType = "TextureCube";
    this.value = e, this.radianceNode = new ai(this.value, t ?? new Ar(Ar.VECTOR), o), this.irradianceNode = new ai(this.value, new nt(nt.WORLD), new Z(1).setReadonly(true));
  }
  generate(e, t) {
    return e.isShader("fragment") ? (e.require("irradiance"), e.context.bias && e.context.bias.setTexture(this.value), (e.slot === "irradiance" ? this.irradianceNode : this.radianceNode).build(e, t)) : (console.warn("TextureCubeNode is not compatible with " + e.shader + " shader."), e.format("vec4( 0.0 )", this.getType(e), t));
  }
};
var _l = class extends Ne {
  constructor(e = new CubeTexture(), t, o) {
    super("v4", { shared: true });
    this.nodeType = "CubeTexture";
    this.value = e, this.uv = t ?? new Ar(), this.bias = o;
  }
  getTexture(e, t) {
    return super.generate(e, t, this.value.uuid, "tc");
  }
  generate(e, t) {
    var _a2;
    if (t === "samplerCube")
      return this.getTexture(e, t);
    let o = this.getTexture(e, t), i = (_a2 = this.uv) == null ? void 0 : _a2.build(e, "v3"), s = this.bias ? this.bias.build(e, "f") : void 0;
    s === void 0 && e.context.bias && (s = e.context.bias.setTexture(this).build(e, "f"));
    let l;
    s ? l = "texCubeBias( " + o + ", " + i + ", " + s + " )" : l = "texCube( " + o + ", " + i + " )";
    let c = { include: e.isShader("vertex"), ignoreCache: true }, u = this.getType(e);
    return e.addContext(c), this.colorSpace = this.colorSpace ?? new vt(new _e("", u)), this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)), this.colorSpace.input.parse(l), l = this.colorSpace.build(e, u), e.removeContext(), e.format(l, u, t);
  }
};
var Ny = `
uniform int frameIndex;
uniform vec2 resolution;
uniform mat4 previousModelViewMatrix;
uniform mat4 previousProjectionMatrix;

varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;
`;
var Cy = `
layout(location = 1) out vec4 gVelocity;

uniform int frameIndex;
uniform vec2 resolution;

varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;

const vec2 haltonSequence[16] = vec2[16](
vec2( 0.000000,-0.333334),
vec2(-0.500000, 0.333334),
vec2( 0.500000,-0.777778),
vec2(-0.750000,-0.111112),
vec2( 0.250000, 0.555556),
vec2(-0.250000,-0.555556),
vec2( 0.750000, 0.111112),
vec2(-0.875000, 0.777778),
vec2(0.125000, -0.925926),
vec2(-0.375000, -0.259260),
vec2(0.625000, 0.407408),
vec2(-0.625000, -0.703704),
vec2(0.375000, -0.037038),
vec2(-0.125000, 0.629630),
vec2(0.875000, -0.481482),
vec2(-0.937500, 0.185186));

vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
  const float goldenAngle = 2.399963f; // radians
  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
  float theta = float(sampleIndex) * goldenAngle + angle;
  float sine = sin(theta);
  float cosine = cos(theta);
  return vec2(cosine, sine) * r;
}

// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso
float getNoiseInterleavedGradient(vec2 screenPos) {
    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);
    return fract(magic.z * fract(dot(screenPos, magic.xy)));
}

`;
var Iy = `
// TODO: This could be generated CPU side and passed to the shader every frame
const vec2 haltonSequence[16] = vec2[16](
vec2( 0.000000,-0.333334),
vec2(-0.500000, 0.333334),
vec2( 0.500000,-0.777778),
vec2(-0.750000,-0.111112),
vec2( 0.250000, 0.555556),
vec2(-0.250000,-0.555556),
vec2( 0.750000, 0.111112),
vec2(-0.875000, 0.777778),
vec2(0.125000, -0.925926),
vec2(-0.375000, -0.259260),
vec2(0.625000, 0.407408),
vec2(-0.625000, -0.703704),
vec2(0.375000, -0.037038),
vec2(-0.125000, 0.629630),
vec2(0.875000, -0.481482),
vec2(-0.937500, 0.185186));

// TODO: Pass correct view size
vec2 offset = haltonSequence[frameIndex];
offset.x /= resolution.x;
offset.y /= resolution.y;

vec4 currentPosition = gl_Position;
vec4 currentPositionJittered = currentPosition + (vec4(offset.x, offset.y, 0.0, 0.0) * currentPosition.w);

// We want to calculate the velocity with unjittered positions
// so that things that are not moving get a velocity = 0
vCurrentPosition = currentPosition;
vPreviousPosition = previousProjectionMatrix * previousModelViewMatrix * vec4(transformed, 1.0);
#ifdef OUTLINE_COMPENSATION
vPreviousPosition.xy += OUTLINE_COMPENSATION;
#endif
gl_Position = currentPositionJittered;

`;
var My = `
vec2 oldPos = vPreviousPosition.xy;
    oldPos /= vPreviousPosition.w;
    oldPos.xy = (oldPos.xy+1.)/2.0;

vec2 newPos = vCurrentPosition.xy;
    newPos /= vCurrentPosition.w;
    newPos.xy = (newPos.xy+1.)/2.0;

vec2 velocity = (newPos - oldPos);

// NOTE: We use the blue channel to avoid temporal reprojection
// with incorrect velocity if the fragment is transparent.
gVelocity = vec4(velocity, gl_FragColor.a < 1.0 ? 0.0 : 1.0, 1.);
`;
var Ly = ["x", "y", "z", "w"];
var FT = ["float", "vec2", "vec3", "vec4"];
var kT = { float: "f", vec2: "v2", vec3: "v3", vec4: "v4", mat4: "v4", int: "i", bool: "b", "float[]": "f[]", "vec4[]": "v4[]" };
var UT = { t: "sampler2D", tc: "samplerCube", b: "bool", i: "int", f: "float", c: "vec3", v2: "vec2", v3: "vec3", v4: "vec4", m3: "mat3", m4: "mat4", "f[]": "float[]", "v4[]": "vec4[]" };
var Pl = class {
  constructor() {
    this.includes = { consts: {}, functions: {}, structs: {} };
    this.cache = "";
    this.slot = "";
    this.shader = "";
    this.context = {};
    this.needsJitter = true;
    this.getIncludesCode = function() {
      function r(e, t) {
        return e.deps.length - t.deps.length;
      }
      return function(t, o) {
        let i = this.getIncludes(t, o);
        if (!i)
          return "";
        let s = "";
        i = i.sort(r);
        for (let l = 0; l < i.length; l++)
          i[l].src && (s += i[l].src + `
`);
        return s;
      };
    }();
    this.slots = [], this.caches = [], this.contexts = [], this.keywords = {}, this.nodeData = {}, this.fragmentVariables = {}, this.fragmentParsVariables = {}, this.vertexParsVariables = {}, this.requires = { uv: [], color: [], transparent: false, irradiance: false, position: false, worldPosition: false, normal: false, worldNormal: false, vWorldViewDir: false, modelMatrix: false, viewMatrix: false, projectionMatrix: false }, this.includes = { consts: [], functions: [], structs: [] }, this.attributes = {}, this.prefixCode = ["#ifdef TEXTURE_LOD_EXT", "	#define texCube(a, b) textureCube(a, b)", "	#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)", "	#define tex2D(a, b) texture2D(a, b)", "	#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)", "#else", "	#define texCube(a, b) textureCube(a, b)", "	#define texCubeBias(a, b, c) textureCube(a, b, c)", "	#define tex2D(a, b) texture2D(a, b)", "	#define tex2DBias(a, b, c) texture2D(a, b, c)", "#endif", `
			// NOTE: Include Spline's blending modes. This could be part of BlendNode
			#define SPE_BLENDING_NORMAL 0
			#define SPE_BLENDING_MULTIPLY 1
			#define SPE_BLENDING_SCREEN 2
			#define SPE_BLENDING_OVERLAY 3

			vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, b, alpha );
			}

			vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, a * b, alpha );
			}

			vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );
				return mix( a, tmp, alpha );
			}

			vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );
				return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );
			}

			vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {
				if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );
				return vec3( 1.0 );
			}
			`, "#include <packing>", "#include <common>"].join(`
`), this.parsCode = { vertex: ["float neighbor_offset = 0.0001;", ""].join(`
`), fragment: ["float accumAlpha = 0.0;", `void accumulateAlpha(float alpha) {
					accumAlpha += (1.0 - accumAlpha) * alpha;
				}`, ""].join(`
`) }, this.code = { vertex: "", fragment: "" }, this.nodeCode = { vertex: "", fragment: "" }, this.resultCode = { vertex: "", fragment: "" }, this.finalCode = { vertex: "", fragment: "" }, this.inputs = { uniforms: { list: [], vertex: [], fragment: [] }, arrayUniforms: { list: [], vertex: [], fragment: [] }, vars: { varying: [], vertex: [], fragment: [] } }, this.defines = {}, this.uniforms = {}, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.updaters = [], this.nodes = [], this.analyzing = false;
  }
  build(r, e) {
    this.addVertexParsCode(Ny), this.addFragmentParsCode(Cy), this.buildShader("vertex", r), this.buildShader("fragment", e);
    for (let t = 0; t < this.requires.uv.length; t++)
      if (this.requires.uv[t]) {
        let o = t > 0 ? t + 1 : "";
        this.addVaryCode("varying vec2 vUv" + o + ";"), t > 0 && this.addVertexParsCode("attribute vec2 uv" + o + ";"), this.addVertexFinalCode("vUv" + o + " = uv" + o + ";");
      }
    return this.requires.color[0] && (this.addVaryCode("varying vec4 vColor;"), this.addVertexParsCode("attribute vec4 color;"), this.addVertexFinalCode("vColor = color;")), this.requires.color[1] && (this.addVaryCode("varying vec4 vColor2;"), this.addVertexParsCode("attribute vec4 color2;"), this.addVertexFinalCode("vColor2 = color2;")), this.requires.position && (this.addVaryCode("varying vec3 vPosition;"), this.addVertexFinalCode("vPosition = transformed;")), this.requires.worldPosition, this.requires.normal && (this.addVaryCode("varying vec3 vObjectNormal;"), this.addVertexFinalCode("vObjectNormal = normal;")), this.requires.modelMatrix && this.addFragmentParsCode("uniform mat4 modelMatrix;"), this.requires.viewMatrix && this.addFragmentParsCode("uniform mat4 viewMatrix;"), this.requires.projectionMatrix && this.addFragmentParsCode("uniform mat4 projectionMatrix;"), this.requires.worldNormal && (this.addVaryCode("varying vec3 vWNormal;"), this.addVertexFinalCode("vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;")), this.requires.vWorldViewDir && (this.addVaryCode("varying vec3 vWorldViewDir;"), this.addVertexFinalCode("vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );")), this.needsJitter && (this.addVertexFinalCode(Iy), this.addFragmentFinalCode(My)), this;
  }
  buildShader(r, e) {
    this.resultCode[r] = e.build(this.setShader(r), "v4");
  }
  setMaterial(r, e) {
    return this.defines = {}, this;
  }
  addFlow(r, e, t) {
    return this.addSlot(r).addCache(e).addContext(t);
  }
  removeFlow() {
    return this.removeSlot().removeCache().removeContext();
  }
  addCache(r) {
    return this.cache = r ?? "", this.caches.push(this.cache), this;
  }
  removeCache() {
    return this.caches.pop(), this.cache = this.caches[this.caches.length - 1] || "", this;
  }
  addContext(r) {
    return this.context = Object.assign({}, this.context, r), this.context.extra = this.context.extra || {}, this.contexts.push(this.context), this;
  }
  removeContext() {
    return this.contexts.pop(), this.context = this.contexts[this.contexts.length - 1] || {}, this;
  }
  addSlot(r) {
    return this.slot = r || "", this.slots.push(this.slot), this;
  }
  removeSlot() {
    return this.slots.pop(), this.slot = this.slots[this.slots.length - 1] || "", this;
  }
  addFragmentVariable(r, e) {
    this.fragmentVariables[r] === void 0 && (this.addFragmentCode(`${e} ${r};`), this.fragmentVariables[r] = "");
  }
  addFragmentParsVariable(r, e) {
    this.fragmentParsVariables[r] === void 0 && (this.addFragmentParsCode(`${e} ${r};`), this.fragmentParsVariables[r] = "");
  }
  addVertexParsVariable(r, e) {
    this.vertexParsVariables[r] === void 0 && (this.addVertexParsCode(`${e} ${r};`), this.vertexParsVariables[r] = "");
  }
  addVertexCode(r) {
    this.addCode(r, "vertex");
  }
  addFragmentCode(r) {
    this.addCode(r, "fragment");
  }
  addCode(r, e) {
    this.code[e ?? this.shader] += r + `
`;
  }
  addVertexNodeCode(r) {
    this.addNodeCode(r, "vertex");
  }
  addFragmentNodeCode(r) {
    this.addNodeCode(r, "fragment");
  }
  addNodeCode(r, e) {
    this.nodeCode[e ?? this.shader] += r + `
`;
  }
  clearNodeCode(r) {
    r = r ?? this.shader;
    let e = this.nodeCode[r];
    return this.nodeCode[r] = "", e;
  }
  clearVertexNodeCode() {
    return this.clearNodeCode("vertex");
  }
  clearFragmentNodeCode() {
    return this.clearNodeCode("fragment");
  }
  addVertexFinalCode(r) {
    this.addFinalCode(r, "vertex");
  }
  addFragmentFinalCode(r) {
    this.addFinalCode(r, "fragment");
  }
  addFinalCode(r, e) {
    this.finalCode[e ?? this.shader] += r + `
`;
  }
  addVertexParsCode(r) {
    this.addParsCode(r, "vertex");
  }
  addFragmentParsCode(r) {
    this.addParsCode(r, "fragment");
  }
  addParsCode(r, e) {
    this.parsCode[e ?? this.shader] += r + `
`;
  }
  addVaryCode(r) {
    this.addVertexParsCode(r), this.addFragmentParsCode(r);
  }
  isCache(r) {
    return this.caches.indexOf(r) !== -1;
  }
  isSlot(r) {
    return this.slots.indexOf(r) !== -1;
  }
  define(r, e) {
    this.defines[r] = e === void 0 ? 1 : e;
  }
  require(r) {
    this.requires[r] = true;
  }
  isDefined(r) {
    return this.defines[r] !== void 0;
  }
  getVar(r, e, t, o = "varying", i = "V", s = "") {
    let l = this.getVars(o), c = l[r];
    if (!c) {
      let u = l.length;
      c = { name: t || "node" + i + u + (s ? "_" + s : ""), type: e }, l.push(c), l[r] = c;
    }
    return c;
  }
  getTempVar(r, e, t, o) {
    return this.getVar(r, e, t, this.shader, "T", o);
  }
  getAttribute(r, e) {
    if (!this.attributes[r]) {
      let t = this.getVar(r, e);
      this.addVertexParsCode("attribute " + e + " " + r + ";"), this.addVertexFinalCode(t.name + " = " + r + ";"), this.attributes[r] = { varying: t, name: r, type: e };
    }
    return this.attributes[r];
  }
  getCode(r) {
    return [this.prefixCode, this.parsCode[r], this.getVarListCode(this.getVars("varying"), "varying"), this.getVarListCode(this.inputs.uniforms[r], "uniform"), this.getVarListCode(this.inputs.arrayUniforms[r], "uniform"), this.getIncludesCode("consts", r), this.getIncludesCode("structs", r), this.getIncludesCode("functions", r), "void main() {", this.getVarListCode(this.getVars(r)), this.code[r], this.resultCode[r], this.finalCode[r], "}"].join(`
`);
  }
  getVarListCode(r, e) {
    e = e ?? "";
    let t = "";
    for (let o = 0, i = r.length; o < i; ++o) {
      let s = r[o], l = s.type, c = s.name, u = s.size, a = this.getFormatByType(l);
      if (a === void 0)
        throw new Error("Node pars " + a + " not found.");
      a.includes("[]") ? t += e + " " + a.substring(0, a.length - 2) + " " + c + `[${u}];
` : t += e + " " + a + " " + c + `;
`;
    }
    return t;
  }
  getVars(r) {
    return this.inputs.vars[r ?? this.shader];
  }
  getNodeData(r) {
    let e = r instanceof rt ? r.uuid : r;
    return this.nodeData[e] = this.nodeData[e] || {};
  }
  createUniform(r, e, t, o, i, s) {
    if (e.includes("[]")) {
      let l = this.inputs.arrayUniforms, c = l.list.length, u = new ws({ type: e, size: t.size, name: o || "nodeUA" + c + (s ? "_" + s : ""), node: t, needsUpdate: i });
      return l.list.push(u), l[r].push(u), l[r][u.name] = u, this.uniforms[u.name] = u, u;
    } else {
      let l = this.inputs.uniforms, c = l.list.length, u = new ws({ type: e, name: o || "nodeU" + c + (s ? "_" + s : ""), node: t, needsUpdate: i });
      return l.list.push(u), l[r].push(u), l[r][u.name] = u, this.uniforms[u.name] = u, u;
    }
  }
  createVertexUniform(r, e, t, o, i) {
    return this.createUniform("vertex", r, e, t, o, i);
  }
  createFragmentUniform(r, e, t, o, i) {
    return this.createUniform("fragment", r, e, t, o, i);
  }
  include(r, e, t) {
    var _a2;
    let o;
    if (r = typeof r == "string" ? Xe.get(r) : r, this.context.include === false)
      return r.name;
    r instanceof U ? o = this.includes.functions : r instanceof Se ? o = this.includes.consts : r instanceof ni && (o = this.includes.structs);
    let i = o[this.shader] = o[this.shader] || [];
    if (r) {
      let s = i[r.name];
      if (s || (s = i[r.name] = { node: r, deps: [] }, i.push(s), s.src = r.build(this, "source")), r instanceof U && e && i[e.name] && i[e.name].deps.indexOf(r) === -1 && (i[e.name].deps.push(r), (_a2 = r.includes) == null ? void 0 : _a2.length)) {
        let l = 0;
        do
          this.include(r.includes[l++], e);
        while (l < r.includes.length);
      }
      return t && (s.src = t), r.name;
    } else
      throw new Error("Include not found.");
  }
  colorToVectorProperties(r) {
    return r.replace("r", "x").replace("g", "y").replace("b", "z").replace("a", "w");
  }
  colorToVector(r) {
    return r.replace(/c/g, "v3");
  }
  getIncludes(r, e) {
    return this.includes[r][e || this.shader];
  }
  getConstructorFromLength(r) {
    return FT[r - 1];
  }
  isTypeMatrix(r) {
    return /^m/.test(r);
  }
  getTypeLength(r) {
    return r === "f" ? 1 : parseInt(this.colorToVector(r).substr(1));
  }
  getTypeFromLength(r) {
    return r === 1 ? "f" : "v" + r;
  }
  findNode(...r) {
    for (let e = 0; e < arguments.length; e++) {
      let t = r[e];
      if (t == null ? void 0 : t.isNode)
        return t;
    }
  }
  resolve(...r) {
    for (let e = 0; e < arguments.length; e++) {
      let t = r[e];
      if (t !== void 0) {
        if (t.isNode)
          return t;
        if (t.isTexture)
          switch (t.mapping) {
            case CubeReflectionMapping:
            case CubeRefractionMapping:
              return new _l(t);
            case CubeUVReflectionMapping:
              return new wl(new bt(t));
            default:
              return new bt(t);
          }
        else {
          if (t.isVector2)
            return new je(t);
          if (t.isVector3)
            return new ut(t);
          if (t.isVector4)
            return new Nt(t);
        }
      }
    }
  }
  format(r, e, t) {
    switch (this.colorToVector(t + " <- " + e)) {
      case "f <- v2":
        return r + ".x";
      case "f <- v3":
        return r + ".x";
      case "f <- v4":
        return r + ".x";
      case "f <- i":
      case "f <- b":
        return "float( " + r + " )";
      case "v2 <- f":
        return "vec2( " + r + " )";
      case "v2 <- v3":
        return r + ".xy";
      case "v2 <- v4":
        return r + ".xy";
      case "v2 <- i":
      case "v2 <- b":
        return "vec2( float( " + r + " ) )";
      case "v3 <- f":
        return "vec3( " + r + " )";
      case "v3 <- v2":
        return "vec3( " + r + ", 0.0 )";
      case "v3 <- v4":
        return r + ".xyz";
      case "v3 <- i":
      case "v3 <- b":
        return "vec2( float( " + r + " ) )";
      case "v4 <- f":
        return "vec4( " + r + " )";
      case "v4 <- v2":
        return "vec4( " + r + ", 0.0, 1.0 )";
      case "v4 <- v3":
        return "vec4( " + r + ", 1.0 )";
      case "v4 <- i":
      case "v4 <- b":
        return "vec4( float( " + r + " ) )";
      case "i <- f":
      case "i <- b":
        return "int( " + r + " )";
      case "i <- v2":
        return "int( " + r + ".x )";
      case "i <- v3":
        return "int( " + r + ".x )";
      case "i <- v4":
        return "int( " + r + ".x )";
      case "b <- f":
        return "( " + r + " != 0.0 )";
      case "b <- v2":
        return "( " + r + " != vec2( 0.0 ) )";
      case "b <- v3":
        return "( " + r + " != vec3( 0.0 ) )";
      case "b <- v4":
        return "( " + r + " != vec4( 0.0 ) )";
      case "b <- i":
        return "( " + r + " != 0 )";
    }
    return r;
  }
  getTypeByFormat(r) {
    return kT[r] || r;
  }
  getFormatByType(r) {
    return UT[r] || r;
  }
  getUUID(r, e) {
    return e = e !== void 0 ? e : true, e && this.cache && (r = this.cache + "-" + r), r;
  }
  getElementByIndex(r) {
    return Ly[r];
  }
  getIndexByElement(r) {
    return Ly.indexOf(r);
  }
  isShader(r) {
    return this.shader === r;
  }
  setShader(r) {
    return this.shader = r, this;
  }
  mergeDefines(r) {
    for (let e in r)
      this.defines[e] = r[e];
    return this.defines;
  }
  mergeUniform(r) {
    for (let e in r)
      this.uniforms[e] = r[e];
    return this.uniforms;
  }
  getTextureEncodingFromMap(r) {
    let e;
    return r ? r.isTexture && (e = r.encoding) : e = LinearEncoding, e === LinearEncoding && this.context.gamma && (e = sRGBEncoding), e;
  }
};
var Oe = class extends Ne {
  constructor(e = 0, t, o, i) {
    super("c");
    this.nodeType = "Color";
    this.value = e instanceof Ke ? e : new Ke(e || 0, t, o, i);
  }
  setRGBA(e) {
    this.value.setRGBA(e.r, e.g, e.b, e.a);
  }
  generate(e, t, o, i, s, l) {
    o = e.getUUID(o ?? this.getUUID()), i = i ?? this.getType(e);
    let c = e.getNodeData(o), u = this.getReadonly() && this.generateReadonly !== void 0;
    if (this.alpha) {
      let a = this.alpha.build(e, "f");
      e.addFragmentNodeCode(`accumAlpha += ( 1.0 - accumAlpha ) * ${a};`);
    }
    return u ? this.generateReadonly(e, t, o, i, s, l) : e.isShader("vertex") ? (c.vertex || (c.vertex = e.createVertexUniform(i, this, s, l, this.getLabel())), e.format(c.vertex.name, i, t)) : (c.fragment || (c.fragment = e.createFragmentUniform(i, this, s, l, this.getLabel())), e.format(c.fragment.name, i, t));
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format("vec3(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ")", i, t);
  }
};
var ve = class extends Ne {
  constructor(e) {
    super("i");
    this.nodeType = "Int";
    this.value = Math.floor(e ?? 0);
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format(this.value.toString(), i, t);
  }
};
var Fe = class extends Ne {
  constructor(e) {
    super("b");
    this.nodeType = "Bool";
    this.value = e ?? false;
  }
  generateReadonly(e, t, o, i) {
    return e.format(this.value ? "true" : "false", i, t);
  }
};
var lr = class extends Ne {
  constructor(e = 1, t) {
    super("f[]");
    this.nodeType = "FloatArray";
    this.size = e, this.value = Array.isArray(t) ? t : typeof t == "number" ? new Array(e).fill(t) : new Array(e).fill(0);
  }
};
var yo = class extends Ne {
};
var Tl = class extends yo {
  constructor(e) {
    super("v3");
    this.image = e;
    this._value = new Vector3();
  }
  get value() {
    return this._value.x = this.image.isVideo ? this.image.img.videoWidth ?? 0 : this.image.img.width, this._value.y = this.image.isVideo ? this.image.img.videoHeight ?? 0 : this.image.img.height, this._value;
  }
};
var Go = class extends yo {
  constructor(e, t) {
    super("t");
    this.image = e;
    this.wrap = t;
  }
  get value() {
    return this.image.getTexture(this.wrap);
  }
};
var li = class extends Ne {
  constructor(e) {
    super("m3");
    this.nodeType = "Matrix3";
    this.value = e ?? new Matrix3();
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format("mat3(" + this.value.elements.join(", ") + ")", i, t);
  }
  get elements() {
    return this.value.elements;
  }
  set elements(e) {
    this.value.fromArray(e);
  }
};
var pt = class extends Ne {
  constructor(e) {
    super("m4");
    this.nodeType = "Matrix4";
    this.value = e ?? new Matrix4();
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format("mat4(" + this.value.elements.join(", ") + ")", i, t);
  }
  get elements() {
    return this.value.elements;
  }
  set elements(e) {
    this.value.fromArray(e);
  }
};
function By(n, r, e) {
  n.setUvTransform(e[0], e[1], r[0], r[1], 0, 0, 0);
}
var Ol = class extends li {
  constructor(e, t) {
    super(new Matrix3());
    this.repeat = e;
    this.offset = t;
    By(this.value, e, t);
  }
  updateMatrix() {
    By(this.value, this.repeat, this.offset);
  }
};
var cr = class extends Ne {
  constructor(e = 1, t) {
    super("v4[]");
    this.nodeType = "Vector4Array";
    this.size = e, this.value = Array.isArray(t) ? t : t instanceof Vector4 ? new Array(e).fill(t) : new Array(e).fill(new Vector4(0));
  }
};
var ci = class extends ae {
  constructor(e, t, o, i) {
    super("v3");
    this.nodeType = "Blend";
    this.a = e, this.b = t, this.alpha = o, this.mode = i;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      let o = [];
      return o.push(this.a.build(e, "c")), o.push(this.b.build(e, "c")), o.push(this.alpha.build(e, "f")), o.push(this.mode.build(e, "i")), e.format("spe_blend(" + o.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("BlendNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var Bd = class extends ae {
  constructor(e, t) {
    super("v3");
    this.nodeType = "CustomColor";
    this.color = e, this.alpha = t, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      let o = e.include(Bd.Nodes.customColor);
      e.addFragmentVariable(this.calpha, "float");
      let i = [];
      return i.push(this.color.build(e, "v3")), i.push(this.mask ? `luminance(${this.mask.build(e, "v3")})` : "1.0"), i.push(this.alpha.build(e, "f")), i.push(this.calpha), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("CustomColorNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var Ro = Bd;
Ro.Nodes = function() {
  return { customColor: new U(`vec3 customColor(vec3 color, float mask, float alpha, out float calpha) {
				float lalpha = alpha * mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color;
			}`) };
}();
var Dd = class extends ae {
  constructor(e, t) {
    super("v3");
    this.nodeType = "CustomNormal";
    this.cnormal = e, this.alpha = t, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      let o = e.include(Dd.Nodes.customNormal);
      e.addFragmentVariable(this.calpha, "float");
      let i = [];
      return i.push(this.cnormal.build(e, "v3")), i.push("normal"), i.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), i.push(this.alpha.build(e, "f")), i.push(this.calpha), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("CustomNormalNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var di = Dd;
di.Nodes = function() {
  return { customNormal: new U(`vec3 customNormal(vec3 cnormal, vec3 norm, float mask, float alpha, out float calpha) {
				vec3 normal = packNormalToRGB( norm ).rgb;
				normal *= step( vec3(0.5), cnormal );

				float lalpha = alpha * mask;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

				return normal;
			}`) };
}();
var ui = class extends ae {
  constructor(e, t, o, i, s, l, c, u, a, d, p, f) {
    super("v3");
    this.nodeType = "CustomTexture";
    this.firstTime = true, this.texture = e, this.textureSize = t, this.crop = o, this.projection = i, this.axis = s, this.side = l, this.size = c, this.blending = u, this.mat = a, this.alpha = d, this.mode = p, this.isMask = f, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    e.require("position"), e.require("normal"), e.require("uv"), e.requires.uv = [true], e.extensions.shaderTextureLOD = true, e.extensions.derivatives = true;
    let o = `g${this.uuid.toString().replace(/-/g, "")}`, i;
    switch (this.projection.value) {
      case 3:
        i = e.include(ui.Nodes.cylindrical);
        break;
      case 2:
        i = e.include(ui.Nodes.spherical);
        break;
      case 1:
        let l = ["vec3(1.0, 0.0, 0.0)", "vec3(0.0, 1.0, 0.0)", "vec3(0.0, 0.0, 1.0)"][this.axis.value], c = new U(`
		vec3 ${o}_planarTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( (${o}_vCustomUv * 2. - 1.) / (size * .5), 1. ) / 2. + 0.5 ).xy;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				${this.side.value === 2 ? "" : `lalpha *= step(0.0, ${this.side.value === 1 ? "-1.0 * " : ""}dot(vObjectNormal, mat * ${l}));`}

				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				
				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}`);
        i = e.include(c);
        break;
      case 4:
        i = e.include(ui.Nodes.triplanar);
        break;
      default:
        i = e.include(ui.Nodes.uv);
        break;
    }
    if (this.projection.value === 1 && this.firstTime) {
      e.addVertexParsCode(`varying vec2 ${o}_vCustomUv;`), e.addFragmentParsCode(`varying vec2 ${o}_vCustomUv;`);
      let l = ["zy", "xz", "xy"][this.axis.value];
      e.addVertexFinalCode(`${o}_vCustomUv = (1. + (transformed.${l})) / 2.;`);
    }
    e.addFragmentVariable(this.calpha, "float");
    let s = [];
    return s.push("normal"), s.push(this.texture.generate(e, "t")), s.push(this.textureSize.build(e, "v2")), s.push(this.crop.build(e, "f")), s.push(this.mat.build(e, "mat3")), s.push(this.size.build(e, "v2")), s.push(this.blending.build(e, "f")), s.push(this.isMask.build(e, "b")), s.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), s.push(this.alpha.build(e, "f")), s.push(this.mode.build(e, "i")), s.push(this.calpha), this.firstTime = !this.firstTime, e.format(i + "(" + s.join(",") + ")", this.getType(e), t);
  }
};
var pi = ui;
pi.Nodes = function() {
  let e = new U(`
vec3 cylindricalTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(position);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float scaledHeight = position.y / (size.y * 0.5);
                float v =  (scaledHeight / 2.) + .5;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;

				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;
				
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}
`), t = new U(`
vec3 sphericalTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(vPosition);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float v = 0.5 + asin(posN.y) / 3.1415;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;
				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}
`), o = new U(`vec3 uvTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;

				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				
				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}`), i = new U(`vec3 triplanarTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha) {
				vec3 p = position;
				vec2 uv0 = (1.0 + p.xy) / 2.0;     
				vec2 uv1 = (1.0 + p.zy) / 2.0;		
				vec2 uv2 = (1.0 + p.xz) / 2.0;		
	
				uv0 = (mat * vec3((uv0 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;
				uv1 = (mat * vec3((uv1 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;
				uv2 = (mat * vec3((uv2 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;

				// Range from 3 to 128 seems to be good
				float exponent = (1.0 - blending) * 125.0 + 3.0;

				vec3 n = vObjectNormal;
				vec3 weights = abs(normalize(n));
				weights = pow(weights, vec3(exponent));
				weights /= dot(weights, vec3(1.0));

				// Derivatives for LOD
				vec2 df0 = fwidth(uv0);
				vec2 df1 = fwidth(uv1);
				vec2 df2 = fwidth(uv2);
				if (df0.x > 0.5) df0.x = 0.0;
				if (df1.x > 0.5) df1.x = 0.0;
				if (df2.x > 0.5) df2.x = 0.0;

				#ifdef GL_EXT_shader_texture_lod
                	vec4 tmp = 
						texture2DLodEXT(tex, uv0, log2(max(df0.x, df0.y)*min(textureSize.x, textureSize.y))) * weights.z + 
						texture2DLodEXT(tex, uv1, log2(max(df1.x, df1.y)*min(textureSize.x, textureSize.y))) * weights.x + 
						texture2DLodEXT(tex, uv2, log2(max(df2.x, df2.y)*min(textureSize.x, textureSize.y))) * weights.y;
				#else
                	vec4 tmp = 
						textureLod(tex, uv0, log2(max(df0.x, df0.y)*min(textureSize.x, textureSize.y))) * weights.z + 
						textureLod(tex, uv1, log2(max(df1.x, df1.y)*min(textureSize.x, textureSize.y))) * weights.x + 
						textureLod(tex, uv2, log2(max(df2.x, df2.y)*min(textureSize.x, textureSize.y))) * weights.y;
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;

				// Apply cropping across all 3 planes
				if ( crop > 0.5 ) {
					if ( uv0.x < 0.0 || uv0.x > 1.0 || uv0.y < 0.0 || uv0.y > 1.0 )  {
						lalpha = 0.0;
					}
					if ( uv1.x < 0.0 || uv1.x > 1.0 || uv1.y < 0.0 || uv1.y > 1.0 )  {
						lalpha = 0.0;
					}
					if ( uv2.x < 0.0 || uv2.x > 1.0 || uv2.y < 0.0 || uv2.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;//n * 0.5 + 0.5;
			}			
			`);
  return { cylindrical: e, spherical: t, uv: o, triplanar: i };
}();
var fi = class extends ae {
  constructor(e, t, o, i, s, l, c, u, a, d, p, f) {
    super("v3");
    this.nodeType = "Depth";
    this.gradientType = e, this.smooth = t, this.near = o, this.far = i, this.isVector = s, this.isWorldSpace = l, this.origin = c, this.direction = u, this.colors = a, this.steps = d, this.isMask = f, this.alpha = p, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    let o = `g${this.uuid.toString().replace(/-/g, "")}`, i = new U(`vec3 ${o}_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[${o}_MAX_COLORS], float steps[${o}_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {
               vec4 color = colors[0];
               #ifdef ${o}_IS_VECTOR
                   #ifdef ${o}_LINEAR
                       #ifdef ${o}_WORLDSPACE
                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);
                       #else
                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);
                       #endif
                   #else
                       #ifdef ${o}_WORLDSPACE
                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);
                       #else
                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);
                       #endif
                   #endif
               #else
                   float dist = length(vWPosition - cameraPosition);
			       float depth = ( dist - near ) / ( far - near );
               #endif


              float p;
              #ifdef ${o}_SMOOTH
				for ( int i = 1; i < ${o}_MAX_COLORS; i++ ) {
						p = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}
              #else
                for ( int i = 1; i < ${o}_MAX_COLORS; i++ ) {
                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);
                   color = mix(color, colors[i], p);
                 }
              #endif

               float lalpha = alpha * color.a * mask;
               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
			   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
			   
               return color.rgb;
			}`, [fi.Nodes.vectorLinearWorldSpaceDepth, fi.Nodes.vectorLinearObjectSpaceDepth, fi.Nodes.vectorSphericalObjectSpaceDepth, fi.Nodes.vectorSphericalWorldSpaceDepth]);
    if (e.isShader("fragment")) {
      e.define(`${o}_MAX_COLORS`, this.colors.value.length), this.smooth.value && e.define(`${o}_SMOOTH`), this.isVector.value > 0.5 && e.define(`${o}_IS_VECTOR`), this.gradientType.value === 0 && e.define(`${o}_LINEAR`), this.isWorldSpace.value > 0.5 && e.define(`${o}_WORLDSPACE`), e.require("worldPosition"), e.addFragmentVariable(this.calpha, "float");
      let s = e.include(i), l = [];
      return l.push(this.near.build(e, "f")), l.push(this.far.build(e, "f")), l.push(this.origin.build(e, "v3")), l.push(this.direction.build(e, "v3")), l.push(this.colors.build(e, "v4[]")), l.push(this.steps.build(e, "f[]")), l.push(this.isMask.build(e, "b")), l.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), l.push(this.alpha.build(e, "f")), l.push(this.calpha), e.format(s + "(" + l.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("DepthNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var mi = fi;
mi.Nodes = function() {
  let e = new U(`float vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`), t = new U(`float vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(position.x - origin.x) + n.y*(position.y - origin.y) + n.z*(position.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`), o = new U(`float vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(vWPosition - origin);
               return ( dist - near ) / ( far - near );
            }`), i = new U(`float vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(position - origin);
               return ( dist - near ) / ( far - near );
            }`);
  return { vectorLinearWorldSpaceDepth: e, vectorLinearObjectSpaceDepth: t, vectorSphericalWorldSpaceDepth: o, vectorSphericalObjectSpaceDepth: i };
}();
var Ps = class extends ae {
  constructor(e, t, o, i, s, l, c, u) {
    super("v3");
    this.nodeType = "Fresnel";
    this.color = e, this.bias = t, this.scale = o, this.intensity = i, this.factor = s, this.isMask = u, this.alpha = l, this.mode = c, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.require("vWorldViewDir"), e.require("worldNormal"), e.isShader("fragment")) {
      e.addFragmentVariable(this.calpha, "float");
      let o = new U(`vec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {
					float fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );

					float lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

					return color;
				}`), i = e.include(o), s = [];
      return s.push(this.color.build(e, "c")), s.push(this.bias.build(e, "f")), s.push(this.scale.build(e, "f")), s.push(this.intensity.build(e, "f")), s.push(this.factor.build(e, "f")), s.push(this.isMask.build(e, "b")), s.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), s.push(this.alpha.build(e, "f")), s.push(this.mode.build(e, "i")), s.push(this.calpha), e.format(i + "(" + s.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("FresnelNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var Gd = class extends ae {
  constructor(e, t, o, i, s, l, c, u, a) {
    super("v3");
    this.nodeType = "Gradient";
    this.gradientType = e, this.smooth = t, this.colors = o, this.steps = i, this.offset = s, this.morph = l, this.angle = c, this.isMask = a, this.alpha = u, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      e.define("GRAD_MAX", 10), e.require("uv"), e.requires.uv = [true], e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Gd.Nodes.gradient), i = [];
      return i.push(this.gradientType.build(e, "i")), i.push(this.smooth.build(e, "b")), i.push(this.colors.build(e, "v4[]")), i.push(this.steps.build(e, "f[]")), i.push(this.offset.build(e, "v2")), i.push(this.morph.build(e, "v2")), i.push(this.angle.build(e, "f")), i.push(this.isMask.build(e, "b")), i.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), i.push(this.alpha.build(e, "f")), i.push(this.calpha), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("GradientNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var hi = Gd;
hi.Nodes = function() {
  return { gradient: new U(`vec3 gradient(int gradientType, bool smoothed, vec4 colors[GRAD_MAX], float steps[GRAD_MAX], vec2 offset, vec2 morph, float angle, bool isMask, float mask, float alpha, out float calpha) {
				vec4 color = colors[0];
				vec2 m = morph / vUv.xy;
				vec2 rot = vec2( 0.5 + m.x, m.y );
				vec2 dt = vec2(
					cos( angle ) * rot.x - sin( angle ) * rot.y,
					sin( angle ) * rot.x + cos( angle ) * rot.y
				);
				vec2 pt = ( vUv - 0.5 + offset ) / 2.0 + dt / 2.0;
				float t = dot( pt, dt ) / dot( dt, dt );
				if ( gradientType == 1 ) {
					t = distance (
						( vUv + morph ) * 3.0,
						( vUv + offset ) + 1.0
					) + angle;
				} else if ( gradientType == 2 ) {
					float polar = atan(
						vUv.x + morph.x - 0.5 + offset.x,
						vUv.y + morph.y - 0.5 + offset.y
					) * -1.0;
					t = fract( ( angle / PI / -2.0 ) + 0.5 * ( polar / PI ) );
				}

				float p;
				if (smoothed) {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}

				} else {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], p);
					}
				}

				float lalpha = alpha * color.a * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
				
				return color.xyz;
			}`) };
}();
var Rd = class extends ae {
  constructor(e, t, o, i) {
    super("v3");
    this.nodeType = "Matcap";
    this.texture = e, this.isMask = i, this.alpha = t, this.mode = o, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Rd.Nodes.matcap);
      e.require("normal"), e.requires.normal = true;
      let i = [];
      return i.push(this.texture.generate(e, "t")), i.push("normal"), i.push(this.isMask.build(e, "b")), i.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), i.push(this.alpha.build(e, "f")), i.push(this.mode.build(e, "i")), i.push(this.calpha), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("MatcapNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var yi = Rd;
yi.Nodes = function() {
  return { matcap: new U(`vec3 matcap(sampler2D matcapTex, vec3 normal, bool isMask, float mask, float alpha, int mode, out float calpha) {
					vec3 viewDir = normalize( vViewPosition );
					vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
					vec3 y = cross( viewDir, x );
					vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks
					vec4 matcapColor = texture2D( matcapTex, uv );

					float lalpha = alpha * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
					
					return matcapColor.rgb;
            	}`) };
}();
var Ts = ((s) => (s.SIMPLEX = "simplex3d", s.SIMPLEX_FRACTAL = "simplex3dFractal", s.ASHIMA = "simplexAshima", s.FBM = "fbm", s.PERLIN = "perlin", s.VORONOI = "voronoi", s))(Ts || {});
var it = function() {
  let r = new U(`vec3 random3(vec3 c) {
			float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
			vec3 r;
			r.z = fract(512.0*j);
			j *= .125;
			r.x = fract(512.0*j);
			j *= .125;
			r.y = fract(512.0*j);
			return r-0.5;
		}`), e = new U(`float simplex3d(vec3 p) {
			 vec3 s = floor(p + dot(p, vec3(F3)));
			 vec3 x = p - s + dot(s, vec3(G3));
			 
			 vec3 e = step(vec3(0.0), x - x.yzx);
			 vec3 i1 = e*(1.0 - e.zxy);
			 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				
			 vec3 x1 = x - i1 + G3;
			 vec3 x2 = x - i2 + 2.0*G3;
			 vec3 x3 = x - 1.0 + 3.0*G3;
			 
			 vec4 w, d;
			 
			 w.x = dot(x, x);
			 w.y = dot(x1, x1);
			 w.z = dot(x2, x2);
			 w.w = dot(x3, x3);
			 
			 w = max(0.6 - w, 0.0);
			 
			 d.x = dot(random3(s), x);
			 d.y = dot(random3(s + i1), x1);
			 d.z = dot(random3(s + i2), x2);
			 d.w = dot(random3(s + 1.0), x3);
			 
			 w *= w;
			 w *= w;
			 d *= w;
			 
			 return dot(d, vec4(52.0));
		}`, [r]);
  e.keywords.F3 = new Se("float F3 0.3333333"), e.keywords.G3 = new Se("float G3 0.1666667");
  let t = new U(`float simplex3dFractal(vec3 m) {
			mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);
			mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);
			mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);
			return 0.5333333 * simplex3d(m * rot1)
				 + 0.2666667 * simplex3d(2.0 * m * rot2)
				 + 0.1333333 * simplex3d(4.0 * m * rot3)
				 + 0.0666667 * simplex3d(8.0 * m);
		}`, [e]), o = new U("vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}"), i = new U("vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}"), s = new U(`float simplexAshima(vec3 v) {
		  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
		  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
		  vec3 i  = floor(v + dot(v, C.yyy) );
		  vec3 x0 =   v - i + dot(i, C.xxx) ;
		  vec3 g = step(x0.yzx, x0.xyz);
		  vec3 l = 1.0 - g;
		  vec3 i1 = min( g.xyz, l.zxy );
		  vec3 i2 = max( g.xyz, l.zxy );
		  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		  vec3 x3 = x0 - 1. + 3.0 * C.xxx;
		  i = mod(i, 289.0 ); 
		  vec4 p = permute( permute( permute( 
					 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
		  float n_ = 1.0/7.0; // N=7
		  vec3  ns = n_ * D.wyz - D.xzx;
		  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
		  vec4 x_ = floor(j * ns.z);
		  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
		  vec4 x = x_ *ns.x + ns.yyyy;
		  vec4 y = y_ *ns.x + ns.yyyy;
		  vec4 h = 1.0 - abs(x) - abs(y);
		  vec4 b0 = vec4( x.xy, y.xy );
		  vec4 b1 = vec4( x.zw, y.zw );
		  vec4 s0 = floor(b0)*2.0 + 1.0;
		  vec4 s1 = floor(b1)*2.0 + 1.0;
		  vec4 sh = -step(h, vec4(0.0));
		  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
		  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
		  vec3 p0 = vec3(a0.xy,h.x);
		  vec3 p1 = vec3(a0.zw,h.y);
		  vec3 p2 = vec3(a1.xy,h.z);
		  vec3 p3 = vec3(a1.zw,h.w);
		  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
		  p0 *= norm.x;
		  p1 *= norm.y;
		  p2 *= norm.z;
		  p3 *= norm.w;
		  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
		  m = m * m;
		  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
										dot(p2,x2), dot(p3,x3) ) );
		}`, [o, i]), l = new U("vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}"), c = new U("vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}", [l]), u = new U(`float noise(vec3 p){
			vec3 a = floor(p);
			vec3 d = p - a;
			d = d * d * (3.0 - 2.0 * d);
			vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			vec4 k1 = perm(b.xyxy);
			vec4 k2 = perm(k1.xyxy + b.zzww);
			vec4 c = k2 + a.zzzz;
			vec4 k3 = perm(c);
			vec4 k4 = perm(c + 1.0);
			vec4 o1 = fract(k3 * (1.0 / 41.0));
			vec4 o2 = fract(k4 * (1.0 / 41.0));
			vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
			return o4.y * d.y + o4.x * (1.0 - d.y);
		}`, [c]), a = new U(`float fbm(vec3 x) {
			float v = 0.0;
			float a = 0.5;
			vec3 shift = vec3(100);
			for (int i = 0; i < NUM_OCTAVES; ++i) {
				v += a * noise(x);
				x = x * 2.0 + shift;
				a *= 0.5;
			}
			return v;
		}`, [u]);
  a.keywords.NUM_OCTAVES = new Se(`int NUM_OCTAVES ${5}`);
  let d = new U("vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}"), p = new U(`float perlin(vec3 P){
		  vec3 Pi0 = floor(P);
		  vec3 Pi1 = Pi0 + vec3(1.0);
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec3 Pf0 = fract(P);
		  vec3 Pf1 = Pf0 - vec3(1.0);
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 gx0 = ixy0 / 7.0;
		  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		  vec4 gx1 = ixy1 / 7.0;
		  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;
		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);
		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}`, [o, i, d]), f = new U(`float hashwithoutsine13(vec3 p3)
		{
			p3  = fract(p3 * .1031);
			p3 += dot(p3, p3.yzx + 33.33);
			return fract((p3.x + p3.y) * p3.z);
		}`), m = new U(`vec3 hashwithoutsine33(vec3 p3)
		{
			p3 = fract(p3 * vec3(.1031, .1030, .0973));
			p3 += dot(p3, p3.yxz+33.33);
			return fract((p3.xxy + p3.yxx)*p3.zyx);
		}`), h = new U(`float metric(in vec3 p)
		{
			// L2 
			return length(p);

			// Chebyshev 
			// vec3 a = abs(p);
			// return max(a.x, max(a.y, a.z));
		}`), y = new U(`float smin( float a, float b, float k )
		{
			float h = smoothstep(0.0, 1.0, 0.5 + 0.5 * (b - a) / k);
			float correction = k * h * (1.0 - h);
			return mix(b, a, h) - correction;
		}`), g = new U(`float smax( float a, float b, float k )
		{
			float h = smoothstep(1.0, 0.0, 0.5 + 0.5 * (a - b) / k);
			float correction = k * h * (1.0 - h);
			return mix(a, b, h) + correction;
		}`), v = new U(`float remap(float value, float input_min, float input_max, float output_min, float output_max) {
			// Compute width of each interval
			float input_width = input_max - input_min;
			float output_width = output_max - output_min;
		
			// Convert input range into a 0-1 range 
			float scaled = (value - input_min) / input_width;
		
			// Convert the 0-1 range into a value in output range
			return output_min + (scaled * output_width);
		}`), b = new U(`float voronoi(in vec3 x, in int style, in float smoothness, in float seed, in int quality) 
		{
			// Integer and fractional parts of this point's coordinates
			ivec3 p = ivec3(floor(x));
			vec3 f = fract(x);

			// Different variables that we will use to construct noise:
			//
			// f1: distance to the closest feature point
			// f2: distance to the second closest feature point
			// e: distance to the closest edge (cell boundary)
			//
			// We also compute "smooth" versions of all of the above quantites, essentially
			// replacing "hard" minimums with "smooth" minimums (described by IQ)
			float f1_smooth = 8.0;
			float f1 = 8.0;
			float f2_smooth = 8.0;
			float f2 = 8.0;
			float e_smooth = 8.0;
			float e = 8.0;

			// Variables stored from closest cell
			ivec3 mb;
			vec3 mr; 

			int steps = quality;
			
			for (int x = -steps; x <= steps; x++) 
			for (int y = -steps; y <= steps; y++)
			for (int z = -steps; z <= steps; z++)
			{
				ivec3 b = ivec3(x, y, z);
				vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
				float d = length(r);
				
				f1_smooth = smin(d, f1_smooth, smoothness);

				// Store un-smoothed distances too 
				if (d < f1) 
				{
					f2 = f1;
					f1 = d;

					mb = ivec3(x, y, z);
					mr = r;
				} 
				else if (d < f2) 
				{
					f2 = d;
				}
			}	
			
			float id = hashwithoutsine13(vec3(p + mb) + seed);

			// Second pass for edge distance  
			for (int x = -steps; x <= steps; x++) 
			for (int y = -steps; y <= steps; y++)
			for (int z = -steps; z <= steps; z++)
			{
				// Start search at the cell that contains the closest point to "x" (found in 1st pass)
				ivec3 b = mb + ivec3(x, y, z);
				vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
				float d1 = dot(0.5 * (mr + r), (r - mr)); 				// IQ normalizes "r - mr" but that breaks things for the smooth version?
				float d2 = dot(0.5 * (mr + r), normalize(r - mr));

				e_smooth = smin(d1, e_smooth, smoothness);

				e = min(e, d2);

				// Also compute a smooth version of F2 in this pass
				{
					ivec3 b = ivec3(x, y, z);
					if (b != mb) 
					{
						vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
						float d = length(r);

						f2_smooth = smin(d, f2_smooth, smoothness);
					}
				}
			}

			// Different visualization modes 
			if (style == 0) 
			{
				return f1_smooth;
			}
			if (style == 1) 
			{
				return f2_smooth;
			}
			if (style == 2) 
			{
				return f2_smooth - f1_smooth;
				
				// "Pebbles" also cool
				//return step(0.2, f2_smooth - f1_smooth);
			}
			if (style == 3) 
			{
				// This one is really good for rock / stone effects
				float a = f1; 
				float b = f2;
				float k = 3.0;
				float h = max(k - abs(a - b), 0.0) / k;
				float final = min(a, b) - h * h * k * (1.0 / 4.0);
				return final;
			}
			if (style == 4) 
			{
				// Some random adjustments to make this style stand out more 
				return exp(5.0 * e_smooth);
			}
			if (style == 5) 
			{
				return pow(f1_smooth, 3.0);
			}
			if (style == 6) 
			{				
				const float eps = 0.0125;

				// Thicker lines as the user increases the smoothness slider
				float thickness = smoothness * 0.25 + eps;

				// Blurrier lines as the user increases the smoothness slider
				float blur = pow(smoothness, 3.0) * 0.25 + eps;

				return smoothstep(
					thickness - thickness * blur, 
					thickness + thickness * blur, 
					e
				);
			}
			if (style == 7) 
			{
				return hashwithoutsine13(vec3(p + mb) + seed);
			}
		}
	`, [f, m, h, y, g, v]);
  return { simplex: e, simplexFractal: t, simplexAshima: s, fbm: a, perlin: p, voronoi: b };
}();
var gi = class extends ae {
  constructor(e, t, o, i, s, l, c, u, a, d, p, f, m, h, y, g, v, b, w) {
    super("v3");
    this.nodeType = "Noise";
    this.scale = e, this.size = t, this.move = o, this.fA = i, this.fB = s, this.distortion = l, this.colorA = c, this.colorB = u, this.colorC = a, this.colorD = d, this.noiseType = f, this.voronoiStyle = h, this.highCut = y, this.lowCut = g, this.smoothness = v, this.seed = b, this.quality = w, this.isMask = m, this.alpha = p, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t, o, i, s) {
    e.require("uv"), e.requires.uv = [true], e.addFragmentVariable(this.calpha, "float");
    let l = Object.values(Ts)[this.noiseType.value], c = l == "voronoi" ? `
		float v = ${l}(st + move, voronoiStyle, smoothness, seed, quality);

		// Apply clipping to colors
		v = remap(v, lowCut, highCut, 0.0, 1.0);
		v = smax(v, 0.0, smoothness * 0.25);
		v = smin(v, 1.0, smoothness * 0.25);

		// Note that the voronoi mode only uses colors "A" and "C" from the UI 
		vec4 color = mix(colorA, colorC, v); 
		` : `
		vec3 q = vec3(${l}(st),
					   ${l}(st + vec3(1.0)),
					   ${l}(st + vec3(1.0)));
		vec3 r = vec3(${l}(st + vec3(distortion, 1.0) * q + vec3(fA, 1.0) + move),
					  ${l}(st + vec3(distortion, 1.0) * q + vec3(fB, 1.0) + move), 
					  ${l}(st * q));
		float f = ${l}(st + r);
		vec4 color;
		color = mix(colorA, colorB, clamp((f * f) * 4.0, 0.0, 1.0));
		color = mix(color, colorC, clamp(length(q), 0.0, 1.0));
		color = mix(color, colorD, clamp(length(r.x), 0.0, 1.0));
		`, u = new U(`vec3 ${l}customNoise(float scale, vec3 size, float move, vec2 fA, vec2 fB, vec2 distortion, vec4 colorA, vec4 colorB, vec4 colorC, vec4 colorD, int voronoiStyle, float highCut, float lowCut, float smoothness, float seed, int quality, bool isMask, float mask, float alpha, out float calpha) 
			{
                // Prevent scale of zero 
				scale = max(abs(scale), 0.001);

				vec3 st = position / size;
				st /= scale;

				${c}

				float lalpha = alpha * color.a * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return clamp(color, 0.0, 1.0).rgb;
			}`, [it.simplex, it.simplexFractal, it.simplexAshima, it.fbm, it.perlin, it.voronoi]), a = e.include(u), d = [];
    return d.push(this.scale.build(e, "f")), d.push(this.size.build(e, "v3")), d.push(this.move.build(e, "f")), d.push(this.fA.build(e, "v2")), d.push(this.fB.build(e, "v2")), d.push(this.distortion.build(e, "v2")), d.push(this.colorA.build(e, "v4")), d.push(this.colorB.build(e, "v4")), d.push(this.colorC.build(e, "v4")), d.push(this.colorD.build(e, "v4")), d.push(this.voronoiStyle.build(e, "i")), d.push(this.highCut.build(e, "f")), d.push(this.lowCut.build(e, "f")), d.push(this.smoothness.build(e, "f")), d.push(this.seed.build(e, "f")), d.push(this.quality.build(e, "i")), d.push(this.isMask.build(e, "b")), d.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), d.push(this.alpha.build(e, "f")), d.push(this.calpha), e.format(a + "(" + d.join(",") + ")", this.getType(e), t);
  }
};
gi.numOctaves = 5;
var Vd = class extends ae {
  constructor(e, t, o, i, s, l, c, u, a, d, p, f, m, h, y, g) {
    super("v3");
    this.nodeType = "Outline";
    this.firstTime = true, this.outlineColor = e, this.contourColor = t, this.outlineWidth = o, this.contourWidth = i, this.contourThreshold = s, this.outlineThreshold = l, this.contourFrequency = c, this.outlineSmoothing = u, this.contourDirection = a, this.positionalLines = d, this.compensation = p, this.resolution = f, this.normalMap = m, this.depthMap = h, this.pixelRatio = y, this.alpha = g, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    let o = `g${this.uuid.toString().replace(/-/g, "")}`;
    if (e.require("vWorldViewDir"), e.require("worldNormal"), e.extensions.derivatives = true, this.compensation.value && e.define("OUTLINE_COMPENSATION", `${o}_offset`), this.firstTime) {
      let i = this.outlineWidth.build(e, "f"), s = this.resolution.build(e, "v2"), l = this.compensation.build(e, "b"), c = this.pixelRatio.build(e, "f");
      e.addVertexParsVariable("randomColor", "attribute vec3"), e.addVertexParsVariable("extrudeNormal", "attribute vec3"), e.addVertexParsVariable(i, "uniform float"), e.addVertexParsVariable(s, "uniform vec2"), e.addVertexParsVariable(l, "uniform bool"), e.addVertexParsVariable(c, "uniform float"), e.addVertexParsVariable("vID", "flat out float"), e.addFragmentParsVariable("vID", "flat in float"), e.addVertexFinalCode(`
                vID = randomColor.r;
                vec2 ${o}_offset = vec2(0.0);
                if (${l}) {
                    vec4 ${o}_clipPosition = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
                    // NOTE: For certain shapes, like spheres, we get incorrect extrusion when the
                    // normals face the camera directly. So we hackily fix this by offsetting the normal
                    // by a tiny amount.
                    vec3 ${o}_clipNormal = mat3(projectionMatrix) * (mat3(modelViewMatrix) * extrudeNormal) + 0.0000001;
                    ${o}_offset = normalize(${o}_clipNormal.xy) / ${s} * (${i} / 2.0) * ${o}_clipPosition.w * 2.0 * ${c};
                    ${o}_clipPosition.xy += ${o}_offset;
                    // TODO(MAX): To handle multiple outline layers, we only want to extrude
                    // if this offset is the biggest of all the potential offsets
                    gl_Position = ${o}_clipPosition;
                }
            `);
    }
    if (e.isShader("fragment")) {
      e.require("uv"), e.requires.uv = [true], e.addFragmentVariable(this.calpha, "float");
      let i = e.include(Vd.Nodes.outline), s = [];
      return s.push(this.outlineColor.build(e, "c")), s.push(this.contourColor.build(e, "c")), s.push(this.outlineWidth.build(e, "f")), s.push(this.contourWidth.build(e, "f")), s.push(this.contourThreshold.build(e, "f")), s.push(this.outlineThreshold.build(e, "f")), s.push(this.contourFrequency.build(e, "f")), s.push(this.outlineSmoothing.build(e, "f")), s.push(this.contourDirection.build(e, "v3")), s.push(this.positionalLines.build(e, "b")), s.push(this.resolution.build(e, "v2")), s.push(this.normalMap.getTexture(e, "t")), s.push(this.depthMap.getTexture(e, "t")), s.push(this.pixelRatio.build(e, "f")), s.push(this.compensation.build(e, "b")), s.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), s.push(this.alpha.build(e, "f")), s.push(this.calpha), this.firstTime = !this.firstTime, e.format(i + "(" + s.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("OutlineNode is not compatible with " + e.shader + " shader."), "";
  }
};
var xi = Vd;
xi.Nodes = function() {
  let e = new U(`
float sobelSample(sampler2D t, sampler2D d, vec2 uv, vec2 resolution, float outlineWidth, float pixelRatio)
{
    vec2 halton = haltonSequence[frameIndex];
    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
    float temporalAngle  = temporalOffset * PI2;

    vec2 texelSize = (vec2(1.0) / resolution);
    vec2 offsetSize = texelSize * outlineWidth * pixelRatio;

    vec2 uvSamples[9];
    vec4 normalSamples[9];

	uvSamples[0] = uv + vec2( -offsetSize.x, -offsetSize.y) + (vogelDiskSample(0, 9, temporalAngle) * texelSize);
	uvSamples[1] = uv + vec2(0.0, -offsetSize.y) + (vogelDiskSample(1, 9, temporalAngle) * texelSize);
	uvSamples[2] = uv + vec2(  offsetSize.x, -offsetSize.y) + (vogelDiskSample(2, 9, temporalAngle) * texelSize);
	uvSamples[3] = uv + vec2( -offsetSize.x, 0.0) + (vogelDiskSample(3, 9, temporalAngle) * texelSize);
	uvSamples[4] = uv;
	uvSamples[5] = uv + vec2(  offsetSize.x, 0.0) + (vogelDiskSample(5, 9, temporalAngle) * texelSize);
	uvSamples[6] = uv + vec2( -offsetSize.x, offsetSize.y) + (vogelDiskSample(6, 9, temporalAngle) * texelSize);
	uvSamples[7] = uv + vec2(0.0, offsetSize.y) + (vogelDiskSample(7, 9, temporalAngle) * texelSize);
	uvSamples[8] = uv + vec2(  offsetSize.x, offsetSize.y) + (vogelDiskSample(8, 9, temporalAngle) * texelSize);


    normalSamples[0] = texture2D(t, uvSamples[0]);
    normalSamples[1] = texture2D(t, uvSamples[1]);
    normalSamples[2] = texture2D(t, uvSamples[2]);
    normalSamples[3] = texture2D(t, uvSamples[3]);
    normalSamples[4] = texture2D(t, uvSamples[4]);
    normalSamples[5] = texture2D(t, uvSamples[5]);
    normalSamples[6] = texture2D(t, uvSamples[6]);
    normalSamples[7] = texture2D(t, uvSamples[7]);
    normalSamples[8] = texture2D(t, uvSamples[8]);

    float depthBias = 0.0001;
    // TODO(MAX): Can we somehow reduce the number of conditionals here with MATH?!
    if (normalSamples[0].a != vID && normalSamples[0].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[0]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[1].a != vID && normalSamples[1].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[1]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[2].a != vID && normalSamples[2].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[2]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[3].a != vID && normalSamples[3].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[3]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }


    if (normalSamples[4].a != vID && normalSamples[4].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[4]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[5].a != vID && normalSamples[5].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[5]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[6].a != vID && normalSamples[6].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[6]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[7].a != vID && normalSamples[7].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[7]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[8].a != vID && normalSamples[8].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[8]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    vec3 sobel_edge_h = normalSamples[2].rgb + (2.0*normalSamples[5].rgb) + normalSamples[8].rgb - (normalSamples[0].rgb + (2.0*normalSamples[3].rgb) + normalSamples[6].rgb);
  	vec3 sobel_edge_v = normalSamples[0].rgb + (2.0*normalSamples[1].rgb) + normalSamples[2].rgb - (normalSamples[6].rgb + (2.0*normalSamples[7].rgb) + normalSamples[8].rgb);

    float edgeNormal = sqrt(dot(sobel_edge_h, sobel_edge_h) + dot(sobel_edge_v, sobel_edge_v));
    return edgeNormal;
}
`);
  return { outline: new U(`vec3 outline(vec3 outlineColor, vec3 contourColor, float outlineWidth, float contourWidth, float outlineThreshold, float contourThreshold, float outlineSmoothing, float contourFrequency, vec3 contourDirection, bool positionalLines, vec2 resolution, sampler2D normalMap, sampler2D depthMap, float pixelRatio, bool compensation, float mask, float alpha, out float calpha) {
                vec3 result = outlineColor;
                float resultAlpha = 0.0;

                vec3 N = normalize(vWNormal);
                vec2 nuv = (gl_FragCoord.xy / resolution);
                float sobelSample = compensation ? sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth / 2., pixelRatio) : sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth, pixelRatio);
                resultAlpha = smoothstep(outlineThreshold - outlineSmoothing, outlineThreshold + outlineSmoothing, sobelSample);

                //resultAlpha = 1.0;
                //result = vec3(sobelSample);

                float t = 1.0 - contourThreshold;
                if(positionalLines) {
                    vec3 NDir = position * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float f  = fract(NT * contourFrequency * 0.01);
                    float df = fwidth(NT * contourFrequency);

                    float g = smoothstep(df * (contourWidth * 0.01), df * (contourWidth * 0.01 * 2.0), f);
                    if (g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0;
                    }
                 }
                 else {
                    vec3 NDir = N * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float df = fwidth(NT * contourThreshold);
                    float f = sin(NT * 1.0 * contourFrequency);
                    float g = smoothstep(0.0, df * contourWidth, 1.0 - f);

                    if (df > (t * 0.5) && g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0 - g;
                    }
                 }

                 float lalpha = alpha * resultAlpha * mask;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				 
                 return result;
             }`, [e]) };
}();
var Nr = class extends ae {
  constructor(e, t, o, i, s, l, c, u, a, d, p, f, m, h, y, g, v, b) {
    super("v3");
    this.nodeType = "Pattern";
    this.style = e, this.projection = t, this.axis = o, this.blending = i, this.offset = s, this.colorA = l, this.colorB = c, this.frequency = u, this.size = a, this.variation = d, this.smoothness = p, this.zigzag = f, this.rotation = m, this.vertical = h, this.horizontal = y, this.sides = g, this.isMask = b, this.alpha = v, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      e.require("position"), e.require("uv"), e.requires.uv = [true], e.require("normal"), e.requires.normal = true, e.addFragmentVariable(this.calpha, "float");
      let o;
      switch (this.style.value) {
        case 0:
          o = "circle";
          break;
        case 1:
          o = "ring";
          break;
        case 2:
          o = "polygon";
          break;
        case 3:
          o = "xcross";
          break;
        case 4:
          o = "diamond";
          break;
        case 5:
          o = "checkerboard";
          break;
        case 6:
          o = "line";
          break;
        case 7:
          o = "wave";
          break;
        default:
          o = "circle";
          break;
      }
      let i = `g${this.uuid.toString().replace(/-/g, "")}`, s = new U(`float hashwithoutsine12(vec2 p)
				{
					vec3 p3 = fract(vec3(p.xyx) * .1031);
					p3 += dot(p3, p3.yzx + 33.33);
					return fract((p3.x + p3.y) * p3.z);
				}`), l = new U(`vec2 rotate_uv(in vec2 uv, float a, bool repeat) 
				{
					const float mid = 0.5;
					float radians = a * (PI / 180.0);
					vec2 rotated = vec2(
						cos(radians) * (uv.x - mid) + sin(radians) * (uv.y - mid) + mid,
						cos(radians) * (uv.y - mid) - sin(radians) * (uv.x - mid) + mid
					);
					return repeat ? fract(rotated): rotated;
				}`), c = "";
      if (this.projection.value === 4) {
        let p = this.style.value === 2 ? `${o}(uv0, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)` : `${o}(uv0, frequency, size, variation, smoothness_remapped, zigzag, rotation)`, f = this.style.value === 2 ? `${o}(uv1, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)` : `${o}(uv1, frequency, size, variation, smoothness_remapped, zigzag, rotation)`, m = this.style.value === 2 ? `${o}(uv2, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)` : `${o}(uv2, frequency, size, variation, smoothness_remapped, zigzag, rotation)`;
        c = `
				vec3 p = position;
				float factor = 0.0125;
				vec2 uv0 = fract(p.xy * factor);
				vec2 uv1 = fract(p.zy * factor);
				vec2 uv2 = fract(p.xz * factor);
				
				uv0 = rotate_uv(uv0 + offset, rotation, true);
				uv1 = rotate_uv(uv1 + offset, rotation, true);
				uv2 = rotate_uv(uv2 + offset, rotation, true);
	
				float d0 = ${p};
				float d1 = ${f};
				float d2 = ${m};
				
				// Range from 3 to 128 seems to be good
				float exponent = (1.0 - blending) * 125.0 + 3.0;

				vec3 n = vObjectNormal;
				vec3 weights = abs(normalize(n));
				weights = pow(weights, vec3(exponent));
				weights /= dot(weights, vec3(1.0));
				d0 *= weights.z;
				d1 *= weights.x;
				d2 *= weights.y;
				float draw = d0 + d1 + d2;
	
				vec2 custom_uv = uv0 * weights.z + uv1 * weights.x + uv2 * weights.y;
				`;
      } else {
        let p = this.style.value === 2 ? `${o}(custom_uv, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)` : `${o}(custom_uv, frequency, size, variation, smoothness_remapped, zigzag, rotation)`, f = "";
        this.axis.value === 0 ? f = `float radius = length(p);
					float theta = atan(p.y, p.z);
					float phi = acos(p.x / radius);` : this.axis.value === 1 ? f = `float radius = length(p);
					float theta = atan(p.x, p.z);
					float phi = acos(p.y / radius);` : (this.axis.value, f = `float radius = length(p);
					float theta = atan(p.y, p.x);
					float phi = acos(p.z / radius);`);
        let m = "";
        switch (this.projection.value) {
          case 0:
            m = "custom_uv = vUv.st;";
            break;
          case 1:
            break;
          case 2:
            m = `
							vec3 p = position;
							${f}
							custom_uv = vec2(theta, phi);
							custom_uv /= PI;
							`;
            break;
          case 3:
            break;
          default:
            break;
        }
        c = `
				vec2 custom_uv;
				${m}
	
				custom_uv += offset;
				custom_uv = fract(custom_uv);
				custom_uv = rotate_uv(custom_uv, rotation, true);
	
				float draw = ${p};
				`;
      }
      let u = new U(`vec3 ${i}_pattern(vec3 normal, float blending, int style, vec2 offset, vec4 colorA, vec4 colorB, vec2 frequency, float size, float variation, float smoothness, float zigzag, float rotation, vec2 vertical, vec2 horizontal, int sides, bool isMask, float mask, float alpha, out float calpha) {
					const float TWO_PI = PI * 2.0;
					float smoothness_remapped = pow(smoothness, 5.0);	

					${c}

					// Construct final output color
					vec4 color = mix(colorA, colorB, draw);
					color.a = clamp(color.a, 0.0, 1.0);

					// Apply cuts
					color.a *= 
						step(vertical.x, custom_uv.y) * 
						step(custom_uv.y, vertical.y);
					color.a *= 
						step(horizontal.x, abs(custom_uv.x)) * 
						step(abs(custom_uv.x), horizontal.y);

					// Accumulate alpha 
					float lalpha = alpha * clamp(color.a, 0.0, 1.0) * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

					return clamp(color, 0.0, 1.0).rgb;
				}`, [l, s, Nr.DrawFunctions.circle, Nr.DrawFunctions.ring, Nr.DrawFunctions.polygon, Nr.DrawFunctions.cross, Nr.DrawFunctions.diamond, Nr.DrawFunctions.checkerboard, Nr.DrawFunctions.line, Nr.DrawFunctions.wave]), a = e.include(u), d = [];
      return d.push("normal"), d.push(this.blending.build(e, "f")), d.push(this.style.build(e, "i")), d.push(this.offset.build(e, "v2")), d.push(this.colorA.build(e, "v4")), d.push(this.colorB.build(e, "v4")), d.push(this.frequency.build(e, "v2")), d.push(this.size.build(e, "f")), d.push(this.variation.build(e, "f")), d.push(this.smoothness.build(e, "f")), d.push(this.zigzag.build(e, "f")), d.push(this.rotation.build(e, "f")), d.push(this.vertical.build(e, "v2")), d.push(this.horizontal.build(e, "v2")), d.push(this.sides.build(e, "i")), d.push(this.isMask.build(e, "b")), d.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), d.push(this.alpha.build(e, "f")), d.push(this.calpha), e.format(a + "(" + d.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("PatterNode is not compatible with " + e.shader + " shader."), e.format("vec3(0.0)", this.getType(e), t);
  }
};
var vi = Nr;
vi.DrawFunctions = function() {
  let e = new U(`float hashwithoutsine12(vec2 p) {
				vec3 p3 = fract(vec3(p.xyx) * 0.1031);
				p3 += dot(p3, p3.yzx + 33.33);
				return fract((p3.x + p3.y) * p3.z);
			}`), t = new U(`vec2 tile_and_center(in vec2 uv, in vec2 frequency, in float variation, in float zigzag, in float rotation) {
                // Create tiles in UV-space
                uv *= frequency;

                // Integer coords
                vec2 i = floor(uv);

                // Offset every other row based on zigzag param, then compute fractional coords
                float row_offset = mod(i.y, 2.0);
                uv.x += row_offset * zigzag;
                vec2 f = fract(uv);

				// Rotate the tile itself:
				// const float mid = 0.5;
				// f = vec2(
				// 	cos(rotation) * (f.x - mid) + sin(rotation) * (f.y - mid) + mid,
				// 	cos(rotation) * (f.y - mid) - sin(rotation) * (f.x - mid) + mid
				// );
				// f = fract(f);

                f = f * 2.0 - 1.0;

				// Recompute integer coords after shifting - then, random value per tile 
				i = floor(uv);
				float rand = (hashwithoutsine12(i) * 5.0 + 1.0);
				float jitter = mix(1.0, rand, variation);
				f *= jitter;

                return f;
            }`, [e]), o = new U(`float circle(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(
                    -smoothness, 
                     smoothness, 
                     length(f) - size
                );
            }`, [t]), i = new U(`float ring(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);

				float d = length(f);
                const float inner_width = 0.5;

                float outer = smoothstep(-smoothness, smoothness, d - size);
                float inner = smoothstep(-smoothness, smoothness, d - size * inner_width);
				return outer + (1.0 - inner);   
            }`, [t]), s = new U(`float sdf_ngon(in vec2 p, in float r, in int n) {
                float an = (PI * 2.0) / float(n);
                float he = r * tan(0.5 * an);
                
                // Rotate to first sector
                p = -p.yx; 
                float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);
                vec2  cs = vec2(cos(bn), sin(bn));
                p = mat2(cs.x, -cs.y, cs.y, cs.x)*p;
            
                // Side of polygon
                return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x - r);
            }
            
            float polygon(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation, in int sides) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(-smoothness, smoothness, sdf_ngon(f, size, sides));
            }`, [t]), l = new U(`float sdf_cross(in vec2 p, in vec2 b, float r ) {
                p = abs(p); 
				p = (p.y > p.x) ? p.yx : p.xy;
                vec2  q = p - b;
                float k = max(q.y, q.x);
                vec2  w = (k > 0.0) ? q : vec2(b.y - p.x, -k);
                return sign(k) * length(max(w, 0.0)) + r;
            }
            
            // Avoid namespace conflicts 
            float xcross(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(-smoothness, smoothness, sdf_cross(f, vec2(size, size * 0.25), smoothness));
            }`, [t]), c = new U(`float ndot(vec2 a, vec2 b) { 
                return a.x*b.x - a.y*b.y; 
            }
            
            float sdf_diamond(in vec2 p, in vec2 b) {
                p = abs(p);
                float h = clamp(ndot(b - 2.0 * p, b) / dot(b, b), -1.0, 1.0);
                float d = length(p - 0.5 * b * vec2(1.0 - h, 1.0 + h));
                return d * sign(p.x * b.y + p.y * b.x - b.x * b.y);
            }

            float diamond(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
	            return smoothstep(-smoothness, smoothness, sdf_diamond(f, vec2(size)));
            }`, [t]), u = new U(`float checkerboard(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                uv *= frequency;
                vec2 i = floor(uv);

                float offset = mod(i.y, 2.0);

                uv.x += offset + zigzag * offset;
                float x = floor(uv.x);
                
                return mod(x, 2.0);
            }`), a = new U(`float line(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, 0.0, zigzag, rotation);
				
				// Different approach for variation param here
				float row = floor(uv * frequency).y;
				float rand = hashwithoutsine12(vec2(row));
				float s = mix(size, size * rand, variation);

				return smoothstep(
					s - smoothness, 
					s + smoothness, 
					abs(f.y)
				);
            }`, [t]), d = new U(`// Uses bisection 
            float udf_cos(in vec2 p, in float a, in float b, in float c, in float d) {
                // Convert all data to a primitive cosine wave
                p = c * (p - vec2(d, a));
                
                const float TWO_PI = PI * 2.0;

                // Reduce to principal half cycle
                p.x = mod(p.x, TWO_PI); 
                if (p.x > PI) {
                    p.x = TWO_PI - p.x;
                }
            
                // Find zero of derivative (minimize distance)
                float xa = 0.0;
                float xb = TWO_PI;

                // 24 bit precision
                for (int i = 0; i < 24; i++) {
                    float x = 0.5 * (xa + xb);
                    float y = x - p.x + b * c * sin(x) * (p.y - b * c * cos(x));
                    if (y < 0.0) xa = x; 
                    else xb = x;
                }
                float x = 0.5 * (xa + xb);
                
                // Compute distance    
                vec2 q = vec2(x, b * c * cos(x));
                return length(p - q) / c;
            }

            float wave(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                float repeat = frequency.x;
                uv *= repeat;
                vec2 i = floor(uv);
                float row_offset = mod(i.y, 2.0);
                uv.x += row_offset * zigzag;
                vec2 f = vec2(uv.x, fract(uv.y));

                // Generalized cosine: y(x) = a + b * cos(cx + d)
                const float amplitude = 0.125;
                float wave_frequency = frequency.y * 0.1;
                float distance_estimate = udf_cos(f, 0.50, amplitude, wave_frequency * (2.0 * PI), 0.0);

				// Different approach for variation param here
				float rand = hashwithoutsine12(vec2(i.y));
				float s = mix(size, size * rand, variation);

                return smoothstep(-smoothness, smoothness, distance_estimate - s * 0.5);
            }`);
  return { tileAndCenter: t, circle: o, ring: i, polygon: s, cross: l, diamond: c, checkerboard: u, line: a, wave: d };
}();
var zd = class extends ae {
  constructor(e, t, o, i, s, l, c, u) {
    super("v3");
    this.nodeType = "Rainbow";
    this.filmThickness = e, this.movement = t, this.wavelengths = o, this.noiseStrength = i, this.noiseScale = s, this.offset = l, this.isMask = u, this.alpha = c, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.require("vWorldViewDir"), e.require("worldNormal"), e.isShader("fragment")) {
      e.require("uv"), e.requires.uv = [true], e.addFragmentVariable(this.calpha, "float");
      let o = e.include(zd.Nodes.rainbow), i = [];
      return i.push(this.filmThickness.build(e, "f")), i.push(this.movement.build(e, "f")), i.push(this.wavelengths.build(e, "v3")), i.push(this.noiseStrength.build(e, "f")), i.push(this.noiseScale.build(e, "f")), i.push(this.offset.build(e, "v3")), i.push(this.isMask.build(e, "b")), i.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), i.push(this.alpha.build(e, "f")), i.push(this.calpha), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("RainbowNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var bi = zd;
bi.Nodes = function() {
  let e = new U(`vec3 attenuation(vec3 wavelengths, float filmThickness, float movement, float noiseStrength, float noiseScale, vec3 offset) {
                 vec3 st = position / noiseScale;
				 vec3 q = vec3(simplex3d(st),
							  simplex3d(st + vec3(1.0)),
							  simplex3d(st + vec3(1.0)));

				 vec3 r = vec3(simplex3d(st + vec3(1.4, 1.3, 1.0) * q + vec3(1.7, 9.2, 1.0)),
							  simplex3d(st + vec3(2.0, 1.2, 1.0) * q + vec3(8.3, 2.8, 1.0)),
							  simplex3d(st * q));

                 float noise = simplex3d(st + r);

                 return .5 + .5 * cos((((filmThickness + (noise * noiseStrength)) / (vec3(wavelengths.r * 1.0, wavelengths.g * 0.8, wavelengths.b * 0.6) + 1.0)) * dot(normalize(vWorldViewDir + (offset * -0.001)), normalize(vWNormal))) + movement);
             }`, [it.simplex]);
  return { rainbow: new U(`vec3 rainbow(float filmThickness, float movement, vec3 wavelengths, float noiseStrength, float noiseScale, vec3 offset, bool isMask, float mask, float alpha, out float calpha) {
				vec3 res = clamp(attenuation(wavelengths, filmThickness, movement, noiseStrength, noiseScale, offset), 0.0, 2.0);

				float rainbowContribution = clamp(res.r + res.g + res.b, 0.0, 1.0);

				float lalpha = alpha * rainbowContribution * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return res;
             }`, [e]) };
}();
var jd = class extends ae {
  constructor(e, t, o, i, s, l, c, u, a, d) {
    super("v3");
    this.nodeType = "Toon";
    this.positioning = e, this.colors = t, this.steps = o, this.source = i, this.isWorldSpace = s, this.noiseStrength = l, this.noiseScale = c, this.shadowColor = u, this.offset = a, this.alpha = d, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.require("worldNormal"), e.require("worldPosition"), e.isShader("fragment")) {
      e.define("COLORS_MAX", 10), e.addFragmentVariable(this.calpha, "float");
      let o = e.include(jd.Nodes.toon), i = [];
      return i.push(this.positioning.build(e, "i")), i.push(this.colors.build(e, "v4[]")), i.push(this.steps.build(e, "f[]")), i.push(this.source.build(e, "v3")), i.push(this.isWorldSpace.build(e, "b")), i.push(this.noiseStrength.build(e, "f")), i.push(this.noiseScale.build(e, "f")), i.push(this.shadowColor.build(e, "v4")), i.push(this.offset.build(e, "v3")), i.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), i.push(this.alpha.build(e, "f")), i.push(this.calpha), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("ToonNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var Si = jd;
Si.Nodes = function() {
  let e = new U(`float rand(float n) {
				return fract(sin(n) * 43758.5453123);
			}`), t = new U(`float hash1(float p) { 
				p = fract(p * 0.011); 
				p *= p + 7.5; 
				p *= p + p; 
				return fract(p); 
			}`), o = new U(`float valueNoise(vec3 x) {
				const vec3 step = vec3(110, 241, 171);
			
				vec3 i = floor(x);
				vec3 f = fract(x);
			 
				// For performance, compute the base input to a 1D hash from the integer part of the argument and the 
				// incremental change to the 1D based on the 3D -> 1D wrapping
				float n = dot(i, step);
			
				vec3 u = f * f * (3.0 - 2.0 * f);
				return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
						   mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
			}`, [t]), i = new U(`vec3 hash3(vec3 x) {
				x = vec3(dot(x,vec3(127.1, 311.7, 74.7)),
						 dot(x,vec3(269.5, 183.3, 246.1)),
						 dot(x,vec3(113.5, 271.9, 124.6)));
			
				return fract(sin(x)*43758.5453123);
			}`), s = new U(`vec3 voronoiNoise(in vec3 x)
			{
				vec3 p = floor(x);
				vec3 f = fract(x);

				float id = 0.0;
				vec2 res = vec2(100.0);

				for(int k=-1; k<=1; k++)
				for(int j=-1; j<=1; j++)
				for(int i=-1; i<=1; i++)
				{
					vec3 b = vec3(float(i), float(j), float(k));

					// Comment out the "+ hash(p + b);" part below to get "square" cells
					vec3 r = vec3(b) - f + hash3(p + b);
					float d = dot(r, r);

					if (d < res.x)
					{
						id = dot(p + b, vec3(1.0, 57.0, 113.0));
						res = vec2(d, res.x);			
					}
					else if (d < res.y)
					{
						res.y = d;
					}
				}

				return vec3(sqrt(res), abs(id));
			}
			`, [i]);
  return { toon: new U(`vec3 toon(int positioning, vec4 colors[COLORS_MAX], float steps[COLORS_MAX], vec3 source, bool isWorldSpace, float noiseStrength, float noiseScale, vec4 shadowColor, vec3 offset, float mask, float alpha, out float calpha) {
				float t = 0.0;
				float shadow = 1.0;

				if (positioning == 0) {

					// Can't do this mode if lighting is "none"
					#if (defined(PHONG) || defined(LAMBERT) || defined(STANDARD))

						// Algorithm from Chapter 10 of Graphics Shaders
						const vec3 weights = vec3(0.2125, 0.7154, 0.0721);
						vec3 lpos;
						vec3 l;
						float dproduct;

						#if (NUM_POINT_LIGHTS > 0)

							#if defined(USE_SHADOWMAP) && (NUM_POINT_LIGHT_SHADOWS > 0)
								PointLightShadow pointLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
								// Light positions are in view-space for some reason?
								lpos = (inverse(viewMatrix) * vec4(pointLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								
								// TODO: we want to use "intensity" but it isn't available in the shader code
								//dproduct += dot(pointLights[UNROLLED_LOOP_INDEX].color, weights);

								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS)
									pointLightShadow = pointLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getPointShadow( 
											pointShadowMap[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowMapSize, 
											pointLightShadow.shadowBias, 
											pointLightShadow.shadowRadius,
											vPointShadowCoord[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowCameraNear, 
											pointLightShadow.shadowCameraFar);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_DIR_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_DIR_LIGHT_SHADOWS > 0)
								DirectionalLightShadow directionalLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_DIR_LIGHTS; i++) {
								// Use the direction vector for directional lights instead
								l = (inverse(viewMatrix) * vec4(directionalLights[UNROLLED_LOOP_INDEX].direction, 0.0)).xyz;
		
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS)
									directionalLightShadow = directionalLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow( 
										UNROLLED_LOOP_INDEX,
										directionalShadowMap[UNROLLED_LOOP_INDEX], 
										directionalLightShadow.shadowMapSize, 
										directionalLightShadow.shadowBias, 
										directionalLightShadow.shadowRadius, 
										vDirectionalShadowCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_SPOT_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_SPOT_LIGHT_SHADOWS > 0)
								SpotLightShadow spotLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {
								lpos = (inverse(viewMatrix) * vec4(spotLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS)
									spotLightShadow = spotLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow(
										UNROLLED_LOOP_INDEX,
										spotShadowMap[UNROLLED_LOOP_INDEX], 
										spotLightShadow.shadowMapSize, 
										spotLightShadow.shadowBias, 
										spotLightShadow.shadowRadius, 
										vSpotLightCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						t = clamp(t, 0.0, 1.0);
				
					#endif

				} else if (positioning == 1) {
					
					vec3 origin = mix(position, worldPosition, float(isWorldSpace));
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	

				} else {

					vec3 origin = worldPosition;
					vec3 source = cameraPosition - offset;
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	
					
				}

				if (noiseStrength > 0.0) {
					// Distort with noise
					vec3 st = position / noiseScale;
					
					// Voronoi "smooth" noise
					float noise = 1.0 - voronoiNoise(st).x;

					// Voronoi cellular noise
					//float noise = 1.0 - rand(voronoiNoise(st).z);

					// Position warp noise
					// vec3 offset = vec3(
					// 	simplex3d(st),
					// 	simplex3d(st + vec3(111.1, 143.89, 217.19)),
					// 	simplex3d(st + vec3(171.1, 247.89, 117.23))
					// );
					// st += offset;
					// float noise = valueNoise(st);

					t += noise * noiseStrength;
				}

				t = clamp(t, 0.0, 1.0);

				// Compute ramp color
				float p;
				vec4 color = colors[0];
				for (int i = 1; i < COLORS_MAX; i++) {
					p = clamp((t - steps[i-1]) / (steps[i] - steps[i-1]), 0.0, 1.0);
					color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
				}

				// Incorporate custom shadow color
				if (positioning == 0) {

					vec3 blendedShadow = mix(color.rgb, shadowColor.rgb, shadowColor.a);
					color.rgb = mix(blendedShadow, color.rgb, shadow);
				
				}

				// Accumulate alpha as usual
				float lalpha = alpha * color.a * mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color.xyz;

            }`, [it.simplex, e, o, s]) };
}();
var Fd = class extends ae {
  constructor(e, t, o, i, s, l, c, u) {
    super("v3");
    this.nodeType = "Transmission";
    this.thickness = e, this.ior = t, this.roughness = o, this.transmissionSamplerSize = i, this.transmissionSamplerMap = s, this.transmissionDepthMap = l, this.aspectRatio = c, this.alpha = u, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.extensions.shaderTextureLOD = true, e.extensions.derivatives = true, e.isShader("fragment")) {
      e.define("NUM_SAMPLES", 6), e.define("BLUR_SLOD", Math.pow(2, ye.transmissionLod.value)), e.require("worldPosition"), e.requires.worldNormal = true, e.requires.modelMatrix = true, e.requires.projectionMatrix = true, e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Fd.Nodes.transmission), i = [];
      return i.push(this.thickness.build(e, "f")), i.push(this.ior.build(e, "f")), i.push(this.roughness.build(e, "f")), i.push(this.transmissionSamplerSize.build(e, "v2")), i.push(this.transmissionSamplerMap.getTexture(e, "t")), i.push(this.transmissionDepthMap.getTexture(e, "t")), i.push(this.aspectRatio.build(e, "v2")), i.push("normal"), i.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), i.push(this.alpha.build(e, "f")), i.push(this.calpha), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("TransmissionNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var wi = Fd;
wi.Nodes = function() {
  let e = new U(`
            vec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {
                // Slightly modified version of this:
                // https://www.shadertoy.com/view/ltScRG

				// Special case for blur == 0.0
				if (lod == 0.0) {
					#ifdef TEXTURE_LOD_EXT
					return texture2DLodEXT( sp, U, 0.0).rgb;
					#else
					return textureLod( sp, U, 0.0).rgb;
					#endif
				}
				
				vec2 texelSize = vec2(1.0) / resolution;
                vec2 halton = haltonSequence[frameIndex];
                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
                float temporalAngle  = temporalOffset * PI2;
				vec3 res = vec3(0.0);
                vec2 uv = vec2(0.0);
                vec2 offset = vec2(0.0);
                vec2 vogelSample = vec2(0.0);
                for (int i = 0; i < NUM_SAMPLES; i++) {
                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;
                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20
                    uv = U + offset;
                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, uv, lod));
                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {
                        uv = unrefractedU;
                        lod = lod > 4.0 ? lod : lod / 2.0;
                    }
                    res += textureLod(sp, uv, lod).rgb;
                }
                return res / float(NUM_SAMPLES);

            }`), t = new U(`
            vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		        // Direction of refracted light.
		        vec3 refractionVector = refract( -v,  n, 1.0 / ior );
		        // Compute rotation-independant scaling of the model matrix.
		        vec3 modelScale;
		        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		        // The thickness is specified in local space.
		        return normalize( refractionVector ) * thickness * modelScale;
	        }`), o = new U(`
float applyIorToRoughness( float roughness, float ior ) {
		// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
		// an IOR of 1.5 results in the default amount of microfacet refraction.
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	} `), i = new U(`
vec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
        float lod = applyIorToRoughness(roughness, ior);

        return blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);
	}`, [o, e]), s = new U(`
vec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {
        vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
        vec3 refractedRayExit = position + transmissionRay;

        // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
        vec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );
        vec2 refractionCoords = ndcPos.xy / ndcPos.w;
        refractionCoords += 1.0;
        refractionCoords /= 2.0;

        vec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );
        vec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;
        unrefractedCoords += 1.0;
        unrefractedCoords /= 2.0;

        // Sample framebuffer to get pixel the refracted ray hits.
        return getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );
    }`, [i, t]);
  return { transmission: new U(`
            vec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {
                vec3 v = vec3(0.);
                if (isOrthographic) {
                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
                } else {
                    v = normalize(vWPosition - cameraPosition);
                }
                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );
                
				float lalpha = alpha * mask;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * alpha;

				return transmission;
            }`, [s]) };
}();
var kd = ((e) => (e.NOISE = "noise", e.MAP = "map", e))(kd || {});
var Ud = class extends ae {
  constructor(e, t, o, i, s, l, c, u, a, d, p) {
    super("v3");
    this.displacementTypeIndex = new ve(0);
    this.nodeType = "VertexDisplacement";
    this.intensity = e, this.movementOrTexture = t, Object.values(kd)[this.displacementTypeIndex.value] === "map" && (this.mat = new li(this.movementOrTexture.value.matrix)), this.cropOrOffset = o, this.scale = d, this.noiseFunctionIndex = p, this.voronoiStyle = i, this.smoothness = s, this.seed = l, this.highCut = c, this.lowCut = u, this.quality = a;
  }
  generate(e, t) {
    if (e.isShader("vertex")) {
      e.define("USE_LAYER_DISPLACE");
      let o, i = [];
      switch (i.push("displaced_position"), i.push("displaced_normal"), Object.values(kd)[this.displacementTypeIndex.value]) {
        case "map": {
          o = e.include(Ud.Nodes.map), i.push(this.movementOrTexture.getTexture(e, "t")), i.push("uv"), i.push(this.cropOrOffset.build(e, "f")), this.mat && i.push(this.mat.build(e, "mat3"));
          break;
        }
        case "noise": {
          let l = Object.values(Ts)[this.noiseFunctionIndex.value], c = new U(`vec3 orthogonal(vec3 v) {
							return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
						}`), u = l == "voronoi" ? `
					float v = ${l}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1), voronoiStyle, smoothness, seed, quality);
					v = remap(v, lowCut, highCut, 0.0, 1.0);
					v = smax(v, 0.0, smoothness * 0.25);
					v = smin(v, 1.0, smoothness * 0.25);

					return p + n * v * intensity;
					` : `
					return p + n * ${l}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1)) * intensity;
					`, a = new U(`vec3 distorted(vec3 p, vec3 n, float scale, float intensity, vec3 offset, float neighbour_offset, float movement, int voronoiStyle, float smoothness, float seed, float highCut, float lowCut, int quality) {
							${u}
						}`, [it.simplex, it.simplexFractal, it.simplexAshima, it.fbm, it.perlin, it.voronoi]), d = new U(`vec3 vertexDisplacementNoise(vec3 position, vec3 normal, float scale, vec3 offset, float movement, int voronoiStyle, float smoothness, float seed, float highCut, float lowCut, int quality, float intensity, out vec3 displaced_normal) {
							vec3 displaced_position = distorted(position, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							vec3 tangent1 = orthogonal(normal);
							vec3 tangent2 = normalize(cross(normal, tangent1));

                            // TODO(Max): The distance to the neighbors was originally scaled by 0.1.
                            // This caused some small oval/circular visual artifacts in the lighting.
                            // For now, simply using neighbors further away betters the problem,
                            // but we should figure out the underlying cause when we have some time.
                            // Maybe its related to how we calculate the tangent and bitangent?
							vec3 nearby1 = position + tangent1;
							vec3 nearby2 = position + tangent2;
							vec3 distorted1 = distorted(nearby1, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							vec3 distorted2 = distorted(nearby2, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
							return displaced_position;
						}`, [a, c]);
          o = e.include(d), i.push(this.scale.build(e, "f")), i.push(this.cropOrOffset.build(e, "v3")), i.push(this.movementOrTexture.build(e, "f")), i.push(this.voronoiStyle.build(e, "i")), i.push(this.smoothness.build(e, "f")), i.push(this.seed.build(e, "f")), i.push(this.highCut.build(e, "f")), i.push(this.lowCut.build(e, "f")), i.push(this.quality.build(e, "i"));
          break;
        }
      }
      return i.push(this.intensity.build(e, "f")), i.push("displaced_normal"), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("VertexDisplacementNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var _i = Ud;
_i.Nodes = function() {
  let e = new U(`vec3 orthogonal(vec3 v) {
				return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
			}`), t = new U(`float displacementMapTexture(sampler2D tex, float crop, vec2 uv, mat3 mat, vec2 offset) {
				vec2 uvs = (mat * vec3(uv * 2.0 - 1.0, 1.0) / 2.0 + 0.5).xy + offset;
				vec4 tmp = texture2D(tex, uvs);
				vec3 col = tmp.rgb;
				if (crop > 0.5) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						return 0.0;
					}
				}
				return col.r;
			}`);
  return { map: new U(`vec3 vertexDisplacementMap(vec3 position, vec3 normal, sampler2D tex, vec2 uv, float crop, mat3 mat, float intensity, out vec3 displaced_normal) {
				vec3 displaced_position = position + normal * displacementMapTexture(tex, crop, uv, mat, vec2(0.0)) * intensity;
				vec3 tangent1 = normalize(orthogonal(normal));
				vec3 tangent2 = normalize(cross(normal, tangent1));
				vec3 nearby1 = position + tangent1 * 0.1;
				vec3 nearby2 = position + tangent2 * 0.1;
				vec3 distorted1 = nearby1 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				vec3 distorted2 = nearby2 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
				return displaced_position;
			}`, [e, t]) };
}();
var ye = { normalRenderTarget: new bt(), normalRenderTargetDepth: new bt(), transmissionRenderTarget: new bt(), transmissionSize: new je(2048, 2048), transmissionRenderTargetDepth: new bt(), aoRenderTarget: new bt(), aoEnabled: new Fe(), pixelRatioNode: new Z(1), resolution: new je(), penumbraSize: new lr(5, 0.5), frameIndex: new ve(0), transmissionLod: new ve(2) };
for (let n of Object.values(ye))
  n.isRenderGlobal = true;
var Vo = class extends rt {
  constructor() {
    super("basic");
    this.nodeType = "Basic";
    this.color = new Oe(5526619), this.shadingAlpha = new Z(1), this.shadingBlend = new ve(0), this.previousModelViewMatrix = new pt(), this.previouseProjectionMatrix = new pt();
  }
  get category() {
    return "phong";
  }
  generate(e) {
    let t;
    if (e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform({ frameIndex: ye.frameIndex }), e.mergeUniform({ resolution: ye.resolution }), e.mergeUniform({ previousModelViewMatrix: this.previousModelViewMatrix }), e.mergeUniform({ previousProjectionMatrix: this.previouseProjectionMatrix }), e.mergeUniform(UniformsUtils.merge([UniformsLib.fog])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>"].join(`
`));
      let i = ["#include <beginnormal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`];
      o && i.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), i.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "	vNormal = transformedNormal;", "#endif"), i.push("#include <project_vertex>", "#include <fog_vertex>", "#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "#include <worldpos_vertex>"), i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = i.join(`
`);
    } else {
      this.color === void 0 && (this.color = new Oe(5526619)), this.color.analyze(e, { slot: "color" }), this.alpha && this.alpha.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" });
      let o = this.color.flow(e, "c", { slot: "color" }), i = this.alpha ? this.alpha.flow(e, "f") : void 0, s = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0;
      e.requires.transparent = i !== void 0, e.addParsCode(["varying vec3 vWPosition;", "#include <fog_pars_fragment>", "#include <dithering_pars_fragment>", "varying vec3 vViewPosition;", "#include <normal_pars_fragment>"].join(`
`));
      let l = ["#include <normal_fragment_begin>", o.code];
      i && l.push(i.code, "#ifdef ALPHATEST", " if ( " + i.result + " <= ALPHATEST ) discard;", "#endif"), s ? l.push(s.code, `vec3 outgoingLight = ${o.result};`, `vec3 finalColor = spe_blend(outgoingLight, ${s.result}, 1.0, SPE_BLENDING_NORMAL);`) : l.push(`vec3 finalColor = ${o.result};`);
      let c = "1.0";
      this.mask && (this.mask.analyze(e), c = `luminance(${this.mask.flow(e, "v3").result})`), i ? l.push(`gl_FragColor = vec4( finalColor, accumAlpha * ${i.result} * ${c} );`) : l.push("gl_FragColor = vec4(" + o.result + ", 1.0 );"), l.push("#include <fog_fragment>", "#include <dithering_fragment>"), t = l.join(`
`);
    }
    return t;
  }
};
var Os = class extends rt {
  constructor() {
    super("lambert");
    this.nodeType = "Lambert";
    this.color = new Oe(5526619), this.emissive = new Oe(0), this.emissiveIntensity = new Z(1), this.previousModelViewMatrix = new pt(), this.previouseProjectionMatrix = new pt(), this.shadingAlpha = new Z(1), this.shadingBlend = new ve(0), this.occlusion = new Fe(true);
  }
  get category() {
    return "lambert";
  }
  build(e) {
    let t;
    if (e.define("LAMBERT"), e.requires.lights = true, e.extensions.derivatives = true, e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform({ frameIndex: ye.frameIndex }), e.mergeUniform({ resolution: ye.resolution }), e.mergeUniform({ previousModelViewMatrix: this.previousModelViewMatrix }), e.mergeUniform({ previousProjectionMatrix: this.previouseProjectionMatrix }), e.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "varying vec3 vLightFront;", "varying vec3 vIndirectFront;", "#ifndef DOUBLE_SIDED", "   #define DOUBLE_SIDED", "#endif", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "	varying vec3 vIndirectBack;", "#endif", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <color_pars_vertex>", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
      let i = ["#include <beginnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
      o && i.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), i.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), i.push("	#include <project_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", `
					vec3 diffuse = vec3( 1.0 );
					GeometricContext geometry;
					geometry.position = mvPosition.xyz;
					geometry.normal = normalize( transformedNormal );
					geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
					GeometricContext backGeometry;
					backGeometry.position = geometry.position;
					backGeometry.normal = -geometry.normal;
					backGeometry.viewDir = geometry.viewDir;
					vLightFront = vec3( 0.0 );
					vIndirectFront = vec3( 0.0 );
					#ifdef DOUBLE_SIDED
						vLightBack = vec3( 0.0 );
						vIndirectBack = vec3( 0.0 );
					#endif
					IncidentLight directLight;
					float dotNL;
					vec3 directLightColor_Diffuse;
					vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
					vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
					#ifdef DOUBLE_SIDED
						vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
						vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
					#endif
					#if NUM_POINT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
							getPointLightInfo( pointLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_SPOT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
							getSpotLightInfo( spotLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_DIR_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
							getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_HEMI_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
							vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
							#ifdef DOUBLE_SIDED
								vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
							#endif
						}
						#pragma unroll_loop_end
					#endif
				`, "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = i.join(`
`);
    } else {
      e.mergeUniform({ penumbraSize: ye.penumbraSize }), e.mergeUniform({ frameIndex: ye.frameIndex }), e.mergeUniform({ aoMap: ye.aoRenderTarget }), e.mergeUniform({ aoEnabled: ye.aoEnabled }), this.color === void 0 && (this.color = new Oe(5526619)), this.color.analyze(e, { slot: "color" }), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e);
      let o = this.color.flow(e, "c", { slot: "color" }), i = this.emissive.flow(e, "c", { slot: "emissive" }), s = this.emissiveIntensity.flow(e, "f", { slot: "emissive" }), l = this.occlusion.flow(e, "b", { slot: "occlusion" }), c = this.shadingAlpha.flow(e, "f"), u = this.shadingBlend.flow(e, "i"), a = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, d = this.alpha ? this.alpha.flow(e, "f") : void 0;
      e.requires.transparent = d !== void 0, e.addParsCode([`uniform float penumbraSize[${5}];`, "uniform sampler2D aoMap;", "uniform bool aoEnabled;", "varying vec3 vViewPosition;", "varying vec3 vWPosition;", "varying vec3 vLightFront;", "varying vec3 vIndirectFront;", "#ifndef DOUBLE_SIDED", "   #define DOUBLE_SIDED", "#endif", "#include <normal_pars_fragment>", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "	varying vec3 vIndirectBack;", "#endif", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <fog_pars_fragment>", "#include <shadowmap_pars_fragment>", "#include <shadowmask_pars_fragment>", "#include <clipping_planes_pars_fragment>", "#include <dithering_pars_fragment>"].join(`
`));
      let p = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx, viewdy));
				bool isFrontFacing = (dot(normal, faceNormal) >= 0.0);
				`, "#include <clipping_planes_fragment>"];
      p.push(o.code, "vec3 diffuseColor = " + o.result + ";", "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );"), d && p.push(d.code, "#ifdef ALPHATEST", "if ( " + d.result + " <= ALPHATEST ) discard;", "#endif"), p.push("#ifdef DOUBLE_SIDED", "	reflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;", "#else", "	reflectedLight.indirectDiffuse += vIndirectFront;", "#endif", "#include <lightmap_fragment>", "reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );", "#ifdef DOUBLE_SIDED", "	reflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;", "#else", "	reflectedLight.directDiffuse = vLightFront;", "#endif", "reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();"), i && p.push(i.code, "reflectedLight.directDiffuse += " + i.result + " * " + s.result + ";"), p.push("vec3 ao = aoEnabled && " + l.result + " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);", "vec3 outgoingLight = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) ;");
      let f = "1.0";
      this.mask && (this.mask.analyze(e), f = `luminance(${this.mask.flow(e, "v3").result})`), p.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${c.result} * ${f} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${c.result} * ${f}, ${u.result} );

					outgoingLight *= ao;
				}
				`), a && p.push(a.code, `outgoingLight = spe_blend(outgoingLight, ${a.result}, 1.0, SPE_BLENDING_NORMAL);`), d ? p.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${d.result} );`) : p.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), p.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), t = p.join(`
`);
    }
    return t;
  }
};
var As = class extends rt {
  constructor() {
    super("phong");
    this.nodeType = "Phong";
    this.color = new Oe(5526619), this.specular = new Oe(1118481), this.shininess = new Z(30), this.previousModelViewMatrix = new pt(), this.previouseProjectionMatrix = new pt(), this.shadingAlpha = new Z(1), this.shadingBlend = new ve(0), this.occlusion = new Fe(true);
  }
  get category() {
    return "phong";
  }
  build(e) {
    let t;
    if (e.define("PHONG"), e.requires.lights = true, e.extensions.derivatives = true, e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform({ frameIndex: ye.frameIndex }), e.mergeUniform({ resolution: ye.resolution }), e.mergeUniform({ previousModelViewMatrix: this.previousModelViewMatrix }), e.mergeUniform({ previousProjectionMatrix: this.previouseProjectionMatrix }), e.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
      let i = ["#include <beginnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif


				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
      o && i.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), i.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), i.push("	#include <project_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = i.join(`
`);
    } else {
      e.mergeUniform({ penumbraSize: ye.penumbraSize }), e.mergeUniform({ frameIndex: ye.frameIndex }), e.mergeUniform({ aoMap: ye.aoRenderTarget }), e.mergeUniform({ aoEnabled: ye.aoEnabled }), this.color === void 0 && (this.color = new Oe(5526619)), this.color.analyze(e, { slot: "color" }), this.specular.analyze(e), this.shininess.analyze(e);
      let o = this.occlusion.flow(e, "b", { slot: "occlusion" });
      this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e);
      let i = this.color.flow(e, "c", { slot: "color" }), s = this.specular.flow(e, "c"), l = this.shininess.flow(e, "f"), c = this.shadingAlpha.flow(e, "f"), u = this.shadingBlend.flow(e, "i"), a = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, d = this.alpha ? this.alpha.flow(e, "f") : void 0;
      e.requires.transparent = d !== void 0, e.addParsCode(["varying vec3 vWPosition;", "uniform vec3 emissive;", `uniform float penumbraSize[${5}];`, "uniform sampler2D aoMap;", "uniform bool aoEnabled;", "#include <normal_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <lights_phong_pars_fragment>", "#include <shadowmap_pars_fragment>", "#include <dithering_pars_fragment>"].join(`
`));
      let p = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	BlinnPhongMaterial material;"];
      p.push(i.code, "	vec3 diffuseColor = " + i.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "	vec3 totalEmissiveRadiance = emissive;", s.code, "	vec3 specular = " + s.result + ";", l.code, "	float shininess = max( 0.0001, " + l.result + " );", "	float specularStrength = 1.0;"), d && p.push(d.code, "#ifdef ALPHATEST", "if ( " + d.result + " <= ALPHATEST ) discard;", "#endif"), p.push("material.diffuseColor = diffuseColor;"), p.push("material.specularColor = specular;", "material.specularShininess = shininess;", "material.specularStrength = specularStrength;", "#include <lights_fragment_begin>", "#include <lights_fragment_end>"), p.push("vec3 ao = aoEnabled && " + o.result + " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);", "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;");
      let f = "1.0";
      this.mask && (this.mask.analyze(e), f = `luminance(${this.mask.flow(e, "v3").result})`), p.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${c.result} * ${f} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${c.result} * ${f}, ${u.result} );
					
					outgoingLight *= ao;
				}
				`), a && p.push(a.code, `outgoingLight = spe_blend(outgoingLight, ${a.result}, 1.0, SPE_BLENDING_NORMAL);`), d ? p.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${d.result} );`) : p.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), p.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), t = p.join(`
`);
    }
    return t;
  }
};
var Ns = class extends rt {
  constructor() {
    super("standard");
    this.nodeType = "Standard";
    this.color = new Oe(5526619), this.roughness = new Z(0.3), this.metalness = new Z(0), this.reflectivity = new Z(0.5), this.previousModelViewMatrix = new pt(), this.previouseProjectionMatrix = new pt(), this.shadingAlpha = new Z(1), this.shadingBlend = new ve(0), this.occlusion = new Fe(true);
  }
  get category() {
    return "physical";
  }
  build(e) {
    let t;
    if (e.define("STANDARD"), e.requires.lights = true, e.extensions.derivatives = true, e.extensions.shaderTextureLOD = true, e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform({ frameIndex: ye.frameIndex }), e.mergeUniform({ resolution: ye.resolution }), e.mergeUniform({ previousModelViewMatrix: this.previousModelViewMatrix }), e.mergeUniform({ previousProjectionMatrix: this.previouseProjectionMatrix }), e.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights])), UniformsLib.LTC_1 && (e.uniforms.ltc_1 = { value: void 0 }, e.uniforms.ltc_2 = { value: void 0 }), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
      let i = ["#include <beginnormal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`];
      o && i.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), i.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), i.push("#include <project_vertex>", "#include <fog_vertex>", "#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "#include <worldpos_vertex>", "#include <shadowmap_vertex>"), i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = i.join(`
`);
    } else {
      e.mergeUniform({ penumbraSize: ye.penumbraSize }), e.mergeUniform({ frameIndex: ye.frameIndex }), e.mergeUniform({ aoMap: ye.aoRenderTarget }), e.mergeUniform({ aoEnabled: ye.aoEnabled });
      let o = { gamma: true };
      this.color === void 0 && (this.color = new Oe(5526619)), this.color.analyze(e, { slot: "color", context: o }), this.roughness.analyze(e), this.metalness.analyze(e);
      let i = this.occlusion.flow(e, "b", { slot: "occlusion" });
      this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e), this.reflectivity && this.reflectivity.analyze(e);
      let s = this.color.flow(e, "c", { slot: "color", context: o }), l = this.roughness.flow(e, "f"), c = this.metalness.flow(e, "f"), u = this.shadingAlpha.flow(e, "f"), a = this.shadingBlend.flow(e, "i"), d = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, p = this.alpha ? this.alpha.flow(e, "f") : void 0, f = this.reflectivity ? this.reflectivity.flow(e, "f") : void 0;
      e.requires.transparent = p !== void 0, e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", `uniform float penumbraSize[${5}];`, "uniform sampler2D aoMap;", "uniform bool aoEnabled;", "#include <normal_pars_fragment>", "#include <dithering_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <lights_physical_pars_fragment>", "#include <shadowmap_pars_fragment>"].join(`
`));
      let m = ["#include <clipping_planes_fragment>", "	#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	PhysicalMaterial material;", "	material.diffuseColor = vec3( 1.0 );"];
      m.push(s.code, "	vec3 diffuseColor = " + s.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", l.code, "	float roughnessFactor = " + l.result + ";", c.code, "	float metalnessFactor = " + c.result + ";"), p && m.push(p.code, "#ifdef ALPHATEST", "	if ( " + p.result + " <= ALPHATEST ) discard;", "#endif"), m.push("vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );"), m.push("material.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );", "material.roughness = max( roughnessFactor, 0.0525 );", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.roughness = clamp( roughnessFactor, 0.04, 1.0 );"), f ? m.push(f.code, "material.specularColor = mix( vec3( 0.16 * pow2( " + f.result + " ) ), diffuseColor, metalnessFactor );") : m.push("material.specularColor = mix( vec3( 0.04 ), diffuseColor, metalnessFactor );"), m.push("#include <lights_fragment_begin>"), m.push("#include <lights_fragment_end>"), m.push("vec3 ao = aoEnabled && " + i.result + " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);", "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular;");
      let h = "1.0";
      this.mask && (this.mask.analyze(e), h = `luminance(${this.mask.flow(e, "v3").result})`), m.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${u.result} * ${h} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${u.result} * ${h}, ${a.result} );
					
					outgoingLight *= ao;
				}
				`), d && m.push(d.code, `outgoingLight = spe_blend(outgoingLight, ${d.result}, 1.0, SPE_BLENDING_NORMAL);`), p ? m.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${p.result} );`) : m.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), m.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), t = m.join(`
`);
    }
    return t;
  }
};
var Cs = class extends rt {
  constructor() {
    super("toon");
    this.nodeType = "Toon";
    this.color = new Oe(5526619), this.specular = new Oe(1118481), this.shininess = new Z(30), this.previousModelViewMatrix = new pt(), this.previouseProjectionMatrix = new pt(), this.shadingAlpha = new Z(1), this.shadingBlend = new ve(0);
  }
  get category() {
    return "toon";
  }
  build(e) {
    let t;
    if (e.define("TOON"), e.requires.lights = true, e.extensions.derivatives = true, e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform({ frameIndex: ye.frameIndex }), e.mergeUniform({ resolution: ye.resolution }), e.mergeUniform({ previousModelViewMatrix: this.previousModelViewMatrix }), e.mergeUniform({ previousProjectionMatrix: this.previouseProjectionMatrix }), e.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
      let i = ["#include <beginnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
      o && i.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), i.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), i.push("	#include <project_vertex>", "	#include <fog_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = i.join(`
`);
    } else {
      e.mergeUniform({ penumbraSize: ye.penumbraSize }), e.mergeUniform({ frameIndex: ye.frameIndex }), e.mergeUniform({ aoMap: ye.aoRenderTarget }), e.mergeUniform({ aoEnabled: ye.aoEnabled }), this.color === void 0 && (this.color = new Oe(5526619)), this.color.analyze(e, { slot: "color" }), this.specular.analyze(e), this.shininess.analyze(e), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e);
      let o = this.color.flow(e, "c", { slot: "color" }), i = this.specular.flow(e, "c"), s = this.shininess.flow(e, "f"), l = this.shadingAlpha.flow(e, "f"), c = this.shadingBlend.flow(e, "i"), u = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, a = this.alpha ? this.alpha.flow(e, "f") : void 0;
      e.requires.transparent = a !== void 0, e.addParsCode([`uniform float penumbraSize[${5}];`, "uniform sampler2D aoMap;", "uniform bool aoEnabled;", "varying vec3 vWPosition;", "#include <normal_pars_fragment>", "#include <gradientmap_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <dithering_pars_fragment>", `
					varying vec3 vViewPosition;
					struct ToonMaterial {
						vec3	diffuseColor;
						vec3	specularColor;
						float	specularShininess;
						float	specularStrength;
					};
					void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
			
						reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
						reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
					}
					void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
					}
					#define RE_Direct				RE_Direct_Toon
					#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
					#define Material_LightProbeLOD( material )	(0)
					`, "#include <shadowmap_pars_fragment>", "#include <bumpmap_pars_fragment>", "#include <normalmap_pars_fragment>"].join(`
`));
      let d = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	ToonMaterial material;"];
      d.push(o.code, "	vec3 diffuseColor = " + o.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", i.code, "	vec3 specular = " + i.result + ";", s.code, "	float shininess = max( 0.0001, " + s.result + " );", "	float specularStrength = 1.0;"), a && d.push(a.code, "#ifdef ALPHATEST", "if ( " + a.result + " <= ALPHATEST ) discard;", "#endif"), d.push("material.diffuseColor = diffuseColor;"), d.push("material.specularColor = specular;", "material.specularShininess = shininess;", "material.specularStrength = specularStrength;", "#include <lights_fragment_begin>", "#include <lights_fragment_end>"), d.push("vec3 ao = aoEnabled ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);", "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) * ao) + reflectedLight.directSpecular;");
      let p = "1.0";
      this.mask && (this.mask.analyze(e), p = `luminance(${this.mask.flow(e, "v3").result})`), d.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${l.result} * ${p} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${l.result} * ${p}, ${c.result} );
				}
				`), u && d.push(u.code, `outgoingLight = spe_blend(outgoingLight, ${u.result}, 1.0, SPE_BLENDING_NORMAL);`), a ? d.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${a.result} );`) : d.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), d.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), t = d.join(`
`);
    }
    return t;
  }
};
var Al = class {
  constructor(r = 1e3 * 10) {
    this.timeout = r;
    this.cache = /* @__PURE__ */ new Map();
    this.head = { data: null, time: 0, src: null, next: null, prev: null };
    this.tail = { data: null, time: 1 / 0, src: null, next: null, prev: null };
    this.hasClean = false;
    this.head.next = this.tail, this.tail.prev = this.head;
  }
  log(...r) {
  }
  remove(r) {
    let e = this.cache.get(r);
    e && (this.dispose(r, e.data), this.cache.delete(r), e.prev.next = e.next, e.next.prev = e.prev);
  }
  scheduleCleanup() {
    this.hasClean || (this.log("scheduled cleanup"), this.hasClean = true, setTimeout(() => {
      this.hasClean = false, this.log("cleaning");
      let r = Date.now(), e = this.head.next;
      for (; e.time < r - this.timeout; )
        this.dispose(e.src, e.data), this.cache.delete(e.src), e = e.next, e.prev = this.head, this.head.next = e;
      this.head.next !== this.tail ? this.scheduleCleanup() : this.log("no more cleanup");
    }, this.timeout + 1e3));
  }
  has(r) {
    var _a2;
    return (_a2 = this.cache.get(r)) == null ? void 0 : _a2.data;
  }
  load(r) {
    let e = Date.now(), t = this.cache.get(r);
    return t === void 0 ? (t = { data: this.create(r), src: r, time: e, next: null, prev: null }, this.cache.set(r, t)) : (t.time = e, t.prev.next = t.next, t.next.prev = t.prev), t.prev = this.tail.prev, t.next = this.tail, this.tail.prev.next = t, this.tail.prev = t, this.scheduleCleanup(), t.data;
  }
};
var Wd = class extends Al {
  create(r) {
    return URL.createObjectURL(new Blob([r]));
  }
  dispose(r, e) {
    URL.revokeObjectURL(e);
  }
};
var qd;
function zy(n) {
  return typeof n == "string" ? n : (qd || (qd = new Wd()), qd.load(n));
}
var Nl = class {
  constructor(r, e) {
    this.data = r;
    this.cache = e;
    this.refCount = 0;
  }
  deref() {
    if (this.refCount === 0 && false)
      throw new Error("ref count -1?");
    this.refCount -= 1, this.refCount === 0 && (this.cache.remove(this), this.dispose());
  }
  dispose() {
    if (this.refCount !== 0 && false)
      throw new Error("ref count is not 0");
  }
};
var Cl = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  remove(r) {
    if (this.cache.delete(r.data) === false && false)
      throw new Error("ref count remove non-exists");
  }
  load(r) {
    let e = this.cache.get(r);
    return e === void 0 && (e = this.create(r), this.cache.set(r, e)), e.refCount += 1, e;
  }
};
var Pi = class extends Nl {
  constructor(e, t) {
    super(e, t.imageHolderCache);
    this.data = e;
    this.shared = t;
    this.loaded = false;
    this.isVideo = false;
    this.isVideo = e.type === "video", this.updateSrc(e.data);
  }
  async updateSrc(e) {
    if (typeof document > "u")
      return;
    this.disposeTextures(), this.loaded = false;
    let t = () => {
      this.loaded = true;
      let i = [1e3, 1001, 1002];
      for (let s of i) {
        let l = this[s];
        l && (l.image = this.img, l.needsUpdate = true);
      }
      this.shared.requestRender();
    };
    if (this.isVideo) {
      if (this.img = document.createElement("video"), this.img.preload = "auto", this.img.playsInline = true, this.img.currentTime = 0.01, typeof e != "string") {
        var o = new FileReader();
        o.readAsDataURL(new Blob([e], { type: "video/mp4" }));
        let i;
        await new Promise((s) => {
          o.onloadend = (l) => {
            var _a2;
            i = (_a2 = l.target) == null ? void 0 : _a2.result, s(null);
          };
        }), this.img.src = i;
      } else
        this.img.src = e;
      this.img.onloadeddata = () => {
        t();
      };
    } else
      this.img = new Image(), this.img.src = zy(e), this.img.onload = t;
  }
  getTexture(e) {
    let t = this[e];
    if (t)
      return t;
    {
      let o;
      return this.isVideo ? o = new VideoTexture(this.img, void 0, e, e) : o = new Texture(this.img, void 0, e, e), this.loaded && (o.needsUpdate = true), this[e] = o, o;
    }
  }
  disposeTextures() {
    var _a2, _b2, _c2;
    (_a2 = this[1e3]) == null ? void 0 : _a2.dispose(), this[1e3] = void 0, (_b2 = this[1001]) == null ? void 0 : _b2.dispose(), this[1001] = void 0, (_c2 = this[1002]) == null ? void 0 : _c2.dispose(), this[1002] = void 0;
  }
  dispose() {
    super.dispose(), this.disposeTextures();
  }
};
var Ht = class extends Pi {
};
function st(n, r) {
  return r.color(n);
}
function jy(n, r) {
  switch (n.type) {
    case "fresnel":
      return nO(n, r);
    case "gradient":
      return iO(n);
    case "depth":
      return sO(n);
    case "normal":
      return aO(n);
    case "noise":
      return lO(n, r);
    case "rainbow":
      return cO(n);
    case "toon":
      return dO(n, r);
    case "outline":
      return uO(n, r);
    case "transmission":
      return pO(n, r);
    case "color":
      return oO(n, r);
    case "pattern":
      return fO(n, r);
  }
}
function rO(n) {
  return { type: n.type };
}
function dr(n) {
  let { alpha: r, mode: e, isMask: t } = n;
  return { ...rO(n), alpha: r, mode: e, isMask: t };
}
function oO(n, r) {
  return { ...dr(n), color: st(n.color, r) };
}
function nO(n, r) {
  let { bias: e, scale: t, intensity: o, factor: i, color: s, isMask: l } = n;
  return { ...dr(n), color: st(s, r), bias: e, scale: t, intensity: o, factor: i };
}
function iO(n) {
  let { gradientType: r, smooth: e, colors: t, steps: o, angle: i, offset: s, morph: l } = n;
  return { ...dr(n), gradientType: r, smooth: e, colors: t.map((c) => new Vector4(c[0], c[1], c[2], c[3])), num: t.length, steps: o, offset: new Vector2(...s), morph: new Vector2(...l), angle: i };
}
function sO(n) {
  let { gradientType: r, near: e, far: t, isVector: o, isWorldSpace: i, origin: s, direction: l, colors: c, steps: u, smooth: a } = n;
  return { ...dr(n), gradientType: r, near: e, far: t, isVector: o, isWorldSpace: i, origin: new Vector3(...s), direction: l ? new Vector3(...l) : new Vector3(1, 0, 0), colors: c.map((d) => d !== void 0 ? new Vector4(d[0], d[1], d[2], d[3]) : new Vector4(0, 0, 0, 0)), steps: u.slice(0, c.length), smooth: a };
}
function aO(n) {
  let { cnormal: r } = n;
  return { ...dr(n), cnormal: new Vector3(r[0], r[1], r[2]) };
}
function lO(n, r) {
  return { ...dr(n), scale: n.scale, move: n.move, fA: new Vector2(...n.fA), fB: new Vector2(...n.fB), size: new Vector3(...n.size), distortion: new Vector2(...n.distortion), colorA: st(n.colorA, r), colorB: st(n.colorB, r), colorC: st(n.colorC, r), colorD: st(n.colorD, r), noiseType: n.noiseType, voronoiStyle: n.voronoiStyle, highCut: n.highCut, lowCut: n.lowCut, smoothness: n.smoothness, seed: n.seed, quality: n.quality };
}
function cO(n) {
  return { ...dr(n), filmThickness: n.filmThickness, movement: n.movement, wavelengths: new Vector3(...n.wavelengths), noiseStrength: n.noiseStrength, noiseScale: n.noiseScale, offset: new Vector3(...n.offset) };
}
function dO(n, r) {
  return { ...dr(n), positioning: n.positioning, colors: n.colors.map((e) => new Vector4(e[0], e[1], e[2], e[3])), num: n.colors.length, steps: n.steps, source: new Vector3(...n.source), isWorldSpace: n.isWorldSpace, noiseStrength: n.noiseStrength, noiseScale: n.noiseScale, shadowColor: st(n.shadowColor, r), offset: new Vector3(...n.offset) };
}
function uO(n, r) {
  return { ...dr(n), outlineColor: st(n.outlineColor, r), contourColor: st(n.contourColor, r), outlineWidth: n.outlineWidth, contourWidth: n.contourWidth, outlineThreshold: n.outlineThreshold, contourThreshold: n.contourThreshold, outlineSmoothing: n.outlineSmoothing, contourFrequency: n.contourFrequency, contourDirection: new Vector3(...n.contourDirection), positionalLines: n.positionalLines, compensation: n.compensation };
}
function pO(n, r) {
  return { ...dr(n), thickness: n.thickness, ior: n.ior, roughness: n.roughness };
}
function fO(n, r) {
  return { ...dr(n), style: n.style, projection: n.projection, axis: n.axis, blending: n.blending, offset: new Vector2(...n.offset), colorA: st(n.colorA, r), colorB: st(n.colorB, r), frequency: new Vector2(...n.frequency), size: n.size, variation: n.variation, smoothness: n.smoothness, zigzag: n.zigzag, rotation: n.rotation, vertical: new Vector2(...n.vertical), horizontal: new Vector2(...n.horizontal), sides: n.sides };
}
var go = class extends Ke {
};
var $d = { noise: ["noiseType"], texture: ["projection", "axis", "side"], video: ["projection", "axis", "side"], displace: ["noiseType"], depth: ["smooth", "isWorldSpace", "gradientType", "isVector"], pattern: ["style", "projection", "axis"] };
var Yd = { depth: ["colors"] };
function hO(n, r, e) {
  var _a2, _b2;
  if (r === "isMask")
    return true;
  let t = $d[n.type], o = Yd[n.type];
  if (o !== void 0) {
    let i = n.color;
    if (o.includes(r)) {
      let s = (_b2 = (_a2 = i[r]) == null ? void 0 : _a2.value) == null ? void 0 : _b2.length;
      if (s !== void 0 && s !== e.length)
        return true;
    }
  }
  return t !== void 0 ? t.includes(r) : false;
}
function Xd(n, r, e) {
  let t = e.uniforms[`f${e.id}_texture`];
  if (!t)
    return false;
  let o = false, i = n;
  if ("image" in i) {
    let s = i.image, l = r.image(s), c = t;
    c.image instanceof Ht || c.image.deref(), c.image = l;
  }
  if ("video" in i) {
    let s = i.video, l = r.video(s), c = t;
    c.image instanceof Ht || c.image.deref(), c.image = l;
  }
  if ("wrapping" in i) {
    let s = t;
    s.wrap = i.wrapping;
  }
  if ("repeat" in i || "offset" in i) {
    let s = "mat", l = e.uniforms[`f${e.id}_${s}`];
    "repeat" in i && (l.repeat = i.repeat), "offset" in i && (l.offset = i.offset), l.updateMatrix();
  }
  return o;
}
function Fy(n, r, e, t) {
  let o = false;
  for (let [i, s] of Object.entries(n)) {
    if (!i || s === void 0)
      continue;
    if (Kd(i, e, t)) {
      i === "visible" && e.type === "light" && (o = true);
      continue;
    }
    e.visible = t.visible;
    let l = e.uniforms[`f${e.id}_${i}`];
    if (!!l && !(l instanceof yo))
      switch (o = o || hO(e, i, s), l.constructor) {
        case Oe:
          if (typeof s == "string") {
            let c = r.getColor(s);
            c && (l.value = c);
            break;
          } else {
            let c = s;
            l.value instanceof go ? l.value = new Ke(c.r, c.g, c.b, c.a) : l.setRGBA(c);
            break;
          }
        case Nt:
          if (typeof s == "string") {
            let c = r.getColor(s);
            c && (l.value = c);
            break;
          } else {
            let c = s;
            l.value instanceof go ? l.value = new Ke(c.r, c.g, c.b, c.a) : l.value.setRGBA(c.r, c.g, c.b, c.a);
            break;
          }
        case je: {
          let c = s;
          l.value.setX(c[0]), l.value.setY(c[1]);
          break;
        }
        case ut: {
          let c = s;
          l.value.setX(c[0]), l.value.setY(c[1]), l.value.setZ(c[2]);
          break;
        }
        case bt: {
          Xd(s, r, e);
          break;
        }
        case cr: {
          l.value = s.map((c) => new Vector4(...c));
          break;
        }
        default: {
          l.value = s;
          break;
        }
      }
  }
  return o;
}
var Mr = class {
  constructor(r, e, t, o) {
    this.id = r;
    this.uuid = e;
    this.data = t;
    this.uniforms = {};
    for (let i in o)
      this.uniforms[`f${this.id}_${i}`] = o[i];
    for (let i in t)
      Kd(i, this, t);
  }
  get type() {
    return this.data.type;
  }
  static create(r, e, t, o) {
    if (t.type === "light")
      return Wt.createLigherLayer(r, e, t, o);
    if (t.type === "texture" || t.type === "video") {
      let i = t.type === "texture" ? o.image(t.texture.image) : o.video(t.texture.video), s = new Go(i, t.texture.wrapping), l = new Tl(i), c = new Ol(t.texture.repeat, t.texture.offset), u = new Z(t.crop ? 1 : 0), a = new ve(t.projection ?? 0), d = new ve(["x", "y", "z"].indexOf(t.axis) ?? 0), p = new ve(t.side ?? 0), f = new je(t.size ? new Vector2(t.size[0], t.size[1]) : new Vector2(100, 100)), m = new Z(t.blending ?? 0), h = new Z(t.alpha ?? 1), y = new ve(t.mode ?? 0), g = new Fe(t.isMask ?? false), v = new pi(s, l, u, a, d, p, f, m, c, h, y, g), b = new _e(v.calpha, "f");
      return new De(r, e, t, { texture: s, textureSize: l, crop: u, projection: a, axis: d, side: p, size: f, blending: m, mat: c, alpha: h, mode: y, isMask: g }, v, y, b, g);
    } else if (t.type === "matcap") {
      let i = o.image(t.texture.image), s = new Go(i, t.texture.wrapping), l = new Z(t.alpha ?? 1), c = new ve(t.mode ?? 0), u = new Fe(t.isMask ?? false), a = new yi(s, l, c, u), d = new _e(a.calpha, "f");
      return new De(r, e, t, { texture: s, alpha: l, mode: c, isMask: u }, a, c, d, u);
    } else if (t.type === "displace")
      if (t.displacementType === "noise") {
        let i = new ut(new Vector3(...t.offset)), s = new Z(t.scale ?? 10), l = new Z(t.intensity ?? 8), c = new Z(t.movement ?? 1), u = new ve(t.noiseType ?? 0), a = new ve(t.voronoiStyle ?? 0), d = new Z(t.smoothness ?? 0.5), p = new Z(t.seed ?? 0), f = new Z(t.highCut ?? 1), m = new Z(t.lowCut ?? 0), h = new ve(t.quality ?? 1), y = new _i(l, c, i, a, d, p, f, m, h, s, u);
        return new Is(r, e, t, { offset: i, scale: s, intensity: l, movement: c, noiseType: u, voronoiStyle: a, smoothness: d, seed: p, highCut: f, lowCut: m, quality: h }, y);
      } else
        throw new Error();
    else
      return xO(r, e, t, o);
  }
  updateByOp(r, e, t) {
    var _a2;
    let o = r;
    if (o.path[0] === void 0) {
      if (o.type === 0)
        return "type" in o.props || "category" in o.props || "visible" in o.props ? ((_a2 = t.scene) == null ? void 0 : _a2.markNeedsUpdateRendererDirty(), true) : Fy(o.props, t.shared, this, e);
    } else if (o.path[0] === "texture")
      return "texture" in e || "video" in e ? Xd(o.props, t.shared, this) : true;
    return false;
  }
  dispose() {
    if (yO(this)) {
      let r = this.uniforms[`f${this.id}_texture`];
      if (!r)
        return false;
      let e = r;
      e.image instanceof Ht || e.image.deref();
    }
  }
  hasValueByKey(r) {
    return this.uniforms[r] !== void 0;
  }
  hasValue(r) {
    return this.hasValueByKey(`f${this.id}_${r}`);
  }
  setValue(r, e) {
    let t = `f${this.id}_${r}`;
    this.hasValueByKey(t) && e !== void 0 && (this.uniforms[t].value = e);
  }
  getNode(r) {
    let e = `f${this.id}_${r}`;
    if (this.hasValueByKey(e))
      return this.uniforms[e];
  }
  getValue(r) {
    let e = `f${this.id}_${r}`;
    if (this.hasValueByKey(e))
      return this.uniforms[e].value;
  }
  getName(r) {
    let t = /f\d+_(.*)/.exec(r);
    if (t && t.length > 1)
      return t[1];
    console.log(`Layer.getName: error ${r}`);
  }
  getNames() {
    let r = [];
    for (let e in this.uniforms) {
      let t = this.getName(e);
      t && r.push(t);
    }
    return r;
  }
};
var De = class extends Mr {
  constructor(e, t, o, i, s, l, c, u) {
    super(e, t, o, i);
    this.params = i;
    this.color = s;
    this.mode = l;
    this.alpha = c;
    this.isMask = u;
  }
};
var Is = class extends Mr {
  constructor(e, t, o, i, s) {
    super(e, t, o, i);
    this.position = s;
  }
};
var Wt = class extends Mr {
  constructor(e, t, o, i, s) {
    super(e, t, o, s);
    this.node = i;
  }
  static createLigherLayer(e, t, o, i) {
    let s, l = new Z(o.alpha), c = new ve(o.mode), u;
    if (!o.visible)
      s = new Vo(), u = {};
    else if (o.category === "lambert") {
      s = new Os();
      let a = new Oe(i.color(o.emissive) ?? 0), d = new Fe(o.occlusion ?? true);
      u = { emissive: a, occlusion: d }, s.emissive = a, s.occlusion = d;
    } else if (o.category === "toon") {
      s = new Cs();
      let a = new Z(o.shininess ?? 30), d = new Oe(i.color(o.specular) ?? 1118481);
      u = { shininess: a, specular: d }, s.shininess = a, s.specular = d;
    } else if (o.category === "physical") {
      s = new Ns();
      let a = new Z(o.roughness ?? 0.3), d = new Z(o.metalness ?? 0), p = new Z(o.reflectivity ?? 0.5), f = new Fe(o.occlusion ?? true);
      u = { roughness: a, metalness: d, reflectivity: p, occlusion: f }, s.roughness = a, s.metalness = d, s.reflectivity = p, s.occlusion = f;
    } else {
      s = new As();
      let a = new Z(o.shininess ?? 30), d = new Oe(o.specular !== void 0 ? i.color(o.specular) ?? 1118481 : 1118481), p = new Fe(o.occlusion ?? true);
      u = { shininess: a, specular: d, occlusion: p }, s.shininess = a, s.specular = d, s.occlusion = p;
    }
    return s.alpha = new Z(1), s.shadingAlpha = l, s.shadingBlend = c, u.alpha = s.shadingAlpha, u.mode = s.shadingBlend, new Wt(e, t, o, s, u);
  }
  get category() {
    return this.node.category;
  }
};
function yO(n) {
  let r = n instanceof Mr ? n.type : n;
  return r === "texture" || r === "video" || r === "displace_map" || r === "matcap";
}
function qt(n) {
  return { alpha: new Z(n.alpha ?? 1), mode: new ve(n.mode ?? 0), isMask: new Fe(n.isMask ?? false) };
}
function gO(n, r, e, t) {
  switch (n.type) {
    case "color": {
      let o = new Oe(t.color ?? 5526619), i = qt(t), s = new Ro(o, i.alpha), l = new _e(s.calpha, "f");
      return new De(r, e, n, { color: o, ...i }, s, i.mode, l, i.isMask);
    }
    case "fresnel": {
      let o = new Oe(t.color ?? 16777215), i = new Z(t.bias ?? 0.1), s = new Z(t.scale ?? 1), l = new Z(t.intensity ?? 2), c = new Z(t.factor ?? 1), u = qt(t), a = new Ps(o, i, s, l, c, u.alpha, u.mode, u.isMask), d = new _e(a.calpha, "f");
      return new De(r, e, n, { color: o, bias: i, scale: s, intensity: l, factor: c, ...u }, a, u.mode, d, u.isMask);
    }
    case "rainbow": {
      let o = new Z(t.filmThickness ?? 30), i = new Z(t.movement ?? 0), s = new ut(t.wavelengths ?? new Vector3(0, 0, 0)), l = new Z(t.noiseStrength ?? 0), c = new Z(t.noiseScale ?? 1), u = new ut(t.offset ?? new Vector3(0, 0, 0)), a = qt(t), d = new bi(o, i, s, l, c, u, a.alpha, a.isMask), p = new _e(d.calpha, "f");
      return new De(r, e, n, { filmThickness: o, movement: i, wavelengths: s, noiseStrength: l, noiseScale: c, offset: u, ...a }, d, a.mode, p, a.isMask);
    }
    case "transmission": {
      let o = new Z(t.thickness ?? 10), i = new Z(t.ior ?? 1.5), s = new Z(t.roughness ?? 0.5), l = ye.transmissionSize, c = ye.transmissionRenderTarget, u = ye.transmissionRenderTargetDepth, a = window.innerWidth, d = window.innerHeight, p = a >= d ? new je(d / a, 1) : new je(1, a / d), f = qt(t), m = new wi(o, i, s, l, c, u, p, f.alpha), h = new _e(m.calpha, "f");
      return new De(r, e, n, { thickness: o, ior: i, roughness: s, aspectRatio: p, ...f }, m, f.mode, h, f.isMask);
    }
    case "toon": {
      let o = new ve(t.positioning ?? 0), i;
      t.colors ? i = new cr(t.colors.length, t.colors) : (i = new cr(10, new Vector4(0, 0, 0, 1)), i.value[1] = new Vector4(1, 1, 1, 1));
      let s;
      t.steps ? s = new lr(t.steps.length, t.steps) : (s = new lr(10, 1), s.value[0] = 0);
      let l = new ut(t.source ?? new Vector3(0, 0, 0)), c = new Fe(t.isWorldSpace ?? true), u = new Z(t.noiseStrength ?? 0), a = new Z(t.noiseScale ?? 1), d = new Nt(t.shadowColor), p = new ut(t.offset ?? new Vector3(0, 0, 0)), f = qt(t), m = new Si(o, i, s, l, c, u, a, d, p, f.alpha), h = new _e(m.calpha, "f");
      return new De(r, e, n, { positioning: o, colors: i, steps: s, source: l, isWorldSpace: c, noiseStrength: u, noiseScale: a, shadowColor: d, offset: p, ...f }, m, f.mode, h, f.isMask);
    }
    case "outline": {
      let o = new Oe(t.outlineColor ?? 16777215), i = new Oe(t.contourColor ?? 16777215), s = new Z(t.outlineWidth ?? 0.1), l = new Z(t.contourWidth ?? 0.1), c = new Z(t.outlineThreshold ?? 0.1), u = new Z(t.contourThreshold ?? 0.1), a = new Z(t.outlineSmoothing ?? 0.1), d = new Z(t.contourFrequency ?? 0.1), p = new ut(t.contourDirection ?? new Vector3(0, 1, 0)), f = new Fe(t.positionalLines ?? false), m = new Fe(t.compensation ?? true), h = ye.normalRenderTarget, y = ye.normalRenderTargetDepth, g = ye.pixelRatioNode, v = ye.resolution, b = qt(t), w = new xi(o, i, s, l, c, u, a, d, p, f, m, v, h, y, g, b.alpha), S = new _e(w.calpha, "f");
      return new De(r, e, n, { outlineColor: o, contourColor: i, outlineWidth: s, contourWidth: l, outlineThreshold: c, contourThreshold: u, outlineSmoothing: a, contourFrequency: d, contourDirection: p, positionalLines: f, compensation: m, ...b }, w, b.mode, S, b.isMask);
    }
    case "depth": {
      let o = new ve(t.gradientType ?? 0), i = new Fe(t.smooth ?? false), s = new Z(t.near ?? 50), l = new Z(t.far ?? 200), c = new Z(t.isVector ?? 1), u = new Z(t.isWorldSpace ?? 0), a = new ut(t.origin ?? new Vector3()), d = new ut(t.direction ?? new Vector3()), p;
      t.colors ? p = new cr(t.colors.length, t.colors) : (p = new cr(2, new Vector4(0, 0, 0, 1)), p.value[1] = new Vector4(1, 1, 1, 1));
      let f;
      t.steps ? f = new lr(t.steps.length, t.steps) : (f = new lr(2, 1), f.value[0] = 0);
      let m = qt(t), h = new mi(o, i, s, l, c, u, a, d, p, f, m.alpha, m.isMask), y = new _e(h.calpha, "f");
      return new De(r, e, n, { gradientType: o, smooth: i, near: s, far: l, isVector: c, isWorldSpace: u, origin: a, direction: d, colors: p, steps: f, ...m }, h, m.mode, y, m.isMask);
    }
    case "noise": {
      let o = new Z(t.scale ?? 1), i = new ut(t.size ?? new Vector3(100, 100, 100)), s = new Z(t.move ?? 1), l = new je(t.fA ?? new Vector2(1.7, 9.2)), c = new je(t.fB ?? new Vector2(8.3, 2.8)), u = new je(t.distortion ?? new Vector2(1, 1)), a = new Nt(t.colorA), d = new Nt(t.colorB), p = new Nt(t.colorC), f = new Nt(t.colorD), m = new ve(t.noiseType ?? 0), h = new ve(t.voronoiStyle ?? 0), y = new Z(t.highCut ?? 1), g = new Z(t.lowCut ?? 0), v = new Z(t.smoothness ?? 0.5), b = new Z(t.seed ?? 0.5), w = new ve(t.quality ?? 1), S = qt(t), P = new gi(o, i, s, l, c, u, a, d, p, f, S.alpha, m, S.isMask, h, y, g, v, b, w), _ = new _e(P.calpha, "f");
      return new De(r, e, n, { scale: o, size: i, move: s, fA: l, fB: c, distortion: u, colorA: a, colorB: d, colorC: p, colorD: f, noiseType: m, ...S, voronoiStyle: h, highCut: y, lowCut: g, smoothness: v, seed: b, quality: w }, P, S.mode, _, S.isMask);
    }
    case "normal": {
      let o = new ut(t.cnormal ?? new Vector3(1, 1, 1)), i = qt(t), s = new di(o, i.alpha), l = new _e(s.calpha, "f");
      return new De(r, e, n, { cnormal: o, ...i }, s, i.mode, l, i.isMask);
    }
    case "gradient": {
      let o = new ve(t.gradientType ?? 0), i = new Fe(t.smooth ?? false), s;
      t.colors ? s = new cr(t.colors.length, t.colors) : (s = new cr(10, new Vector4(0, 0, 0, 1)), s.value[1] = new Vector4(1, 1, 1, 1));
      let l;
      t.steps ? l = new lr(t.steps.length, t.steps) : (l = new lr(10, 1), l.value[0] = 0);
      let c = new je(t.offset ?? new Vector2(0, 0)), u = new je(t.morph ?? new Vector2(0, 0)), a = new Z(t.angle ?? 0), d = qt(t), p = new hi(o, i, s, l, c, u, a, d.alpha, d.isMask), f = new _e(p.calpha, "f");
      return new De(r, e, n, { gradientType: o, smooth: i, colors: s, steps: l, offset: c, morph: u, angle: a, ...d }, p, d.mode, f, d.isMask);
    }
    case "pattern": {
      let o = new ve(t.style ?? 0), i = new ve(t.projection ?? 0), s = new ve(["x", "y", "z"].indexOf(t.axis) ?? 0), l = new Z(t.blending ?? 0), c = new je(t.offset ?? new Vector2(0, 0)), u = new Nt(t.colorA), a = new Nt(t.colorB), d = new je(t.frequency ?? new Vector2(10, 10)), p = new Z(t.size ?? 0.5), f = new Z(t.variation ?? 0), m = new Z(t.smoothness ?? 0.5), h = new Z(t.zigzag ?? 0), y = new Z(t.rotation ?? 0), g = new je(t.vertical ?? new Vector2(0, 1)), v = new je(t.horizontal ?? new Vector2(0, 1)), b = new ve(t.sides ?? 6), w = qt(t), S = new vi(o, i, s, l, c, u, a, d, p, f, m, h, y, g, v, b, w.alpha, w.isMask), P = new _e(S.calpha, "f");
      return new De(r, e, n, { style: o, projection: i, axis: s, blending: l, offset: c, colorA: u, colorB: a, frequency: d, size: p, variation: f, smoothness: m, zigzag: h, rotation: y, vertical: g, horizontal: v, sides: b, ...w }, S, w.mode, P, w.isMask);
    }
    default: {
      let o = new Oe(1, 0, 0, 1), i = qt(t), s = new Ro(o, i.alpha), l = new _e(s.calpha, "f");
      return new De(r, e, n, { color: o, ...i }, s, i.mode, l, i.isMask);
    }
  }
}
function xO(n, r, e, t) {
  let o = jy(e, t);
  return gO(e, n, r, o);
}
function Kd(n, r, e) {
  if (e.type === "displace" && (n === "intensity" || n === "visible")) {
    let t = r.uniforms[`f${r.id}_intensity`];
    return t ? (t.value = e.intensity * (e.visible ? 1 : 0), t) : void 0;
  }
  if (e.type !== "displace" && (n === "alpha" || n === "visible")) {
    let t = r.uniforms[`f${r.id}_alpha`];
    if (!t)
      return;
    if (t.value = e.alpha * (e.visible ? 1 : 0), e.type === "outline" && n === "visible") {
      let o = r.uniforms[`f${r.id}_compensation`];
      o && (o.value = e.compensation && e.visible);
    }
    return t;
  }
}
function ky(n, r) {
  let e = 0;
  for (let t of n.layers) {
    if (t.data.type !== "displace" && t.data.isMask)
      return true;
    if (t.data.type !== "displace" && "alpha" in t.data && t.data.type !== "light" && t.data.type !== "fresnel" && t.data.type !== "texture" && t.data.type !== "matcap" && t.data.type !== "rainbow" && t.data.type !== "outline" && t.data.type !== "pattern") {
      let o = t.data.visible ? t.data.alpha : 0;
      if (o === 1 && t.data.type === "depth" || t.data.type === "gradient") {
        for (let i of t.data.colors)
          if (i[3] < 1) {
            o = i[3];
            break;
          }
      } else if (o === 1 && t.data.type === "noise") {
        let i = r.color(t.data.colorA).a, s = r.color(t.data.colorB).a, l = r.color(t.data.colorC).a, c = r.color(t.data.colorD).a, u = Math.min(i, Math.min(s, Math.min(l, c)));
        u < 1 && (o = u);
      }
      e += (1 - e) * o;
    }
  }
  return e < 1;
}
var It = class extends ShaderMaterial {
  constructor() {
    super(void 0);
    this.flatShading = false;
    this.needsJitter = true;
    this.cacheKey = "";
    this.fog = true, this.dithering = true, this.vertexColors = true, this.transparent = true;
  }
  customProgramCacheKey() {
    return this.cacheKey;
  }
};
var Ml = class extends It {
  constructor(e, t, o, i) {
    super();
    this.flatShading = e;
    this.side = t;
    this.wireframe = o;
    this.root = i;
  }
  updateAfterBuild() {
    let e = this.root;
    this.lights = e.lights, this.vertexShader = e.vertexShader, this.fragmentShader = e.fragmentShader, this.defines = e.defines, this.uniforms = e.uniforms, this.extensions = e.extensions, this.transparent = e.transparent, this.cacheKey = e.customProgramCacheKey() + "flat" + this.flatShading + this.side;
  }
  onBeforeCompile(e, t) {
    this.root.onBeforeCompile(e);
  }
  get data() {
    return this.root.data;
  }
  get category() {
    return this.root.category;
  }
  get hasAO() {
    return this.root.hasAO;
  }
  getFlavor(e, t, o) {
    return this.root.getFlavor(e, t, o);
  }
  get layers() {
    return this.root.layers;
  }
  get fragment() {
    return this.root.fragment;
  }
  getLayersOfType(e) {
    return this.root.getLayersOfType(e);
  }
  getLayerByUuid(e) {
    return this.root.getLayerByUuid(e);
  }
  updateByOp(e, t, o) {
    this.root.updateByOp(e, t, o);
  }
  nodeMaterialDispose() {
    this.root.nodeMaterialDispose();
  }
};
var zo = class extends It {
  constructor(e, t) {
    super();
    this.data = e;
    this.layerIdGen = 0;
    this.flavors = [];
    this.masks = {};
    this.type = "NodeMaterial";
    this.updaters = [], this.reset0(e, t);
  }
  get nodeMaterial() {
    return this;
  }
  getFlavor(e, t, o) {
    let i = o ? 6 : (e ? 3 : 0) + t;
    if (i === 0)
      return this;
    this.flavors === void 0 && (this.flavors = []), i -= 1;
    let s = this.flavors[i];
    return s === void 0 && (s = new Ml(e, t, o, this), this.flavors[i] = s, s.flatShading = e, s.side = t, s.updateAfterBuild()), s;
  }
  get fragment() {
    return this.lightLayer.node;
  }
  get category() {
    return this.lightLayer.category;
  }
  get hasAO() {
    var _a2;
    return ((_a2 = this.lightLayer.getNode("occlusion")) == null ? void 0 : _a2.value) ?? false;
  }
  reset(e, t) {
    this.data !== e && this.reset0(e, t);
  }
  reset0(e, t) {
    this.data = e;
    let o = e.layers ?? Ot.defaultTwoLayerData("phong").layers;
    this.layers = o.map((i) => Mr.create(this.layerIdGen++, i.id, i.data, t.shared)), this.layers.reverse(), this.name = e.name ?? "Untitled Material", this.onUpdate(), this.transparent = ky(e, t.shared);
  }
  getLayersOfType(e) {
    return this.layers.filter((t) => t.type === e);
  }
  getLayerByUuid(e) {
    return this.layers.find((t) => t.uuid === e);
  }
  onUpdate() {
    this.cacheKey = this.computeCacheKey(), this.lightLayer = this.layers.find((e) => e instanceof Wt), this.lightLayer === void 0 && (this.lightLayer = new Wt(0, "", { ...xt.defaultData("light", "phong"), visible: false }, new Vo(), {})), this.dispose();
    for (let e of this.flavors)
      e && e.dispose();
    this.applyMasks(), this.blendColors(), this.blendAfterColors(), this.blendPositions();
  }
  updateByOp(e, t, o) {
    var _a2, _b2, _c2, _d;
    if (t !== void 0 ? this.data = t : t = this.data, this.transparent = ky(t, o.shared), e.path[0] === "layers") {
      this.data = t;
      let i = o.shared, s = e.path[1];
      if (s === void 0) {
        if (this.layers.reverse(), e.type === 4) {
          let l = Mr.create(this.layerIdGen++, e.id, e.data, o.shared);
          this.layers.splice(e.localIndex, 0, l), (_a2 = o.scene) == null ? void 0 : _a2.markNeedsUpdateRendererDirty();
        } else if (e.type === 5)
          this.layers.splice(e.localIndex, 1)[0].dispose(), (_b2 = o.scene) == null ? void 0 : _b2.markNeedsUpdateRendererDirty();
        else if (e.type === 6) {
          let l = this.layers.findIndex((u) => u.uuid === e.id), c = this.layers[l];
          this.layers.splice(l, 1), this.layers.splice(e.localIndex, 0, c), (_c2 = o.scene) == null ? void 0 : _c2.markNeedsUpdateRendererDirty();
        }
        this.layers.reverse(), this.onUpdate();
      } else {
        e.type === 0 && e.props.occlusion !== void 0 && ((_d = o.scene) == null ? void 0 : _d.markNeedsUpdateRendererDirty());
        let l = this.layers.find((c) => c.uuid === s);
        if (l) {
          let c = t.layers.data(s);
          if (l.updateByOp({ ...e, path: e.path.slice(2) }, c, o)) {
            let a = Mr.create(this.layerIdGen++, s, c, i);
            this.layers.splice(this.layers.findIndex((d) => d.uuid === s), 1, a), this.onUpdate();
          }
        }
      }
    } else
      this.reset(t, o);
  }
  applyMasks() {
    for (let e = 0; e < this.layers.length; ++e) {
      let t = this.layers[e];
      t instanceof De ? t.color.mask = void 0 : t instanceof Wt && (t.node.mask = void 0);
    }
    for (let e = 0; e < this.layers.length; ++e) {
      let t = this.layers[e];
      if (t instanceof De && t.isMask.value && t.data.visible && e > 0) {
        let o = e - 1, i = this.layers[o];
        i instanceof Wt ? i.node.mask = new ot(t.color, t.alpha, ot.MUL) : i instanceof De && (i.isMask.value || (i.color.mask = new ot(t.color, t.alpha, ot.MUL)));
      }
    }
  }
  blendColors() {
    let e = this.layers.findIndex((o) => o instanceof De), t = this.layers.findIndex((o) => o instanceof Wt);
    if (e !== -1 && e < t) {
      let o = this.layers[e].color;
      for (let i = e + 1; i < t; ++i) {
        let s = this.layers[i];
        if (s instanceof De) {
          if (s.isMask.value)
            continue;
          o = new ci(o, s.color, s.alpha, s.mode);
        }
      }
      this.fragment.color = o;
    } else
      this.fragment.color = void 0;
  }
  blendAfterColors() {
    let e = new _e("outgoingLight", "f"), t = this.layers.findIndex((o) => o instanceof Wt);
    if (this.layers.length > t + 1) {
      for (let o = t + 1; o < this.layers.length; ++o) {
        let i = this.layers[o];
        if (i instanceof De) {
          if (i.isMask.value)
            continue;
          e = new ci(e, i.color, i.alpha, i.mode);
        }
      }
      this.fragment.afterColor = e;
    } else
      this.fragment.afterColor = void 0;
  }
  blendPositions() {
    let e = this.layers.filter((t) => t instanceof Is);
    if (e.length > 0) {
      let t = e[0].position;
      for (let o = 1; o < e.length; ++o)
        e[o] && (t = new ot(t, e[o].position, ot.ADD), t = new ot(t, new Z(0.5).setReadonly(true), ot.MUL));
      this.fragment.position = t;
    } else
      this.fragment.position = void 0;
  }
  getDefines() {
    return this.defines;
  }
  getUniforms() {
    return this.uniforms;
  }
  getVertexShader() {
    return this.vertexShader;
  }
  getFragmentShader() {
    return this.fragmentShader;
  }
  onBeforeCompile(e) {
    this.build(), e.defines = this.defines, e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.extensionDerivatives = this.extensions.derivatives === true, e.extensionFragDepth = this.extensions.fragDepth === true, e.extensionDrawBuffers = this.extensions.drawBuffers === true, e.extensionShaderTextureLOD = this.extensions.shaderTextureLOD === true;
  }
  clampUniformsForPreview(e, t) {
    let o = (i, s, l) => Math.min(Math.max(i, s), l);
    for (let i of this.layers)
      if (i.type === "displace") {
        let s = o(i.uniforms[`f${i.id}_intensity`].value, e, t);
        i.uniforms[`f${i.id}_intensity`].value = s;
      }
  }
  computeCacheKey() {
    let e = "[";
    for (let { data: t } of this.data.layers)
      if (t.type === "light")
        e += `"${t.visible ? t.category.toUpperCase() : "Basic"}"`;
      else {
        let o = ($d[t.type] ?? []).map((l) => t[l]), i = (Yd[t.type] ?? []).map((l) => {
          var _a2;
          return ((_a2 = t[l]) == null ? void 0 : _a2.length) ?? 0;
        }), s = [...o, ...i];
        s.length ? e += `["${t.type}", "${s.join('","')}"],` : e += `"${t.type}",`;
      }
    return e = e.slice(0, -1) + "]", e;
  }
  updateFrame(e) {
    for (let t = 0; t < this.updaters.length; ++t)
      e.updateNode(this.updaters[t]);
  }
  build() {
    let e = new Pl();
    e.needsJitter = this.needsJitter, this.lights = this.lightLayer.data.visible, e.build(this.fragment, this.fragment), this.vertexShader = e.getCode("vertex"), this.fragmentShader = e.getCode("fragment"), this.defines = e.defines, this.uniforms = e.uniforms, this.extensions = e.extensions, this.updaters = e.updaters;
    for (let t of this.flavors)
      t && t.updateAfterBuild();
    return this;
  }
  nodeMaterialDispose() {
    this.layers.forEach((e) => e.dispose()), super.dispose();
    for (let e of this.flavors)
      e && e.dispose();
  }
  assetsLoaded() {
    for (let e of this.layers)
      if (e instanceof De) {
        let t = e.params.texture;
        if (t instanceof Go && !t.image.loaded)
          return false;
      }
    return true;
  }
  getHash() {
    let e = "{";
    return e += '"fragment":' + this.fragment.getHash(), e += "}", e;
  }
};
Object.defineProperties(It.prototype, { properties: { get: function() {
  return this.fragment.properties;
} } });
var jo = class extends zo {
};
var Wy = Ws(Uy());
var Hy = /* @__PURE__ */ new Map();
function qy(n) {
  if (typeof n == "string")
    return n;
  let r = Hy.get(n);
  return r || (r = { url: URL.createObjectURL(new Blob([n])) }, Hy.set(n, r)), r.url;
}
var Fo = class {
  constructor({ src: r, volume: e, delay: t, loop: o }) {
    this._volume = 1;
    this.delay = 0;
    this._loop = 1;
    this.loopsRemaining = 0;
    this._status = "stopped";
    this.onEnd = () => {
      this.loopsRemaining === 1 / 0 ? this.replay() : this.loopsRemaining > 1 ? (this.replay(), this.loopsRemaining--) : (this._status = "stopped", this.loopsRemaining = this._loop);
    };
    let i;
    typeof r == "string" ? i = { src: r } : i = { src: qy(r), format: "wav" }, this.sound = new Wy.Howl(i), this.sound.on("end", this.onEnd), this.src = r, e !== void 0 && (this.volume = e), t !== void 0 && (this.delay = t), o !== void 0 && (this.loop = o);
  }
  get status() {
    return this._status;
  }
  get volume() {
    return this._volume;
  }
  set volume(r) {
    this._volume = r, this.sound.volume(r);
  }
  get loop() {
    return this._loop;
  }
  set loop(r) {
    this._loop = r, this.loopsRemaining = r;
  }
  replay() {
    this.clearDelay(), this.delayTimerId = window.setTimeout(() => {
      this.sound.play(), this.clearDelay();
    }, this.delay);
  }
  fade(r, e = 1e3) {
    r ? (this.sound.volume(this._volume), this.clearFade(), this.fadeTimerId = window.setTimeout(() => {
      this.sound.fade(this._volume, 0, e), this.clearFade();
    }, r)) : this.sound.fade(this._volume, 0, e);
  }
  on(r, e, t) {
    this.sound.on(r, e, t);
  }
  off(r, e, t) {
    this.sound.off(r, e, t);
  }
  play() {
    this._status === "playing" || this.sound.playing() || (this._status === "paused" ? (this.sound.seek() === 0 ? this.replay() : this.sound.play(), this._status = "playing") : this._status === "stopped" && (this.replay(), this._status = "playing"));
  }
  pause() {
    this._status === "playing" && (this.sound.pause(), this.clearFade(), this.clearDelay(), this._status = "paused");
  }
  stop() {
    this.sound.stop(), this.loopsRemaining = this._loop, this.clearFade(), this.clearDelay(), this._status = "stopped";
  }
  clearFade() {
    this.fadeTimerId && (clearTimeout(this.fadeTimerId), delete this.fadeTimerId);
  }
  clearDelay() {
    this.delayTimerId && (clearTimeout(this.delayTimerId), delete this.delayTimerId);
  }
  dispose(r = false) {
    this.off(), this.stop(), this.clearFade(), this.clearDelay();
  }
};
var Ll = class {
  constructor() {
    this.type = "ShapePath";
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }
  moveTo(r, e) {
    return this.currentPath = new Path(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(r, e), this;
  }
  lineTo(r, e) {
    var _a2;
    return (_a2 = this.currentPath) == null ? void 0 : _a2.lineTo(r, e), this;
  }
  quadraticCurveTo(r, e, t, o) {
    var _a2;
    return (_a2 = this.currentPath) == null ? void 0 : _a2.quadraticCurveTo(r, e, t, o), this;
  }
  bezierCurveTo(r, e, t, o, i, s) {
    var _a2;
    return (_a2 = this.currentPath) == null ? void 0 : _a2.bezierCurveTo(r, e, t, o, i, s), this;
  }
  splineThru(r) {
    var _a2;
    return (_a2 = this.currentPath) == null ? void 0 : _a2.splineThru(r), this;
  }
  toShapes() {
    let e = { ORIGIN: 0, DESTINATION: 1, BETWEEN: 2, LEFT: 3, RIGHT: 4, BEHIND: 5, BEYOND: 6 }, t = { loc: e.ORIGIN, t: 0 };
    function o(h, y, g, v) {
      let b = h.x, w = y.x, S = g.x, P = v.x, _ = h.y, x = y.y, C = g.y, T = v.y, N = (P - S) * (_ - C) - (T - C) * (b - S), O = (w - b) * (_ - C) - (x - _) * (b - S), A = (T - C) * (w - b) - (P - S) * (x - _), R = N / A, k = O / A;
      if (A === 0 && N !== 0 || R <= 0 || R >= 1 || k < 0 || k > 1)
        return null;
      if (N === 0 && A === 0) {
        for (let $ = 0; $ < 2; $++)
          if (i($ === 0 ? g : v, h, y), t.loc === e.ORIGIN) {
            let te = $ === 0 ? g : v;
            return { x: te.x, y: te.y, t: t.t };
          } else if (t.loc === e.BETWEEN) {
            let te = +(b + t.t * (w - b)).toPrecision(10), Y = +(_ + t.t * (x - _)).toPrecision(10);
            return { x: te, y: Y, t: t.t };
          }
        return null;
      } else {
        for (let Y = 0; Y < 2; Y++)
          if (i(Y === 0 ? g : v, h, y), t.loc === e.ORIGIN) {
            let W = Y === 0 ? g : v;
            return { x: W.x, y: W.y, t: t.t };
          }
        let $ = +(b + R * (w - b)).toPrecision(10), te = +(_ + R * (x - _)).toPrecision(10);
        return { x: $, y: te, t: R };
      }
    }
    function i(h, y, g) {
      let v = g.x - y.x, b = g.y - y.y, w = h.x - y.x, S = h.y - y.y, P = v * S - w * b;
      if (h.x === y.x && h.y === y.y) {
        t.loc = e.ORIGIN, t.t = 0;
        return;
      }
      if (h.x === g.x && h.y === g.y) {
        t.loc = e.DESTINATION, t.t = 1;
        return;
      }
      if (P < -Number.EPSILON) {
        t.loc = e.LEFT;
        return;
      }
      if (P > Number.EPSILON) {
        t.loc = e.RIGHT;
        return;
      }
      if (v * w < 0 || b * S < 0) {
        t.loc = e.BEHIND;
        return;
      }
      if (Math.sqrt(v * v + b * b) < Math.sqrt(w * w + S * S)) {
        t.loc = e.BEYOND;
        return;
      }
      let _;
      v !== 0 ? _ = w / v : _ = S / b, t.loc = e.BETWEEN, t.t = _;
    }
    function s(h, y) {
      let g = [], v = [];
      for (let b = 1; b < h.length; b++) {
        let w = h[b - 1], S = h[b];
        for (let P = 1; P < y.length; P++) {
          let _ = y[P - 1], x = y[P], C = o(w, S, _, x);
          C !== null && g.find((T) => T.t <= C.t + Number.EPSILON && T.t >= C.t - Number.EPSILON) === void 0 && (g.push(C), v.push(new Vector2(C.x, C.y)));
        }
      }
      return v;
    }
    function l(h, y, g) {
      let v = new Vector2();
      y.getCenter(v);
      let b = [];
      return g.forEach((w) => {
        w.boundingBox.containsPoint(v) && s(h, w.points).forEach((P) => {
          b.push({ identifier: w.identifier, isCW: w.isCW, point: P });
        });
      }), b.sort((w, S) => w.point.x - S.point.x), b;
    }
    function c(h, y, g, v, b) {
      (b == null || b === "") && (b = "nonzero");
      let w = new Vector2();
      h.boundingBox.getCenter(w);
      let S = [new Vector2(g, w.y), new Vector2(v, w.y)], P = l(S, h.boundingBox, y);
      P.sort((O, A) => O.point.x - A.point.x);
      let _ = [], x = [];
      P.forEach((O) => {
        O.identifier === h.identifier ? _.push(O) : x.push(O);
      });
      let C = _[0].point.x, T = [], N = 0;
      for (; N < x.length && x[N].point.x < C; )
        T.length > 0 && T[T.length - 1] === x[N].identifier ? T.pop() : T.push(x[N].identifier), N++;
      if (T.push(h.identifier), b === "evenodd") {
        let O = T.length % 2 === 0, A = T[T.length - 2];
        return { identifier: h.identifier, isHole: O, for: A };
      } else if (b === "nonzero") {
        let O = true, A = null, R = null;
        for (let k = 0; k < T.length; k++) {
          let $ = T[k];
          y[$] && (O ? (R = y[$].isCW, O = false, A = $) : R !== y[$].isCW && (R = y[$].isCW, O = true));
        }
        return { identifier: h.identifier, isHole: O, for: A };
      } else
        console.warn('fill-rule: "' + b + '" is currently not implemented.');
    }
    let u = 0, a = 999999999, d = -999999999, p = [];
    this.subPaths.forEach((h) => {
      let y = h.getPoints(), g = -999999999, v = 999999999, b = -999999999, w = 999999999;
      for (let S = 0; S < y.length; S++) {
        let P = y[S];
        P.y > g && (g = P.y), P.y < v && (v = P.y), P.x > b && (b = P.x), P.x < w && (w = P.x);
      }
      d <= b && (d = b + 1), a >= w && (a = w - 1), y.length && p.push({ curves: h.curves, points: y, isCW: ShapeUtils.isClockWise(y), identifier: u++, boundingBox: new Box2(new Vector2(w, v), new Vector2(b, g)) });
    });
    let f = p.map((h) => {
      var _a2;
      return c(h, p, a, d, (_a2 = this.userData) == null ? void 0 : _a2.style.fillRule);
    }), m = [];
    return p.forEach((h) => {
      let y = f[h.identifier];
      if (y && !y.isHole) {
        let g = new Shape();
        g.curves = h.curves, f.filter((b) => (b == null ? void 0 : b.isHole) && b.for === h.identifier).forEach((b) => {
          if (b) {
            let w = p[b.identifier], S = new Path();
            S.curves = w.curves, g.holes.push(S);
          }
        }), m.push(g);
      }
    }), m;
  }
};
var Xy;
var Zd = new Promise((n) => {
  Xy = n;
});
var Yy = false;
async function Ky() {
  if (Yy)
    return;
  let n = await import("./opentype-PUSIHXD5.js");
  Xy(n), Yy = true;
}
var Ms = class {
  async load(r, e, t = () => {
  }) {
    let { load: o } = await Zd;
    o(r, (i, s) => {
      i || !s ? t(i ?? "Something went wrong") : e(s);
    });
  }
  async parse(r) {
    let { parse: e, Bidi: t } = await Zd;
    try {
      let o = e(r), i = new t(), s = (l) => o.charToGlyphIndex(l.char);
      return i.registerModifier("glyphIndex", null, s), i.applyFeatures(o, o.defaultRenderOptions.features), { font: o, bidi: i };
    } catch (o) {
      console.error(o);
    }
  }
};
async function PO(n) {
  return await (await fetch(n)).arrayBuffer();
}
var TO = new Ms();
async function Qd(n) {
  let r, e, t = false;
  if (n.url ? (r = await PO(n.url), e = n.url, t = n.url.startsWith("/")) : n.data && (r = n.data.buffer), r) {
    let o = await TO.parse(r);
    if (o)
      return { font: o.font, url: e, intercepted: t, arr: r, bidi: o.bidi };
  }
}
function CO(n, r) {
  return r.state.glyphIndex === n || r.state.fina === n || r.state.medi === n || r.state.init === n;
}
var Bl = class {
  constructor(r) {
    this._arrayBuffer = new ArrayBuffer(1);
    this._isLoaded = false;
    this._intercepted = false;
    this._isUserFont = r.isUserFont ?? false, this._loadingPromise = Qd(r).then((e) => {
      e && (this._arrayBuffer = e.arr, this._url = e.url, this.font = e.font, this._intercepted = e.intercepted, this._isLoaded = true, this._bidi = e.bidi);
    });
  }
  update(r) {
    this._isLoaded = false, this._isUserFont = r.isUserFont ?? false, this._loadingPromise = Qd(r).then((e) => {
      e && (this._arrayBuffer = e.arr, this._url = e.url, this.font = e.font, this._intercepted = e.intercepted, this._isLoaded = true, this._bidi = e.bidi);
    });
  }
  get url() {
    return this._url;
  }
  get intercepted() {
    return this._intercepted;
  }
  get isLoaded() {
    return this._isLoaded;
  }
  get loadingPromise() {
    return this._loadingPromise;
  }
  reverseLigaturesTable(r, e, t) {
    if (!this._bidi)
      return [];
    let o = this._bidi;
    o.getTextGlyphs(e);
    let i = o.tokenizer.tokens, s = [], l = 0, c = t.length === i.length;
    for (let u = 0; u < t.length; u++) {
      let a = t[u].index, d = String.fromCharCode(t[u].unicode), p = i[l];
      if (CO(a, p) || c)
        s.push({ char: d, index: a, replacements: [p.state.glyphIndex], replacementChars: [p.char] }), l++;
      else {
        let f = p.char, m = "", h = [p.state.glyphIndex], y = [], g = false;
        for (; !g; )
          l++, m = e.charAt(l), f += m, h.push(r.charToGlyphIndex(m)), y = r.stringToGlyphs(f), y.length === 1 && y[0].index === a && (g = true), l > e.length && (g = true);
        s.push({ char: d, index: a, replacements: h, replacementChars: Array.from(f) }), l++;
      }
    }
    return s;
  }
  generateShapes(r, e) {
    if (!this._isLoaded)
      return;
    let t = this.font, o = e.fontSize / this.unitsPerEm, i = e.fontSize * e.lineHeight, s = r.map((v) => this.getTextWidth(v, e)), l = e.width, c = this.getCharWidth(`
`, e), u = e.horizontalAlign === 1 ? c : 0, a = this.computeSpaceWidthForLine(r, 0, e), d = this.getLineInitialOffsetX(s[0], l, e.horizontalAlign, r[0], c), p = this.getLineInitialOffsetY(i, r.length, e.height, o, e.verticalAlign), f = [], m = r.map((v) => []), h = r.map((v) => []), y;
    for (let v = 0; v < r.length; v++) {
      let b = r[v], w = { features: { liga: true } }, S = [];
      try {
        S = t.stringToGlyphs(b, w);
      } catch (_) {
        console.warn(_);
      }
      d = this.getLineInitialOffsetX(s[v], l, e.horizontalAlign, b, c);
      let P = [];
      try {
        P = this.reverseLigaturesTable(t, b, S);
      } catch (_) {
        console.warn(_);
      }
      a = this.computeSpaceWidthForLine(r, v, e);
      for (let _ = 0; _ < S.length; _++) {
        let x = S[_], C = x.index === 0 ? `
` : x.unicode ? String.fromCharCode(x.unicode) : void 0, T = P[_], N = 0, O = 0;
        _ === 0 && e.horizontalAlign === 2 && x.leftSideBearing !== void 0 && (O = -x.leftSideBearing * o), y && (N = t.getKerningValue(x, y) * o), d += O + N;
        let A = 0;
        if (C === `
`)
          A = u;
        else if (C === " ")
          A = a;
        else {
          let R = this.createPath(x, o, d, p, e);
          R && (A = R.offsetX - (N + O), f.push(R.path));
        }
        if (T.replacements.length === 1)
          h[v].push([d, p]), m[v].push(A);
        else {
          let R = T.replacements.map((Y) => (t.glyphs.get(Y).advanceWidth ?? 0) * o), k = R.reduce((Y, W) => Y += W, 0), $ = R.map((Y) => Y / k), te = d;
          for (let Y = 0; Y < $.length; Y++) {
            let W = A * $[Y];
            h[v].push([te, p]), m[v].push(W), te += W;
          }
        }
        d += A, y = x;
      }
      p -= i;
    }
    let g = [];
    for (let v = 0, b = f.length; v < b; v++)
      g.push(...f[v].toShapes());
    return { shapes: g, charWidths: m, lineWidths: s, charCoords: h };
  }
  get isUserFont() {
    return this._isUserFont;
  }
  get arrayBuffer() {
    return this._arrayBuffer;
  }
  get ascender() {
    var _a2;
    return ((_a2 = this.font) == null ? void 0 : _a2.ascender) ?? 0;
  }
  get descender() {
    var _a2;
    return ((_a2 = this.font) == null ? void 0 : _a2.descender) ?? 0;
  }
  get familyName() {
    var _a2;
    return ((_a2 = this.font) == null ? void 0 : _a2.names.fontFamily) ?? "";
  }
  get subfamilyName() {
    var _a2;
    return ((_a2 = this.font) == null ? void 0 : _a2.names.fontSubfamily) ?? "";
  }
  get unitsPerEm() {
    var _a2;
    return ((_a2 = this.font) == null ? void 0 : _a2.unitsPerEm) ?? 1;
  }
  getLineInitialOffsetX(r, e, t, o, i) {
    return (t === 3 || t === 2) && o.indexOf(`
`) >= 0 && (r -= i), t === 3 ? e * 0.5 - r * 0.5 : t === 2 ? e - r : 0;
  }
  getLineInitialOffsetY(r, e, t, o, i) {
    let s = e * r, l = Math.abs(this.ascender - this.descender) * o, c = r - l, u = -this.ascender * o - c / 2;
    return i === 3 ? -(t - s - u) : i === 2 ? -(t * 0.5 - s * 0.5 - u) : u;
  }
  createPath(r, e, t, o, i) {
    var _a2;
    let s = r.getPath(t, -o, i.fontSize, { kerning: false, letterSpacing: i.letterSpacing });
    if (!s) {
      console.error('THREE.Font: character "' + r + '" does not exists in font family ' + this.familyName + ".");
      return;
    }
    let l = new Ll(), c = (r.advanceWidth ?? 1) * e;
    if (r)
      for (let u of s.commands) {
        let a = (_a2 = l.currentPath) == null ? void 0 : _a2.currentPoint;
        if (!(a && u.type !== "Z" && a.x === u.x && -a.y === u.y))
          switch (u.type) {
            case "M":
              l.moveTo(u.x, -u.y);
              break;
            case "L":
              l.lineTo(u.x, -u.y);
              break;
            case "Q":
              l.quadraticCurveTo(u.x1, -u.y1, u.x, -u.y);
              break;
            case "C":
              l.bezierCurveTo(u.x1, -u.y1, u.x2, -u.y2, u.x, -u.y);
              break;
          }
      }
    return l.subPaths.forEach((u) => {
      let a = IO(u.curves);
      a !== void 0 && u.currentPoint.distanceTo(a) > 0 && u.lineTo(a.x, a.y);
    }), { offsetX: c + i.fontSize * i.letterSpacing, path: l };
  }
  getCharWidth(r, e) {
    var _a2;
    return ((_a2 = this.font) == null ? void 0 : _a2.getAdvanceWidth(r, e.fontSize, { kerning: true, letterSpacing: e.letterSpacing })) ?? 0;
  }
  getTextWidth(r, e) {
    var _a2;
    return ((_a2 = this.font) == null ? void 0 : _a2.getAdvanceWidth(r, e.fontSize, { kerning: true, letterSpacing: e.letterSpacing })) ?? 0;
  }
  computeSpaceWidthForLine(r, e, t) {
    let o = this.getCharWidth(" ", t), i = r[e];
    if (i) {
      let s = this.countSpaces(i.trimEnd());
      if (t.horizontalAlign === 4 && e < r.length - 1 && s) {
        let l = t.width, c = this.getTextWidth(i, t);
        return (l - (c - s * o)) / s;
      }
    }
    return o;
  }
  countSpaces(r) {
    return (r.match(/ /g) || []).length;
  }
};
function IO(n) {
  if (n.length) {
    let r = n[0];
    if (r instanceof LineCurve)
      return r.v1;
    if (r instanceof CubicBezierCurve || r instanceof QuadraticBezierCurve)
      return r.v0;
  }
}
var Jd = class {
  constructor() {
    this.objects = /* @__PURE__ */ new Map();
    this.unreachable = /* @__PURE__ */ new Set();
  }
  getCached(r) {
    return this.objects.get(r);
  }
  get size() {
    return this.objects.size;
  }
  get(r, e) {
    let t = this.objects.get(r);
    return t === void 0 ? (t = this.createObject(r, e), this.objects.set(r, t)) : t.isShared = true, t;
  }
  mutateIfUnique(r, e) {
    let t = this.objects.get(r);
    if (t && t.isShared !== true)
      return this.objects.delete(r), this.objects.set(e, t), t;
  }
  startGc() {
    this.unreachable = new Set(this.objects.keys());
  }
  markAsReachable(r, e) {
    let t = this.objects.get(r);
    e === t ? this.unreachable.delete(r) : false;
  }
  endGc() {
    this.unreachable.forEach((r) => {
      this.disposeObject(this.objects.get(r)), this.objects.delete(r);
    }), this.unreachable.clear();
  }
  dispose() {
    this.objects.forEach((r) => {
      this.disposeObject(r);
    }), this.objects.clear();
  }
};
var Es = class extends Jd {
  constructor(e) {
    super();
    this.flatShading = e;
  }
  disposeObject(e) {
    e.dispose();
  }
  createObject(e, t) {
    let o = Lo(e, t, this.flatShading);
    return o.computeBoundingSphere(), o;
  }
};
var Zy = { find(n) {
}, markNeedsUpdateRendererDirty: function() {
}, markGeometryCacheDirty: function() {
}, addPendingExpandCloner: function(n) {
}, addPendingUpdateCloner(n) {
}, addPendingCommand(n) {
} };
var eu = class extends Cl {
  constructor(e) {
    super();
    this.shared = e;
  }
  create(e) {
    return new Pi(e, this.shared);
  }
};
var Uo = class {
  constructor(r, e = {}) {
    this.geometryCache = new Es(true);
    this.geometryCache2 = new Es(false);
    this.imageHolderCache = new eu(this);
    this.thisContext = { scene: Zy, shared: this };
    this.deletedMaterial = new jo(Ot.defaultTwoLayerData("phong"), this.thisContext);
    this.deletedImage = new Ht(Dn.emptyImage, this);
    this.deletedVideo = new Ht(Nn.defaultVideo, this);
    this.materials = {};
    this.images = {};
    this.videos = {};
    this.colors = {};
    this.audios = {};
    this.fonts = {};
    this.penumbraSize = [];
    this.requestRender = () => {
      this._requestRender && this._requestRender();
    };
    if (e.images)
      for (let [t, o] of Object.entries(e.images))
        this.addImage(t, o);
    if (e.videos)
      for (let [t, o] of Object.entries(e.videos))
        this.addVideo(t, o);
    if (e.audios)
      for (let [t, o] of Object.entries(e.audios))
        this.addAudio(t, o.data);
    this.reset(r);
  }
  setRequestRender(r) {
    this._requestRender = r;
  }
  reset(r) {
    for (let [e, t] of Object.entries(r.images))
      this.addImage(e, t);
    for (let [e, t] of Object.entries(r.videos))
      this.addVideo(e, t);
    for (let [e, t] of Object.entries(r.colors))
      this.addColor(e, t);
    for (let [e, t] of Object.entries(r.materials))
      this.addMaterial(e, new jo(t, this.thisContext));
    for (let [e, t] of Object.entries(r.audios))
      this.addAudio(e, t.data);
    for (let [e, t] of Object.entries(r.fonts))
      this.addFont(e, t);
    this.penumbraSize = r.penumbraSize;
  }
  addMaterial(r, e) {
    e.uuid = r, this.materials[r] ? (this.materials[r].reset(e.data, this.thisContext), e.dispose()) : this.materials[r] = e;
  }
  deleteMaterial(r) {
    this.materials[r] && (this.materials[r].nodeMaterialDispose(), delete this.materials[r]);
  }
  getMaterial(r) {
    let e = this.materials[r];
    return e;
  }
  getMaterialOrDeletedPlaceholder(r) {
    return this.materials[r] ?? this.deletedMaterial;
  }
  material(r) {
    return typeof r == "string" ? this.getMaterialOrDeletedPlaceholder(r) : new zo(r, this.thisContext);
  }
  getMaterials() {
    return this.materials;
  }
  addImage(r, e) {
    return this.images[r] ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(), this.images[r].updateSrc(e.data), true) : (this.images[r] = new Ht(e, this), false);
  }
  deleteImage(r) {
    let e = this.images[r];
    e && (e.dispose(), delete this.images[r]);
  }
  getDefaultImage() {
    return this.images.image_0;
  }
  getImage(r) {
    return this.images[r] ?? this.deletedImage;
  }
  image(r) {
    return typeof r == "string" ? this.getImage(r) : this.imageHolderCache.load(r);
  }
  addVideo(r, e) {
    return this.videos[r] ? (this.videos[r].updateSrc(e.data), true) : (this.videos[r] = new Ht(e, this), false);
  }
  deleteVideo(r) {
    let e = this.videos[r];
    e && (e.dispose(), delete this.videos[r]);
  }
  getVideo(r) {
    return this.videos[r] ?? this.deletedVideo;
  }
  video(r) {
    return typeof r == "string" ? this.getVideo(r) : this.imageHolderCache.load(r);
  }
  addColor(r, e) {
    return this.colors[r] ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(), "a" in e ? this.colors[r].setRGBA(e.r, e.g, e.b, e.a) : this.colors[r].setRGBA(e.r, e.g, e.b, 1), true) : ("a" in e ? this.colors[r] = new go(e.r, e.g, e.b, e.a) : this.colors[r] = new go(e.r, e.g, e.b, 1), false);
  }
  updateColor(r, e) {
    if (this.colors[r]) {
      this.onColorOrImageUpdate && this.onColorOrImageUpdate();
      let t = this.colors[r];
      return this.colors[r].r = e.r ?? t.r, this.colors[r].g = e.g ?? t.g, this.colors[r].b = e.b ?? t.b, this.colors[r].a = e.a ?? t.a, true;
    }
    return false;
  }
  deleteColor(r) {
    this.colors[r] && delete this.colors[r];
  }
  getColor(r) {
    return this.colors[r];
  }
  color(r) {
    let e;
    if (typeof r == "string") {
      let t = this.getColor(r);
      t ? e = t : (console.warn("Tried to create color layer params with a color key that does not exist in the assets manager"), e = new Ke(0, 0, 0, 0));
    } else
      return "a" in r ? new Ke(r.r, r.g, r.b, r.a) : new Ke(r.r, r.g, r.b, 1);
    return e;
  }
  addAudio(r, e) {
    this.audios[r] = e;
  }
  getAudio(r) {
    let e = this.audios[r];
    if (e instanceof Fo)
      return e;
    {
      let t = new Fo({ src: e });
      return this.audios[r] = t, t;
    }
  }
  deleteAudio(r) {
    let e = this.audios[r];
    e && (e instanceof Fo && e.dispose(), delete this.audios[r]);
  }
  addFont(r, e) {
    this.fonts[r] = new Bl(e), this.fonts[r].loadingPromise.then(() => this.requestRender());
  }
  getFont(r) {
    return this.fonts[r];
  }
  deleteFont(r) {
    this.fonts[r] && delete this.fonts[r];
  }
  dispose() {
    Object.keys(this.materials).forEach((e) => this.deleteMaterial(e)), this._requestRender = void 0, Object.values(this.audios).forEach((e) => {
      e instanceof Fo && e.dispose();
    }), this.audios = {}, this.geometryCache.dispose(), this.geometryCache2.dispose();
  }
};
var Qy = new Uo(Wa.emptyData());
var $t = class extends dt {
  updateByPatchedOp(e, t, o) {
    if (super.updateByPatchedOp(e, t, o), tm(e.path, ["materials"]) !== null && e.type === 0 && Array.isArray(this.material))
      for (let [i, s] of Object.entries(e.props)) {
        let l = o.shared.material(s);
        this.material[Number(i)] = l;
      }
    else if (Zt(e.path, ["material"]) && this.material instanceof It)
      "material" in t && typeof t.material != "string" && this.material.updateByOp(lt.drop(e, 1), t.material, o);
    else if (Zt(e.path, ["materials", "*"]) && Array.isArray(this.material)) {
      let i = e.path[1];
      if ("materials" in t && i < this.material.length) {
        let s = t.materials[i];
        typeof s != "string" && this.material[i].updateByOp(lt.drop(e, 2), s, o);
      }
    }
  }
  get needsAO() {
    return this.material !== void 0 ? (Array.isArray(this.material) ? this.material[0] : this.material).hasAO : false;
  }
  updateState(e, t) {
    var _a2, _b2, _c2, _d, _e2;
    super.updateState(e, t), e.castShadow !== void 0 && (this.castShadow = e.castShadow), e.receiveShadow !== void 0 && (this.receiveShadow = e.receiveShadow);
    let o = this.dataPatched;
    if (((_a2 = e.geometry) == null ? void 0 : _a2.type) !== "NonParametricGeometry" && "material" in e && e.material !== void 0 && (this.disposeMaterial(), this.material = t.shared.material(e.material).getFlavor(o.flatShading, o.side, o.wireframe), (_b2 = t.scene) == null ? void 0 : _b2.markNeedsUpdateRendererDirty()), ((_c2 = e.geometry) == null ? void 0 : _c2.type) === "NonParametricGeometry" && ("materials" in e && e.materials !== void 0 ? (this.disposeMaterial(), this.material = e.materials.map((i) => t.shared.material(i).getFlavor(o.flatShading, o.side, o.wireframe)), (_d = t.scene) == null ? void 0 : _d.markNeedsUpdateRendererDirty()) : "material" in e && e.material !== void 0 && (this.disposeMaterial(), this.material = [t.shared.material(e.material).getFlavor(o.flatShading, o.side, o.wireframe)], (_e2 = t.scene) == null ? void 0 : _e2.markNeedsUpdateRendererDirty())), e.flatShading !== void 0 || e.wireframe !== void 0 || e.side !== void 0)
      if (Array.isArray(this.material))
        for (let i = 0; i < this.material.length; i++)
          this.material[i] = this.material[i].getFlavor(o.flatShading, o.side, o.wireframe);
      else
        this.material = this.material.getFlavor(o.flatShading, o.side, o.wireframe);
  }
  disposeMaterial() {
    this.material && $s(this.material).forEach((e) => {
      e instanceof It && (e instanceof jo || e.nodeMaterialDispose());
    });
  }
  dispose() {
    this.disposeMaterial(), super.dispose();
  }
};
var ft = class extends $t {
  constructor(e, t, o) {
    super(e, t);
    this.data = t;
    this.localGeometry = void 0;
  }
  chooseGeoemtryCache(e) {
    return e.geometryCache;
  }
  markGeometryAsReachable(e) {
    this.geometryCreateDeleyed instanceof BufferGeometry && this.chooseGeoemtryCache(e).markAsReachable(this.dataPatched.geometry, this.geometryCreateDeleyed);
  }
  get geometry() {
    if (this.localGeometry !== void 0)
      return this.localGeometry;
    if (this.geometryCreateDeleyed instanceof Uo) {
      let e = this.geometryCreateDeleyed, t = this.chooseGeoemtryCache(e);
      this.geometryCreateDeleyed = t.get(this.dataPatched.geometry, e);
    }
    return this.geometryCreateDeleyed;
  }
  set geometry(e) {
    this.localGeometry = e;
  }
  get is2DAndNoDepth() {
    let e = this.dataPatched.geometry;
    return Zi.is2DParametricMesh(e.type) && e.depth === 0;
  }
  get is2DType() {
    return Zi.is2DParametricMesh(this.geometry.userData.type);
  }
  get isNonParametric() {
    return this.geometry.userData.type === "NonParametricGeometry";
  }
  updateByPatchedOp(e, t, o) {
    super.updateByPatchedOp(e, t, o), Zt(e.path, ["geometry"]) && this.updateByPatchedOpGeometry(lt.drop(e, 1), t.geometry, o);
  }
  removeInteractionGeometry() {
    var _a2;
    (_a2 = this.localGeometry) == null ? void 0 : _a2.dispose(), this.localGeometry = void 0;
  }
  updateGeometryInteractions(e, t) {
    var _a2;
    this.invalidateDownstreamBooleanData();
    let o = this.data.geometry.type;
    if (o === "NonParametricGeometry" || o === "SubdivGeometry") {
      let i = e;
      if (this.localGeometry === void 0) {
        let a = { ...this.data.geometry, ...i };
        this.localGeometry = Lo(a, t, this.data.flatShading);
      }
      let s, l, c;
      i.scaleBaked ? [s, l, c] = i.scaleBaked : { width: s, height: l, depth: c } = i;
      let u = this.localGeometry.userData;
      u.sxPrev !== void 0 && xs(this.localGeometry.attributes, s / u.sxPrev, l / u.syPrev, c / u.szPrev), u.sxPrev = s, u.syPrev = l, u.szPrev = c;
    } else {
      let i = { ...this.data.geometry, ...e };
      (_a2 = this.localGeometry) == null ? void 0 : _a2.dispose(), this.localGeometry = Lo(i, t, this.data.flatShading);
    }
  }
  refreshAttachedCloners(e) {
    for (let t of this.attachedSurfaceCloners)
      e.scene.addPendingUpdateCloner(t.object);
  }
  refreshAttachedPaths(e) {
    for (let t of this.attachedPaths)
      e.scene.addPendingCommand(() => t.updateShape());
  }
  createGeometryDelayed(e) {
    this.geometryCreateDeleyed = e.shared, this.refreshAttachedCloners(e), this.refreshAttachedPaths(e);
  }
  updateByPatchedOpGeometry(e, t, o) {
    var _a2;
    let i = false;
    e.type === 0 && e.path.length === 0 && Ui(["scaleBaked"], Object.keys(e.props)) && this.geometryCreateDeleyed instanceof He && this.chooseGeoemtryCache(o.shared).mutateIfUnique(this.geometryCreateDeleyed.data, t) === this.geometryCreateDeleyed && (i = true, this.geometryCreateDeleyed.mutateDirectlyScaleBaked(t, e.props.scaleBaked), this.refreshAttachedCloners(o), this.refreshAttachedPaths(o)), i || ((_a2 = o.scene) == null ? void 0 : _a2.markGeometryCacheDirty(), this.createGeometryDelayed(o)), this.resetBBoxNeedsUpdate(), this.invalidateDownstreamBooleanData();
  }
  updateGeometryOnStateUpdate(e, t) {
    this.createGeometryDelayed(t);
  }
  updateState(e, t) {
    e.geometry !== void 0 && this.updateGeometryOnStateUpdate(e.geometry, t), super.updateState(e, t);
  }
  updateGeometryGroupsIfNeeded() {
    var _a2;
    Array.isArray(this.material) && this.geometry.groups.length === 0 && this.geometry.addGroup(0, Math.max(((_a2 = this.geometry.getIndex()) == null ? void 0 : _a2.count) ?? 0, this.geometry.getAttribute("position").count), 0);
  }
  updateEntityBoxSize(e, t) {
    let o = this.geometry.userData.parameters;
    this.is2DType ? e.set(0, 0, o.depth * 0.5) : this.isNonParametric ? (e.setScalar(0), this.geometry.boundingSphere && e.copy(this.geometry.boundingSphere.center), t.set(o.width, o.height, o.depth ?? 0).multiplyScalar(0.5)) : e.setScalar(0), t.set(o.width, o.height, o.depth ?? 0).multiplyScalar(0.5);
  }
};
function LO(n) {
  var _a2, _b2;
  if (n.geometry.attributes.extrudeNormal || !n.geometry.attributes.position || !n.geometry.attributes.normal)
    return;
  let r = /* @__PURE__ */ new Map(), e = n.geometry.attributes, t = e.position.array, o = e.normal.array, i = new Float32Array(t.length);
  for (let s = 0; s < t.length; s += 3) {
    let l = `${t[s]}_${t[s + 1]}_${t[s + 2]}`, c = new Vector3(o[s], o[s + 1], o[s + 2]);
    r.has(l) ? (_a2 = r.get(l)) == null ? void 0 : _a2.normals.push(c) : r.set(l, { normals: [c], result: new Vector3() });
  }
  r.forEach((s, l) => {
    for (let c of s.normals)
      s.result.add(c);
    s.result.divideScalar(s.normals.length);
  });
  for (let s = 0; s < t.length; s += 3) {
    let l = `${t[s]}_${t[s + 1]}_${t[s + 2]}`, c = (_b2 = r.get(l)) == null ? void 0 : _b2.result;
    c && (i[s] = c.x, i[s + 1] = c.y, i[s + 2] = c.z);
  }
  n.geometry.setAttribute("extrudeNormal", new Float32BufferAttribute(i, 3));
}
function BO(n) {
  if (n.geometry.attributes.extrudeNormals || !n.geometry.attributes.position)
    return;
  let e = n.geometry.attributes.position.array, t = new Float32Array(e.length), o = new Vector3();
  for (let i = 0; i < e.length; i += 3)
    o.set(e[i], e[i + 1], e[i + 2]).normalize(), t[i] = o.x, t[i + 1] = o.y, t[i + 2] = o.z;
  n.geometry.setAttribute("extrudeNormal", new Float32BufferAttribute(t, 3));
}
function Oi(n) {
  if (Array.isArray(n.material)) {
    for (let r of n.material)
      if (r.getLayersOfType("outline").length === 0)
        return;
  } else if (!(n.material instanceof It) || n.material.getLayersOfType("outline").length === 0)
    return;
  n instanceof ft && n.is2DAndNoDepth ? BO(n) : LO(n);
}
function Ai(n) {
  if (!n.geometry.attributes.position)
    return;
  let e = n.geometry.attributes.position.array, t = new Float32Array(e.length), o = parseInt(n.uuid.replace(/\D/g, "")), i = [MathUtils.seededRandom(o), MathUtils.seededRandom(o + 1e4), MathUtils.seededRandom(o + 2e4)];
  for (let s = 0; s < e.length; s++)
    t[s] = i[s % 3];
  n.geometry.setAttribute("randomColor", new BufferAttribute(t, 3));
}
var VO;
ei.then((n) => {
  VO = n;
});
var Er = new Box3();
var Ls = new Vector3();
function tg(n) {
  let r = false;
  return n.scene.objects.traverse((e, t) => {
    t.type === "Mesh" && t.geometry.type === "SubdivGeometry" && (r = true);
  }), r;
}
var Ho = class extends ft {
  constructor(e, t, o) {
    super(e, t, o);
    this.data = t;
    this.hiddenMatrixOld = new Matrix4();
    this.smoothShading = true;
    this.skipReactionUpdate = false;
  }
  chooseGeoemtryCache(e) {
    return this.dataPatched.flatShading ? e.geometryCache : e.geometryCache2;
  }
  get subdivPointerNew() {
    return this.localGeometry !== void 0 ? this.subdivPointer : this.geometry.ensureSubdivPointer();
  }
  get originalGeometryNew() {
    return this.localGeometry !== void 0 ? this.originalGeometry : this.geometry.originalGeometry;
  }
  get phongAngle() {
    return this.data.geometry.phongAngle ?? 45;
  }
  updateEntityBoxSize(e, t) {
    let o = this.geometry.userData.parameters;
    e.copy(this.originalGeometryNew.boundingSphere.center), t.set(o.width, o.height, o.depth ?? 0).multiplyScalar(0.5);
  }
  createGeometryByControls(e) {
    var _a2, _b2, _c2;
    if (this.skipReactionUpdate === true)
      return;
    let t = (_a2 = this.localGeometry) == null ? void 0 : _a2.uuid, { originalGeometry: o, subdividedGeometry: i, subdivPointer: s } = He.build(e, this.subdivPointer, this.smoothShading, this.hasNonUniformScale ? this.shearScale : void 0);
    this.subdivPointer = s, o !== void 0 && ((_b2 = this.originalGeometry) == null ? void 0 : _b2.dispose(), this.originalGeometry = o), i !== void 0 && ((_c2 = this.subdividedGeometry) == null ? void 0 : _c2.dispose(), this.subdividedGeometry = i ?? void 0), this.localGeometry = this.subdividedGeometry ?? this.originalGeometry, Oi(this), Ai(this), this.calcBoundingBox(), t && (this.localGeometry.uuid = t);
  }
  updateState(e, t) {
    if (super.updateState(e, t), e.flatShading !== void 0) {
      let o = this.material;
      this.material = o.getFlavor(false, o.side, o.wireframe), this.smoothShading = !e.flatShading, this.createGeometryDelayed(t);
    }
  }
  updateMesh(e = false) {
    He.buildLevel(this.subdivPointer, true, this.smoothShading ? this.phongAngle : -1, this.originalGeometry, e && this.hasNonUniformScale ? this.shearScaleInv : void 0), this.subdividedGeometry && He.buildLevel(this.subdivPointer, false, this.smoothShading ? this.phongAngle : -1, this.subdividedGeometry, e && this.hasNonUniformScale ? this.shearScaleInv : void 0);
  }
  updateTopology() {
    this.originalGeometry.dispose(), this.originalGeometry = He.buildLevel(this.subdivPointer, true, this.smoothShading ? this.phongAngle : -1), this.subdividedGeometry && (this.subdividedGeometry.dispose(), this.subdividedGeometry = He.buildLevel(this.subdivPointer, false, this.smoothShading ? this.phongAngle : -1)), this.localGeometry = this.subdividedGeometry ?? this.originalGeometry;
  }
  raycast(e, t) {
    let o = this.localGeometry;
    this.localGeometry = this.originalGeometryNew, dt.prototype.raycast.call(this, e, t), this.localGeometry = o;
  }
  activateSVDCompensation() {
    !this.hasNonUniformScale || (this.matrix.copy(this.matrixWorldRigid), this.hiddenMatrixOld.copy(this.hiddenMatrix), this.hiddenMatrix.copy(this.parent.matrixWorld).invert());
  }
  deactivateSVDCompensation() {
    !this.hasNonUniformScale || (this.updateMatrix(), this.hasNonUniformScale = void 0, this.hiddenMatrix.copy(this.hiddenMatrixOld));
  }
  calcBoundingBox() {
    let e = this.originalGeometry;
    e.boundingSphere === null && (e.boundingSphere = new Sphere(), this.subdividedGeometry && (this.subdividedGeometry.boundingSphere = e.boundingSphere));
    let t = e.attributes.position, o = e.boundingSphere.center;
    Er.setFromBufferAttribute(t), Er.getCenter(o), e.boundingSphere.radius = o.distanceTo(Er.max), isNaN(e.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this), Er.getSize(Ls), this.hasNonUniformScale && Ls.divide(this.scale);
    let i = { width: Ls.x, height: Ls.y, depth: Ls.z };
    return this.geometry.userData.parameters = i, i;
  }
  updateBoundingSphere(e) {
    let t = this.originalGeometry;
    Er.min.set(e[0], e[2], e[4]), Er.max.set(e[1], e[3], e[5]), this.hasNonUniformScale && (Er.min.applyMatrix4(this.shearScaleInv), Er.max.applyMatrix4(this.shearScaleInv)), t.boundingSphere === null && (t.boundingSphere = new Sphere());
    let o = t.boundingSphere.center;
    Er.getCenter(o), t.boundingSphere.radius = o.distanceTo(Er.max);
  }
  freeSubdivPointer() {
    var _a2, _b2;
    this.subdivPointer && (He.freeSubdivPointer(this.subdivPointer), this.subdivPointer = 0), this.localGeometry = void 0, (_a2 = this.originalGeometry) == null ? void 0 : _a2.dispose(), (_b2 = this.subdividedGeometry) == null ? void 0 : _b2.dispose();
  }
  dispose() {
    super.dispose(), this.freeSubdivPointer();
  }
  updateByPatchedOpGeometry(e, t, o) {
    super.updateByPatchedOpGeometry(e, t, o), this.localGeometry && this.createGeometryByControls(t);
  }
};
var rg = -1;
var jO = 1;
var og = { x: [1, 0, 0], "-x": [-1, 0, 0], y: [0, 1, 0], "-y": [0, -1, 0], z: [0, 0, 1], "-z": [0, 0, -1] };
var ng = { polygon_center: 0, edge: 1, vertex: 2 };
var Bs = (n, r) => (e, t) => !r || e === 0 || n === 0 ? 0 : n * t / 100;
var me = (n, r) => {
  let e = Math.abs(r), t = e * -1;
  return (n - rg) * (e - t) / (jO - rg) + t;
};
function ig(n) {
  let r = [], e = {};
  for (var t = 0, o = n.length; t < o; t++) {
    var i = JSON.stringify(n[t].pos.map((s) => Math.round(s * 1e4) / 1e4));
    e[i] || (r.push(n[t]), e[i] = true);
  }
  return r;
}
var FO = new Vector3();
var Dl = new Vector3();
var kO = new Vector3();
var UO = new Vector3();
function Ni(n, r) {
  let e = kO.fromArray(n), t = UO.fromArray(r);
  Dl.copy(t).sub(e);
  let o = Dl.length();
  return Dl.normalize().multiplyScalar(o * 0.5), FO.copy(e).add(Dl).toArray();
}
var Yt = new Triangle();
var Gl = new Vector3();
var Rl = new Vector3();
var qo = new Vector3();
function sg(n) {
  let r = [];
  for (let e = 0; e <= n.index.count; e++)
    if (Gl.fromArray(n.index.array, e * 3), Yt.setFromAttributeAndIndices(n.attributes.position, Gl.x, Gl.y, Gl.z), Yt.getNormal(Rl), Yt.getMidpoint(qo), !(isNaN(qo.x) || isNaN(qo.y) || isNaN(qo.z))) {
      let { a: t, b: o, c: i } = Yt, s = t.toArray(), l = o.toArray(), c = i.toArray(), u = t.distanceTo(o), a = o.distanceTo(i), d = i.distanceTo(t), p = Ni(s, l), f = Ni(l, c), m = Ni(c, s), h = [u, a, d], y = Math.max(...h), g = h.filter((w) => Math.round(w) === Math.round(y)).length > 1, v = [], b = Yt.getMidpoint(qo).toArray();
      y === u && !g && (v = [f, m, m], b = p), y === a && !g && (v = [p, m, m], b = f), y === d && !g && (v = [p, f, f], b = m), g && (v = [p, f, m]), r.push({ vertices: [s, l, c], faceCenters: v, midpoint: b, norm: Yt.getNormal(Rl).toArray() });
    }
  return r;
}
function ag(n) {
  let r = [], { position: e } = n.attributes;
  for (let t = 0; t < e.count; t++) {
    Yt.setFromAttributeAndIndices(e, t * 3, t * 3 + 1, t * 3 + 2), Yt.getNormal(Rl), Yt.getMidpoint(qo);
    let o = Yt.a.toArray(), i = Yt.b.toArray(), s = Yt.c.toArray();
    r.push({ vertices: [o, i, s], faceCenters: [Ni(o, i), Ni(i, s), Ni(s, o)], midpoint: qo.toArray(), norm: Rl.toArray() });
  }
  return r;
}
var HO = 4;
var qO = 0.5;
var ou = (n) => 0.5 * (1 - Math.cos(n * Math.PI));
var nu = class {
  constructor() {
    this.perlin = new Array(4095 + 1);
  }
  noise(r, e = 0, t = 0) {
    if (this.perlin == null) {
      this.perlin = new Array(4095 + 1);
      for (let g = 0; g < 4095 + 1; g++)
        this.perlin[g] = Math.random();
    }
    r < 0 && (r = -r), e < 0 && (e = -e), t < 0 && (t = -t);
    let o = Math.floor(r), i = Math.floor(e), s = Math.floor(t), l = r - o, c = e - i, u = t - s, a, d, p = 0, f = 0.5, m, h, y;
    for (let g = 0; g < HO; g++) {
      let v = o + (i << 4) + (s << 8);
      a = ou(l), d = ou(c), m = this.perlin[v & 4095], m += a * (this.perlin[v + 1 & 4095] - m), h = this.perlin[v + 16 & 4095], h += a * (this.perlin[v + 16 + 1 & 4095] - h), m += d * (h - m), v += 256, h = this.perlin[v & 4095], h += a * (this.perlin[v + 1 & 4095] - h), y = this.perlin[v + 16 & 4095], y += a * (this.perlin[v + 16 + 1 & 4095] - y), h += d * (y - h), m += ou(u) * (h - m), p += m * f, f *= qO, o <<= 1, l *= 2, i <<= 1, c *= 2, s <<= 1, u *= 2, l >= 1 && (o++, l--), c >= 1 && (i++, c--), u >= 1 && (s++, u--);
    }
    return p;
  }
  noiseSeed(r) {
    let e = (() => {
      let s, l;
      return { setSeed(c) {
        l = s = (c ?? Math.random() * 4294967296) >>> 0;
      }, getSeed() {
        return s;
      }, rand() {
        return l = (1664525 * l + 1013904223) % 4294967296, l / 4294967296;
      } };
    })();
    e.setSeed(r), this.perlin = new Array(4095 + 1);
    for (let t = 0; t < 4095 + 1; t++)
      this.perlin[t] = e.rand();
  }
};
var lg = nu;
var cg = new Vector3();
var dg = new Matrix4();
var ug = new Ray();
function pg(n) {
  let r = false;
  return n.scene.objects.traverse((e, t) => {
    t.type === "Mesh" && t.geometry.type === "TextGeometry" && (r = true);
  }), r;
}
var Ci = class extends ft {
  constructor(e, t, o) {
    super(e, t, o);
    this.data = t;
  }
  get textGeometry() {
    return this.geometry;
  }
  get charWidths() {
    return this.textGeometry.charWidths;
  }
  get charCoords() {
    return this.textGeometry.charCoords;
  }
  get wrappedText() {
    return this.textGeometry.wrappedText;
  }
  get font() {
    return this.textGeometry.font;
  }
  get initialOffsetY() {
    var _a2;
    let e = this.dataPatched;
    return ((_a2 = this.font) == null ? void 0 : _a2.getLineInitialOffsetY(this.lineHeight, this.wrappedText.length, e.geometry.height, this.fontScale, e.geometry.verticalAlign)) ?? 0;
  }
  get fontScale() {
    let e = this.dataPatched;
    return this.font ? e.geometry.fontSize / this.font.unitsPerEm : 1;
  }
  get AD() {
    return Math.abs(this.ascender - this.descender);
  }
  get ascender() {
    var _a2;
    return (((_a2 = this.font) == null ? void 0 : _a2.ascender) ?? 1) * this.fontScale;
  }
  get descender() {
    var _a2;
    return (((_a2 = this.font) == null ? void 0 : _a2.descender) ?? 1) * this.fontScale;
  }
  get lineHeight() {
    let e = this.dataPatched;
    return e.geometry.fontSize * e.geometry.lineHeight;
  }
  raycast(e, t) {
    let { matrixWorld: o } = this;
    if (!(isNaN(e.ray.origin.x) || this.scale.x === 0 || this.scale.y === 0 || this.scale.z === 0) && (dg.copy(o).invert(), ug.copy(e.ray).applyMatrix4(dg), ug.intersectBox(this.singleBBox, cg))) {
      let i = cg.applyMatrix4(o), s = e.ray.origin.distanceTo(i);
      t.push({ distance: s, point: i.clone(), object: this });
    }
  }
};
var St = 1e-4;
var Lr;
var yg;
var gg;
var xg;
var mg = new Vector3();
var hg = new Vector3();
ei.then((n) => {
  Lr = n, yg = [Lr.get_face_center, Lr.get_edge_midpoint, Lr.get_vertex_position], gg = [Lr.get_face_normal, Lr.get_edge_normal, Lr.get_vertex_normal], xg = [Lr.face_count, Lr.edge_count, Lr.vertex_count];
});
var KO = new Matrix4();
var ZO = new Matrix4();
var xo = new Vector3();
var $o = new Vector3();
var Ds = new Vector3();
var su = new Vector3();
var QO = new Vector3();
var JO = new Vector3();
var Kr = new lg();
var Mi = class extends Vn(Object3D) {
  constructor(e, t) {
    super();
    this.parameters = t;
    this.objectForSample = void 0;
    this._pendingMediaLoad = false;
    this.object = e;
  }
  resetOnMove() {
    this.removeFromParent(), this.parent = null;
  }
  expandClones(e) {
    if (this.parent === null)
      this.updateState(this.parameters, e);
    else
      for (let t of this.children)
        t instanceof Wr && t.expand();
  }
  invalidateTransform(e) {
    this.matrixWorldNeedsUpdate = true, this.traverse((t) => {
      t instanceof Wr && t.object === e && (t.matrixWorldNeedsUpdate = true);
    });
  }
  onObjUpdateMatrix() {
    this.parameters.type !== "toObject" && (this.matrixWorldNeedsUpdate = true);
  }
  update() {
    switch (this._updateCount(), this.parameters.type) {
      case "radial":
        this._updateRadial(this.parameters);
        break;
      case "linear":
        this._updateLinear(this.parameters);
        break;
      case "grid":
        this._updateGrid(this.parameters);
        break;
      case "toObject":
        this._updateToObject(this.parameters);
    }
    for (let e of this.children)
      e.updateMatrix(), e.hasNonUniformScale && (e.updateMatrixWorld(), e.updateMatrixWorldSVD());
  }
  _updateCount(e) {
    let t;
    if (e !== void 0 ? t = e : t = this.parameters.type === "grid" ? Math.round(this.parameters.grid.count[0]) * Math.round(this.parameters.grid.count[1]) * Math.round(this.parameters.grid.count[2]) : this.parameters.count, this.parameters.type === "toObject" && !this.parameters.toObject.object && (t = 0), this.parameters.type === "toObject" && this.objectForSample) {
      for (let i = 0, s = this.children.length; i < s; ++i)
        this.remove(this.children[0]);
      let o = this.children;
      if (o.length === t)
        return;
      if (o.length < t)
        for (let i = 0, s = t - o.length; i < s; ++i) {
          let l = new Wr(this.object);
          l.expand(), this.add(l);
        }
      else
        for (let i = 0, s = o.length - t; i < s; ++i)
          this.remove(o[i]);
    } else {
      if (this.children.length === t)
        return;
      if (this.children.length < t)
        for (let o = 0, i = t - this.children.length; o < i; ++o) {
          let s = new Wr(this.object);
          s.expand(), this.add(s);
        }
      else
        for (let o = 0, i = this.children.length - t; o < i; ++o)
          this.remove(this.children[0]);
    }
  }
  _updateRadial(e) {
    let t = e.radial, o = t.start * MathUtils.DEG2RAD, i = t.end * MathUtils.DEG2RAD, s = o - i, l = new Euler(t.rotation[0], t.rotation[1], t.rotation[2]), c;
    switch (t.axis) {
      case "z":
        c = new Vector3(0, 0, 1);
        break;
      case "y":
        c = new Vector3(0, 1, 0);
        break;
      default:
      case "x":
        c = new Vector3(1, 0, 0);
        break;
    }
    let u = e.randomnessObject ?? Sr.defaultData([1, 1, 1]).randomnessObject, a = u.noiseType === "perlin";
    Kr.noiseSeed(u.seed);
    let d = Xa((0, Ii.default)(u.seed)), p = Bs(u.strength, this.parameters.randomness);
    for (let [f, m] of this.children.entries()) {
      let h = f * (u.freqScale / 10) + u.movement, y = a ? Kr.noise(h) : d(h, h);
      m.scale.x = t.scale[0] + p(f, me(y, u.scale[0])) || St, m.scale.y = t.scale[1] + p(f, me(y, u.scale[1])) || St, m.scale.z = t.scale[2] + p(f, me(y, u.scale[2])) || St, m.position.setScalar(0);
      let g = s / e.count * f - o;
      switch (t.axis) {
        case "x":
          m.rotation.set(0, g, 0);
          break;
        case "y":
          m.rotation.set(0, 0, g);
          break;
        case "z":
          m.rotation.set(g, 0, 0);
          break;
      }
      m.translateOnAxis(c, t.radius), m.position.x += t.position[0] + p(f, me(y, u.position[0])), m.position.y += t.position[1] + p(f, me(y, u.position[1])), m.position.z += t.position[2] + p(f, me(y, u.position[2]));
      let v = p(f, me(y, u.rotation[0])), b = p(f, me(y, u.rotation[1])), w = p(f, me(y, u.rotation[2]));
      t.alignment === true ? (m.rotation.x += l.x + v, m.rotation.y += l.y + b, m.rotation.z += l.z + w) : m.rotation.set(l.x + v, l.y + b, l.z + w);
    }
  }
  _updateLinear(e) {
    if (e.type !== "linear")
      throw new Error();
    let t = e.linear, o = new Euler(t.rotation[0], t.rotation[1], t.rotation[2]), i = e.randomnessObject ?? Sr.defaultData([1, 1, 1]).randomnessObject, s = i.noiseType === "perlin";
    Kr.noiseSeed(i.seed);
    let l = Xa((0, Ii.default)(i.seed)), c = Bs(i.strength, this.parameters.randomness);
    for (let [u, a] of this.children.entries()) {
      let d = u * (i.freqScale / 10) + i.movement, p = s ? Kr.noise(d) : l(d, d), f = c(u, me(p, i.rotation[0])), m = c(u, me(p, i.rotation[1])), h = c(u, me(p, i.rotation[2]));
      a.scale.x = 1 + (t.scale[0] - 1) * u + c(u, me(p, i.scale[0])) || St, a.scale.y = 1 + (t.scale[1] - 1) * u + c(u, me(p, i.scale[1])) || St, a.scale.z = 1 + (t.scale[2] - 1) * u + c(u, me(p, i.scale[2])) || St, a.rotation.x = o.x * u + f, a.rotation.y = o.y * u + m, a.rotation.z = o.z * u + h, a.position.x = t.position[0] * u + c(u, me(p, i.position[0])), a.position.y = t.position[1] * u + c(u, me(p, i.position[1])), a.position.z = t.position[2] * u + c(u, me(p, i.position[2]));
    }
  }
  _updateGrid(e) {
    let t = 0, o = e.grid, i = e.randomnessObject ?? Sr.defaultData([1, 1, 1]).randomnessObject, s = Bs(i.strength, this.parameters.randomness), l = i.noiseType === "perlin";
    Kr.noiseSeed(i.seed);
    let c = Qm((0, Ii.default)(i.seed));
    if (o.useCenter === true) {
      let u = { x: o.count[0] % 2 === 0 ? 2 : 1, y: o.count[1] % 2 === 0 ? 2 : 1, z: o.count[2] % 2 === 0 ? 2 : 1 }, a = new Vector3(o.size[0] * (o.count[0] - u.x) * 0.5, o.size[1] * (o.count[1] - u.y) * 0.5, o.size[2] * (o.count[2] - u.z) * 0.5);
      for (let d = 0; d < o.count[0]; d++)
        for (let p = 0; p < o.count[1]; p++)
          for (let f = 0; f < o.count[2]; f++) {
            let m = [(d + 1) * (i.freqScale / 10) + i.movement, (p + 1) * (i.freqScale / 10) + i.movement, (f + 1) * (i.freqScale / 10) + i.movement], h = l ? Kr.noise(...m) : c(...m), y = this.children[t++];
            y.scale.x = 1 + s(t, me(h, i.scale[0])) || St, y.scale.y = 1 + s(t, me(h, i.scale[1])) || St, y.scale.z = 1 + s(t, me(h, i.scale[2])) || St;
            let g = s(t, me(h, i.rotation[0])), v = s(t, me(h, i.rotation[1])), b = s(t, me(h, i.rotation[2]));
            y.rotation.set(g, v, b), y.position.x = o.size[0] * d - a.x + s(t, me(h, i.position[0])), y.position.y = o.size[1] * p - a.y + s(t, me(h, i.position[1])), y.position.z = o.size[2] * f - a.z + s(t, me(h, i.position[2]));
          }
    } else
      for (let u = 0; u < o.count[0]; u++)
        for (let a = 0; a < o.count[1]; a++)
          for (let d = 0; d < o.count[2]; d++) {
            let p = [(u + 1) * (i.freqScale / 10) + i.movement, (a + 1) * (i.freqScale / 10) + i.movement, (d + 1) * (i.freqScale / 10) + i.movement], f = l ? Kr.noise(...p) : c(...p), m = this.children[t++];
            m.scale.x = 1 + s(t, me(f, i.scale[0])) || St, m.scale.y = 1 + s(t, me(f, i.scale[1])) || St, m.scale.z = 1 + s(t, me(f, i.scale[2])) || St;
            let h = s(t, me(f, i.rotation[0])), y = s(t, me(f, i.rotation[1])), g = s(t, me(f, i.rotation[2]));
            m.rotation.set(h, y, g), m.position.x = o.size[0] * u + s(t, me(f, i.position[0])), m.position.y = -o.size[1] * a + s(t, me(f, i.position[1])), m.position.z = -o.size[2] * d + s(t, me(f, i.position[2]));
          }
  }
  _updateToObject(e) {
    var _a2;
    if (e.type !== "toObject")
      throw new Error();
    let { toObject: t } = e, o = new Euler(t.rotation[0], t.rotation[1], t.rotation[2]), i = e.randomnessObject ?? Sr.defaultData([1, 1, 1]).randomnessObject, s = i.noiseType === "perlin";
    Kr.noiseSeed(i.seed);
    let l = Xa((0, Ii.default)(i.seed)), c = Bs(i.strength, this.parameters.randomness);
    if (!t.object) {
      for (let [, g] of this.children.entries())
        g.position.set(0, 0, 0), g.scale.setScalar(1), g.rotation.set(0, 0, 0);
      this.objectForSample = void 0;
      return;
    }
    if (!this.objectForSample)
      return;
    if (this.objectForSample instanceof Ci)
      if (!((_a2 = this.objectForSample.font) == null ? void 0 : _a2.isLoaded) || this.objectForSample.geometry.attributes.position === void 0) {
        this._pendingMediaLoad = true;
        return;
      } else
        this._pendingMediaLoad = false;
    if (this.objectForSample.geometry === void 0 && this.objectForSample.isAncestorOf(this.object.uuid)) {
      console.warn(`Oh no! The object "${this.object.name}" (${this.object.uuid}) seem to be a child/descendant of the object it's being cloned to. Please re-parent it so that they are siblings instead.`);
      return;
    }
    let u = this.getSubdivData(), a = [], d = (g) => {
      let v = g.length, b = g.map((P) => P[0]).reduce((P, _) => P + _, 0), w = g.map((P) => P[1]).reduce((P, _) => P + _, 0), S = g.map((P) => P[2]).reduce((P, _) => P + _, 0);
      return [b / v, w / v, S / v];
    }, p = (g) => Math.round(g * 1e6) / 1e6;
    u.forEach((g) => {
      let v = u.filter((b) => p(g.pos[0]) === p(b.pos[0]) && p(g.pos[1]) === p(b.pos[1]) && p(g.pos[2]) === p(b.pos[2]));
      v.length > 1 ? a.push({ pos: g.pos, norm: d(v.map((b) => b.norm)) }) : a.push(g);
    });
    let f = ig(a);
    if (u.length > 0) {
      let g = Math.round(f.length * t.count / 100);
      this._updateCount(g);
    }
    this.objectForSample.updateMatrixWorld();
    let m = new Ka(this.objectForSample).build(), h = og[t.axis], y = this.children;
    m.setRandomGenerator((0, Ii.default)(this.object.uuid + t.seed));
    for (let [g, v] of y.entries()) {
      let b = g * (i.freqScale / 10) + i.movement, w = s ? Kr.noise(b) : l(b, b), S = c(g, me(w, i.rotation[0])), P = c(g, me(w, i.rotation[1])), _ = c(g, me(w, i.rotation[2]));
      t.spreadType === "random" ? m.sample(Ds, su) : (f.length && (Ds.fromArray(f[g].pos), su.fromArray(f[g].norm)), this.objectForSample instanceof Ho && Ds.applyMatrix4(KO.copy(this.objectForSample.matrixWorld).invert())), Ds.applyMatrix4(this.object.hiddenMatrix.clone().invert()), v.position.copy(Ds), xo.fromArray(h);
      let x = t.align === "normal" ? su : this.object.getWorldDirection(JO), C = $o.fromArray(t.position);
      $o.x += $o.x + c(g, me(w, i.position[0])), $o.y += $o.y + c(g, me(w, i.position[1])), $o.z += $o.z + c(g, me(w, i.position[2]));
      let T = Math.acos(x.dot(xo)), N = QO.crossVectors(xo, x).normalize(), O = ZO.makeRotationAxis(N, T), A = x.clone().cross(this.object.up).normalize(), R = A.clone().cross(x).normalize(), k = new Matrix4().makeBasis(A, x, R), $ = new Vector3(xo.y, xo.z, xo.x).normalize(), te = $.clone().cross(xo).normalize(), Y = new Matrix4().makeBasis($, xo, te).invert(), W = new Matrix4().multiplyMatrices(k, Y);
      v.rotation.setFromRotationMatrix(W), C.applyMatrix4(O), v.position.add(C), v.rotation.x = v.rotation.x + o.x + S, v.rotation.y = v.rotation.y + o.y + P, v.rotation.z = v.rotation.z + o.z + _, v.scale.setScalar(1), v.scale.x = v.scale.x + t.scale[0] + c(g, me(w, i.scale[0])) || St, v.scale.y = v.scale.y + t.scale[1] + c(g, me(w, i.scale[1])) || St, v.scale.z = v.scale.z + t.scale[2] + c(g, me(w, i.scale[2])) || St, v.scale.multiply(this.object.scale), v.hiddenMatrix = this.object.hiddenMatrix;
    }
  }
  getSubdivData() {
    if (!this.objectForSample)
      return [];
    let e = this.parameters.toObject.spreadType;
    if (e === "random")
      return [];
    if (this.objectForSample instanceof Ho) {
      let t = this.objectForSample, o = ng[e], i = xg[o], s = yg[o], l = gg[o], c = [], u = i(t.subdivPointerNew);
      for (let a = 0; a <= u - 1; a++) {
        let d = s(t.subdivPointerNew, a), p = l(t.subdivPointerNew, a);
        mg.fromArray(d).applyMatrix4(t.matrixWorld), hg.fromArray(p), c.push({ pos: mg.toArray(), norm: hg.toArray() });
      }
      return c;
    } else
      return (this.objectForSample.geometry.index ? sg(this.objectForSample.geometry) : ag(this.objectForSample.geometry)).map((o, i) => e === "polygon_center" ? { pos: o.midpoint, norm: o.norm } : e === "vertex" ? [{ pos: o.vertices[0], norm: o.norm }, { pos: o.vertices[1], norm: o.norm }, { pos: o.vertices[2], norm: o.norm }] : e === "edge" ? [{ pos: o.faceCenters[0], norm: o.norm }, { pos: o.faceCenters[1], norm: o.norm }, { pos: o.faceCenters[2], norm: o.norm }] : []).flat();
  }
  updateState(e, t) {
    var _a2;
    if (this.parameters = Ur(e), this.parameters.type !== "toObject")
      (this.parent === null || this.parent !== this.object) && (this.removeFromParent(), (_a2 = this.object.parent) == null ? void 0 : _a2.add(this), this.matrix = this.object.matrix, this.hiddenMatrix = this.object.hiddenMatrix, this.matrixWorldNeedsUpdate = true, this.matrixAutoUpdate = false);
    else if (this.parent === null || this.parent.uuid !== this.parameters.toObject.object) {
      this.removeFromParent();
      let o = t.find(this.parameters.toObject.object);
      o instanceof dt ? this.objectForSample = o : this.objectForSample = void 0, this.matrix = new Matrix4(), this.hiddenMatrix = new Matrix4(), this.matrixWorldNeedsUpdate = true, this.matrixAutoUpdate = false, o && o.add(this);
    }
    this.update();
  }
  get pendingMediaLoad() {
    return this._pendingMediaLoad;
  }
};
var Br = (n) => {
  var r;
  return r = class extends n {
  }, r.geometryHelper = new BoxGeometry(30, 30, 30), r;
};
var Vl = new Ray();
var au = new Sphere();
var vg = new Matrix4();
var Dr = (n, r, e, t, o = false) => {
  let i = r, s = n.matrixWorld;
  if (i.boundingSphere === null && i.computeBoundingSphere(), au.copy(i.boundingSphere), au.applyMatrix4(s), e.ray.intersectsSphere(au) === false || (vg.copy(s).invert(), Vl.copy(e.ray).applyMatrix4(vg), i.boundingBox !== null && Vl.intersectsBox(i.boundingBox) === false))
    return;
  let l, c, u, a, d = i.index, p = i.attributes.position, f = i.drawRange, m, h;
  if (o === false) {
    let g = Math.max(0, f.start), v = Math.min(d.count, f.start + f.count);
    for (m = g, h = v; m < h; m += 3)
      if (c = d.getX(m), u = d.getX(m + 1), a = d.getX(m + 2), l = y(n, e, Vl, p, c, u, a), l) {
        l.faceIndex = Math.floor(m / 3), t.push(l);
        return;
      }
  } else {
    let v = i.attributes.position, b = new Vector3(), w = new Vector3(), S = new Vector3(), P = new Vector3(), _ = 2, C = 1 / ((n.scale.x + n.scale.y + n.scale.z) / 3), T = C * C, N = Math.max(0, f.start), O = Math.min(v.count, f.start + f.count);
    for (let A = N, R = O - 1; A < R; A += _) {
      if (b.fromBufferAttribute(v, A), w.fromBufferAttribute(v, A + 1), Vl.distanceSqToSegment(b, w, P, S) > T)
        continue;
      P.applyMatrix4(n.matrixWorld);
      let $ = e.ray.origin.distanceTo(P);
      $ < e.near || $ > e.far || t.push({ distance: $, point: S.clone().applyMatrix4(n.matrixWorld), object: n });
    }
  }
  function y(g, v, b, w, S, P, _) {
    let x = new Vector3(), C = new Vector3(), T = new Vector3(), N = new Vector3(), O = new Vector3();
    if (x.fromBufferAttribute(w, S), C.fromBufferAttribute(w, P), T.fromBufferAttribute(w, _), b.intersectTriangle(x, C, T, false, N) === null)
      return null;
    O.copy(N), O.applyMatrix4(g.matrixWorld);
    let R = v.ray.origin.distanceTo(O);
    return R < v.near || R > v.far ? null : { faceIndex: 1, distance: R, point: O.clone(), object: g };
  }
};
var zl = new Vector3();
var Xt = new Camera();
var cu = class extends LineSegments {
  constructor(e) {
    let t = new BufferGeometry(), o = new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false }), i = [], s = [], l = {}, c = new Color(15711266), u = new Color(15711266), a = new Color(2857471);
    d("n1", "n2", c), d("n2", "n4", c), d("n4", "n3", c), d("n3", "n1", c), d("f1", "f2", c), d("f2", "f4", c), d("f4", "f3", c), d("f3", "f1", c), d("n1", "f1", c), d("n2", "f2", c), d("n3", "f3", c), d("n4", "f4", c), d("p", "n1", u), d("p", "n2", u), d("p", "n3", u), d("p", "n4", u), d("u1", "u2", a), d("u2", "u3", a), d("u3", "u1", a);
    function d(f, m, h) {
      p(f, h), p(m, h);
    }
    function p(f, m) {
      i.push(0, 0, 0), s.push(m.r, m.g, m.b), l[f] === void 0 && (l[f] = []), l[f].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new Float32BufferAttribute(i, 3)), t.setAttribute("color", new Float32BufferAttribute(s, 3));
    super(t, o);
    this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = l, this.update();
  }
  update() {
    let e = this.geometry, t = this.pointMap, o = true;
    Xt.projectionMatrixInverse.elements = [0.5112609807824982, -0, -0, -0, -0, 0.41421356237309503, -0, -0, -0, -0, -0, -0.099999, -0, -0, -1.0000000000000002, 0.100001];
    let i = 1, s = 1, l = o ? 0.8 : 1e-4;
    pr("n1", t, e, Xt, -i, -s, l), pr("n2", t, e, Xt, i, -s, l), pr("n3", t, e, Xt, -i, s, l), pr("n4", t, e, Xt, i, s, l);
    let c = l;
    pr("f1", t, e, Xt, -i, -s, c), pr("f2", t, e, Xt, i, -s, c), pr("f3", t, e, Xt, -i, s, c), pr("f4", t, e, Xt, i, s, c);
    let u = c, a = 0.5;
    pr("u1", t, e, Xt, i * 0.7 * a, s * 1.1, u), pr("u2", t, e, Xt, -i * 0.7 * a, s * 1.1, u), pr("u3", t, e, Xt, 0, s * (1.1 + 0.9 * a), u), e.getAttribute("position").needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
function pr(n, r, e, t, o, i, s) {
  zl.set(o, i, s).unproject(t);
  let l = r[n];
  if (l !== void 0) {
    let c = e.getAttribute("position");
    for (let u = 0, a = l.length; u < a; u++)
      c.setXYZ(l[u], zl.x, zl.y, zl.z);
  }
}
var jl = class extends Br(cu) {
  constructor(e) {
    super(e);
    this.object = e;
    this.object = e, this.name = `CombinedCameraHelper: ${e.uuid}`;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.updateTarget();
  }
  updateTarget() {
    let e = this.object.getTarget();
    this.updateWorldMatrix(true, false), this.worldToLocal(e);
  }
  raycast(e, t) {
    Dr(this.object, this.geometry, e, t, true);
  }
};
var Fl;
((r) => r.is = (e) => "objectHelper" in e)(Fl || (Fl = {}));
var vo = (n, r) => class extends el(n) {
  constructor() {
    super(...arguments);
    this.objectHelper = new r(this);
    this.gizmos = {};
  }
  get geometryHelper() {
    return r.geometryHelper;
  }
  raycast(o, i) {
    this.objectHelper.raycast(o, i);
  }
  showGizmos() {
    for (let o in this.gizmos) {
      let i = this.gizmos[o];
      i instanceof Box3Helper && (i.visible = true);
    }
  }
  updateEntityBoxSize(o, i) {
    this.objectHelper.visible && this.geometryHelper instanceof BoxGeometry ? (o.setScalar(0), i.set(this.geometryHelper.parameters.width, this.geometryHelper.parameters.height, this.geometryHelper.parameters.height).multiplyScalar(0.5)) : super.updateEntityBoxSize(o, i);
  }
  hideGizmos() {
    for (let o in this.gizmos) {
      let i = this.gizmos[o];
      i instanceof Box3Helper && (i.visible = false);
    }
  }
};
var du = 790;
var Ei = new Vector3();
var uu = new Vector3();
var pu = new Quaternion();
var fu = new Vector3();
var Gs = new Vector3();
var mu = new Vector3();
var Gr = class extends vo(Camera, jl) {
  constructor(e = "", t = { ...En.defaultData, name: "" }) {
    super();
    this._cameraType = "OrthographicCamera";
    this.targetOffset = No.DefaultTargetOffset;
    this.isUpVectorFlipped = false;
    this.angleOffsetFromUp = 0;
    this.wasMovedByUser = false;
    this.wasMovedBySwitchCameraAction = false;
    this.super_Entity(e, t), this.previousProjectionMatrix = new Matrix4(), this.matrixAutoUpdate = true, this.width = window.innerWidth, this.height = window.innerHeight;
    let o = this.width, i = this.height;
    if (t.orthographic.autoZoom) {
      let s = t.orthographic.autoZoomFrustumSize ?? du, l = o / i, c = o > i ? l : 1, u = o > i ? 1 : l;
      this.orthoCamera = new OrthographicCamera(-s * 0.5 * c, s * 0.5 * c, s * 0.5 * (1 / u), -s * 0.5 * (1 / u), -5e4, 1e4);
    } else
      this.orthoCamera = new OrthographicCamera(o * -0.5, o * 0.5, i * 0.5, i * -0.5, -5e4, 1e4);
    this.perspCamera = new PerspectiveCamera(45, o / i, 50, 1e4), this.left = this.orthoCamera.left, this.right = this.orthoCamera.right, this.top = this.orthoCamera.top, this.bottom = this.orthoCamera.bottom, this.far = this.orthoCamera.far, this.view = this.orthoCamera.view, this.aspect = this.perspCamera.aspect, this.focus = this.perspCamera.focus, this.filmGauge = this.perspCamera.filmGauge, this.filmOffset = this.perspCamera.filmOffset, this.objectHelper.update();
  }
  get isPerspectiveCamera() {
    return this.cameraType === "PerspectiveCamera";
  }
  get isOrthographicCamera() {
    return !this.isPerspectiveCamera;
  }
  get cameraType() {
    return this._cameraType;
  }
  set fov(e) {
    this.perspCamera.fov = e;
  }
  get fov() {
    return this.perspCamera.fov;
  }
  setNear(e, t) {
    e === "PerspectiveCamera" ? this.perspCamera.near = t : this.orthoCamera.near = t;
  }
  setZoom(e, t) {
    t >= 0 && (e === "PerspectiveCamera" ? this.perspCamera.zoom = t : this.orthoCamera.zoom = t);
  }
  set cameraType(e) {
    e === "PerspectiveCamera" ? this.toPerspective() : e === "OrthographicCamera" && this.toOrthographic();
  }
  get near() {
    return this._cameraType === "PerspectiveCamera" ? this.perspCamera.near : this.orthoCamera.near;
  }
  set near(e) {
    this._cameraType === "PerspectiveCamera" ? this.perspCamera.near = e : this.orthoCamera.near = e;
  }
  get zoom() {
    return this._cameraType === "PerspectiveCamera" ? this.perspCamera.zoom : this.orthoCamera.zoom;
  }
  set zoom(e) {
    e >= 0 && (this._cameraType === "PerspectiveCamera" ? this.perspCamera.zoom = e : this.orthoCamera.zoom = e);
  }
  lookAt(e, t, o) {
    typeof e == "number" && (e = new Vector3(e, t, o)), super.lookAt(e), this.getWorldPosition(Ei), this.targetOffset = Ei.distanceTo(e);
  }
  getTarget(e = new Vector3()) {
    return this.getWorldDirection(uu), this.getWorldPosition(Ei), uu.multiplyScalar(this.targetOffset), e.copy(Ei).add(uu), e;
  }
  getDistanceToTarget() {
    let e = this.getTarget();
    return this.getWorldPosition(Ei), Ei.distanceTo(e);
  }
  updateUp() {
    this.getWorldQuaternion(pu), fu.set(0, 0, 1).applyQuaternion(pu), Gs.copy(Object3D.DEFAULT_UP), this.isUpVectorFlipped && Gs.negate(), Gs.applyQuaternion(pu), mu.copy(Object3D.DEFAULT_UP).projectOnPlane(fu), this.angleOffsetFromUp = mu.angleTo(Gs), this.angleOffsetFromUp *= mu.cross(Gs).dot(fu) >= 0 ? 1 : -1;
  }
  updateTransformState(e) {
    let t = super.updateTransformState(e);
    return e.isUpVectorFlipped !== void 0 && (this.isUpVectorFlipped = e.isUpVectorFlipped), this.updateUp(), t;
  }
  getViewFrontToObject(e) {
    let t = e.getWorldPosition(new Vector3()), i = e.getWorldDirection(new Vector3()).multiplyScalar(this.targetOffset);
    return { position: t.clone().add(i), target: t };
  }
  getViewToObject(e) {
    let t = e.getWorldPosition(new Vector3()), i = this.getWorldDirection(new Vector3()).multiplyScalar(this.targetOffset);
    return { position: t.clone().sub(i), target: t };
  }
  setViewplaneSize(e, t) {
    if (this.aspect = e / t, this.data.type === "OrthographicCamera" && this.data.orthographic.autoZoom) {
      let o = this.data.orthographic.autoZoomFrustumSize ?? du, i = e > t ? this.aspect : 1, s = e > t ? 1 : this.aspect;
      this.left = -o * 0.5 * i, this.right = o * 0.5 * i, this.top = o * 0.5 * (1 / s), this.bottom = -o * 0.5 * (1 / s);
    } else
      this.left = -e * 0.5, this.right = e * 0.5, this.top = t * 0.5, this.bottom = -t * 0.5;
    this.updateProjectionMatrix();
  }
  toOrthographic() {
    this.orthoCamera.left = this.left, this.orthoCamera.right = this.right, this.orthoCamera.top = this.top, this.orthoCamera.bottom = this.bottom, this.orthoCamera.view = this.view, this.orthoCamera.far = this.far, this.orthoCamera.updateProjectionMatrix(), this.projectionMatrix = this.orthoCamera.projectionMatrix, this.projectionMatrixInverse = this.orthoCamera.projectionMatrixInverse, this._cameraType = "OrthographicCamera", this.objectHelper && this.objectHelper.update();
  }
  toPerspective() {
    this.perspCamera.aspect = this.aspect, this.perspCamera.fov = this.fov, this.perspCamera.view = this.view, this.perspCamera.far = this.far, this.perspCamera.updateProjectionMatrix(), this.projectionMatrix = this.perspCamera.projectionMatrix, this.projectionMatrixInverse = this.perspCamera.projectionMatrixInverse, this._cameraType = "PerspectiveCamera", this.objectHelper && this.objectHelper.update();
  }
  setFocalLength(e) {
    this.perspCamera.setFocalLength(e), this.toPerspective();
  }
  getFocalLength() {
    return this.perspCamera.getFocalLength();
  }
  getEffectiveFOV() {
    return this.perspCamera.getEffectiveFOV();
  }
  getFilmWidth() {
    return this.perspCamera.getFilmWidth();
  }
  getFilmHeight() {
    return this.perspCamera.getFilmHeight();
  }
  setViewOffset(e, t, o, i, s, l) {
    this._cameraType === "PerspectiveCamera" ? this.perspCamera.setViewOffset(e, t, o, i, s, l) : this.orthoCamera.setViewOffset(e, t, o, i, s, l);
  }
  clearViewOffset() {
    this._cameraType === "PerspectiveCamera" ? (this.perspCamera.clearViewOffset(), this.toPerspective()) : (this.orthoCamera.clearViewOffset(), this.toOrthographic());
  }
  copyHistory() {
    this.previousProjectionMatrix && this.previousProjectionMatrix.copy(this.projectionMatrix);
  }
  updateProjectionMatrix() {
    this._cameraType === "PerspectiveCamera" ? this.toPerspective() : this._cameraType === "OrthographicCamera" && this.toOrthographic();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  copy(e, t) {
    return super.copy(e, t), this.parent = e.parent, this.orthoCamera.copy(e.orthoCamera), this.perspCamera.copy(e.perspCamera), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.far = e.far, this.view = e.view === null ? null : Object.assign({}, e.view), this._cameraType = e._cameraType, this.aspect = e.aspect, this.fov = e.fov, this.focus = e.focus, this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this.targetOffset = e.targetOffset, this.updateProjectionMatrix(), this;
  }
  toCameraState(e = []) {
    let t = { type: this.cameraType, far: this.far, orthographic: { near: this.orthoCamera.near, zoom: this.orthoCamera.zoom, autoZoom: true, autoZoomFrustumSize: du }, perspective: { near: this.perspCamera.near, fov: this.perspCamera.fov, zoom: this.perspCamera.zoom }, up: this.up.toArray(), targetOffset: this.targetOffset, isUpVectorFlipped: this.isUpVectorFlipped };
    return xn(t, e);
  }
  updateCameraSubtype(e, t) {
    let o = e === "perspective" ? "PerspectiveCamera" : "OrthographicCamera";
    t.zoom !== void 0 && this.setZoom(o, t.zoom), t.near !== void 0 && this.setNear(o, t.near), t.fov !== void 0 && o === "PerspectiveCamera" && (this.fov = t.fov);
  }
  updateState(e, t) {
    this.updateCameraState(e, t);
  }
  updateCameraState(e, t) {
    this.updateState_Entity(e, t), e.far !== void 0 && (this.far = e.far), e.orthographic !== void 0 && this.updateCameraSubtype("orthographic", e.orthographic), e.perspective !== void 0 && this.updateCameraSubtype("perspective", e.perspective), e.type !== void 0 && (this.cameraType = e.type), e.up !== void 0 && this.up.fromArray(e.up), e.targetOffset !== void 0 && (this.targetOffset = e.targetOffset), e.isUpVectorFlipped !== void 0 && (this.isUpVectorFlipped = e.isUpVectorFlipped), this.updateProjectionMatrix();
  }
  updateByPatchedOp(e, t, o) {
    super.updateByPatchedOp(e, t, o), e.path.length === 1 && e.type === 0 && this.updateCameraSubtype(e.path[0], e.props);
  }
  toState(e) {
    return { ...super.toState(e), ...this.toCameraState(e), type: this.cameraType };
  }
};
var Li = new Matrix4();
var yA = new Matrix4();
var Kt = class extends $t {
  constructor(e, t, o) {
    super(e, t);
    this.data = t;
    this.meshSetAddresses = [];
    this.needsTransformForDownstream = false;
    this.geometry = new BufferGeometry();
    this.onAfterRender = (e2, t2, o2, i, s, l) => {
      super.onAfterRender(e2, t2, o2, i, s, l), this.recomputeBoolean();
    };
    this.geometry.userData.parameters = { width: 0, height: 0, depth: 0 };
  }
  get booleanOp() {
    return this.data.geometry.operation;
  }
  get phongAngle() {
    return this.data.geometry.phongAngle ?? 45;
  }
  get isLOD() {
    return this.recomputeBoolean(), false;
  }
  updateByPatchedOp(e, t, o) {
    super.updateByPatchedOp(e, t, o), e.path.length === 1 && e.path[0] === "geometry" && e.type === 0 && e.props.operation !== void 0 && (this.freeBooleanPointer(), this.resetBBoxNeedsUpdate());
  }
  freeBooleanPointer() {
    super.freeBooleanPointer(), this.geometry.dispose();
  }
  recomputeBoolean(e, t = true) {
    var _a2;
    if (this.booleanMeshSetAddress !== -1 && !e)
      return;
    for (let i = 0; i < this.children.length; i++) {
      let s = this.children[i];
      s instanceof Kt && s.recomputeBoolean(e === true, t);
    }
    this.meshSetAddresses = [];
    for (let i = 0; i < this.children.length; i++) {
      let s = this.children[i];
      if (s instanceof dt && s.dataPatched.visible === true && ((_a2 = s.geometry.attributes.position) == null ? void 0 : _a2.count) > 0 && s.geometry.drawRange.count > 0) {
        if (Li.multiplyMatrices(s.hiddenMatrix, s.matrix), s.booleanMeshSetAddress === -1) {
          if ((s.geometry.index ?? s.geometry.getAttribute("position")).count / 3 < 15e5 && (s.booleanMeshSetAddress = sr.getMeshSet(s.geometry, e === true, t)), s.booleanMeshSetAddress === -1)
            return;
          sr.transformMeshSet(s.booleanMeshSetAddress, Li), s.booleanMatrixInvOld.copy(Li).invert(), s.booleanWasTransformed = false;
        } else
          s instanceof Kt && s.needsTransformForDownstream === true ? (sr.transformMeshSet(s.booleanMeshSetAddress, Li), s.needsTransformForDownstream = false) : s.booleanWasTransformed === true && (sr.transformMeshSet(s.booleanMeshSetAddress, yA.multiplyMatrices(Li, s.booleanMatrixInvOld)), s.booleanMatrixInvOld.copy(Li).invert(), s.booleanWasTransformed = false);
        this.meshSetAddresses.push(s.booleanMeshSetAddress);
      }
    }
    if (this.meshSetAddresses.length === 0) {
      this.geometry.setAttribute("position", new Float32BufferAttribute([], 0)), this.geometry.setDrawRange(0, 0);
      return;
    }
    if (e === true)
      return sr.calcBooleanTopological(this.meshSetAddresses, this.booleanOp);
    let o = this.geometry;
    o.dispose(), this.geometry = new BufferGeometry(), this.geometry.userData = o.userData, this.geometry.boundingSphere = o.boundingSphere;
    try {
      this.booleanMeshSetAddress = sr.calcBoolean(this.meshSetAddresses, this.booleanOp, this.geometry, this.phongAngle);
    } catch (i) {
      this.booleanMeshSetAddress = 0, console.error(i);
    }
    this.booleanMatrixInvOld.copy(this.matrix).invert(), this.needsTransformForDownstream = true, Oi(this), Ai(this);
  }
  dispose() {
    super.dispose(), this.geometry.dispose();
  }
};
var Og;
((r) => {
  function n(e) {
    return Ie.is(e) && e instanceof Light;
  }
  r.is = n;
})(Og || (Og = {}));
var Bi = (n, r) => class extends vo(n, r) {
  updateState_Light(t, o) {
    this.updateState_Entity(t, o), t.color !== void 0 && (this.color = o.shared.color(t.color)), t.intensity !== void 0 && (this.intensity = t.intensity), t.depth !== void 0 && (this.shadow.camera.far = t.depth, this.shadow.needsUpdate = true), t.shadows !== void 0 && (this.castShadow = t.shadows);
  }
};
var Di = (n) => n instanceof dt;
var Rs = (n) => n !== null && n instanceof Kt;
var Ag = (n) => n instanceof Gr;
var hu = (n) => Fl.is(n);
var bo = class extends Br(AxesHelper) {
  constructor(e, t = 15) {
    super(t);
    this.object = e;
    this.object.updateMatrixWorld(), this.name = `EmptyObjectHelper: ${e.uuid}`, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false;
  }
  raycast(e, t) {
    Dr(this.object, bo.geometryHelper, e, t);
  }
  update() {
  }
};
var Vs = class extends vo(Group, bo) {
  constructor(r, e) {
    super(), this.super_Entity(r, e), this.objectHelper.update();
  }
  updateState(r, e) {
    this.updateState_Entity(r, e);
  }
};
var Gi = class extends Br(DirectionalLightHelper) {
  constructor(e, t = 15, o = 10066329) {
    super(e, t, o);
    this.object = e;
    this.added = false;
    this.name = `DirectionalLightHelper: ${e.uuid}`;
  }
  raycast(e, t) {
    Dr(this.object, Gi.geometryHelper, e, t);
  }
};
var Ri = class extends Br(PointLightHelper) {
  constructor(e, t = 15, o = 6710886) {
    super(e, t, o);
    this.object = e;
    this.name = `PointLightHelper: ${e.uuid}`;
  }
  raycast(e, t) {
    Dr(this.object, Ri.geometryHelper, e, t);
  }
};
var kl = class extends Br(SpotLightHelper) {
  constructor(e, t = 6710886) {
    super(e, t);
    this.object = e;
    this.name = `SpotLightHelper: ${e.uuid}`;
  }
  raycast(e, t) {
    Dr(this.object, kl.geometryHelper, e, t);
  }
  update() {
    if (this.object !== void 0) {
      let e = kl._vector, t = this.object.distance ? this.object.distance : 1e3, o = t * Math.tan(this.object.angle);
      this.cone.scale.set(o, o, t), e.setFromMatrixPosition(this.object.target.matrixWorld), this.cone.lookAt(e);
      let i = this.color !== void 0 ? this.color : this.light.color;
      if (this.cone.material instanceof Array)
        for (let s = 0, l = this.cone.material.length; s < l; s++)
          this.cone.material[s].color.set(i);
      else
        this.cone.material.color.set(i);
    }
  }
};
var zs = kl;
zs._vector = new Vector3();
function TA(n, r) {
  n.shadow.camera.right = r / 2, n.shadow.camera.left = -r / 2, n.shadow.camera.top = r / 2, n.shadow.camera.bottom = -r / 2, n.shadow.needsUpdate = true;
}
var Ul = class extends Bi(DirectionalLight, Gi) {
  constructor(r, e, t) {
    super(), this.super_Entity(r, e), this.castShadow = true, this.shadow.mapSize.width = 2048, this.shadow.mapSize.height = 2048, this.shadow.normalBias = 1, this.layers.enable(3);
    let i = this.shadow.camera;
    i.top = 1250, i.bottom = -1250, i.right = 1250, i.left = -1250, i.near = -1e4, i.far = 2500;
    let s = new CameraHelper(this.shadow.camera);
    s.visible = false, this.gizmos.shadowmap = s;
  }
  update() {
    this.shadow.camera.updateProjectionMatrix();
    for (let r in this.gizmos) {
      let e = this.gizmos[r];
      e instanceof CameraHelper && e.update();
    }
  }
  updateMatrixWorld(r) {
    super.updateMatrixWorld(r), this.objectHelper && this.objectHelper.update();
  }
  updateState(r, e) {
    this.updateState_Light(r, e);
    let t = r.depth !== void 0 && r.depth !== this.shadow.camera.far || r.size !== void 0 && r.size / 2 !== this.shadow.camera.right;
    r.size !== void 0 && TA(this, r.size), r.shadowRadius !== void 0 && (this.shadow.radius = r.shadowRadius), r.shadowResolution !== void 0 && (this.shadow.mapSize.set(r.shadowResolution, r.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null)), t && this.update();
  }
};
var ql = class extends Bi(PointLight, Ri) {
  constructor(r, e, t) {
    super(), this.super_Entity(r, e), this.castShadow = true, this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024, this.shadow.normalBias = 1, this.layers.enable(3);
    let i = this.shadow.camera;
    i.fov = 90, i.aspect = 1, i.near = 100, i.far = 2500;
    let s = new Vector3(-i.far + this.position.x, -i.far + this.position.y, -i.far + this.position.z), l = new Vector3(i.far + this.position.x, i.far + this.position.y, i.far + this.position.z), c = new Box3(s, l), u = new Box3Helper(c, new Color(16755200));
    u.visible = false, this.gizmos.shadowmap = u, this.update();
  }
  update() {
    if (this.shadow && (this.shadow.camera.updateProjectionMatrix(), this.gizmos))
      for (let r in this.gizmos) {
        let e = this.gizmos[r];
        if (e instanceof Box3Helper) {
          let t = this.shadow.camera, o = new Vector3(-t.far + this.position.x, -t.far + this.position.y, -t.far + this.position.z), i = new Vector3(t.far + this.position.x, t.far + this.position.y, t.far + this.position.z);
          e.box.set(o, i), e.updateMatrixWorld(true);
        }
      }
  }
  updateMatrixWorld(r) {
    super.updateMatrixWorld(r), this.objectHelper && this.objectHelper.update();
  }
  updateState(r, e) {
    this.updateState_Light(r, e), r.distance !== void 0 && (this.distance = r.distance), r.decay !== void 0 && (this.decay = r.decay), r.shadowRadius !== void 0 && (this.shadow.radius = r.shadowRadius), r.shadowResolution !== void 0 && (this.shadow.mapSize.set(r.shadowResolution, r.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null));
  }
};
var Mg = new Vector3();
var Eg = new Vector3();
var Lg = new Quaternion();
var Wl = class extends Bi(SpotLight, zs) {
  constructor(r, e, t) {
    super(), this.super_Entity(r, e), this.castShadow = true, this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024, this.shadow.normalBias = 1, this.layers.enable(3);
    let i = this.shadow.camera;
    i.fov = MathUtils.RAD2DEG * 2 * this.angle, i.aspect = 1, i.near = 100, i.far = 2500;
    let s = new CameraHelper(this.shadow.camera);
    s.visible = false, this.gizmos.shadowmap = s, this.update();
  }
  update() {
    this.shadow.camera.updateProjectionMatrix();
    for (let r in this.gizmos) {
      let e = this.gizmos[r];
      e instanceof CameraHelper && e.update();
    }
  }
  updateMatrixWorld(r) {
    super.updateMatrixWorld(r), Eg.setFromMatrixPosition(this.matrixWorld), Lg.setFromRotationMatrix(this.matrixWorld), Mg.copy(this.up).applyQuaternion(Lg).negate().multiplyScalar(this.distance), this.target.position.copy(Eg).add(Mg), this.target.updateMatrixWorld(), this.objectHelper && this.objectHelper.update();
  }
  updateState(r, e) {
    this.updateState_Light(r, e), r.distance !== void 0 && (this.distance = r.distance), r.decay !== void 0 && (this.decay = r.decay), r.angle !== void 0 && (this.angle = r.angle), r.penumbra !== void 0 && (this.penumbra = r.penumbra), r.shadowRadius !== void 0 && (this.shadow.radius = r.shadowRadius), r.shadowResolution !== void 0 && (this.shadow.mapSize.set(r.shadowResolution, r.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null));
  }
};
var $l = class extends ft {
  get forceComputeSize() {
    return true;
  }
  get shape() {
    return this.geometry.userData.shape;
  }
  updateEntityBoxSize(r, e) {
    let t = this.geometry.getAttribute("position");
    t !== void 0 ? Ss(t, this.geometry.drawRange.start, this.geometry.drawRange.count < 1 / 0 ? this.geometry.drawRange.count : t.count, r, e) : super.updateEntityBoxSize(r, e);
  }
};
var Vi = class extends ft {
  constructor(e, t, o) {
    super(e, t, o);
    this._shapeId = null;
    this._context = o;
  }
  updateState(e, t) {
    super.updateState(e, t), this.updateShape();
  }
  updateShape() {
    var _a2;
    let e = this.data.geometry.extrusion.shape, t;
    if (e.type === "Custom") {
      let i = e.shapeId;
      if (i !== this._shapeId && this.detachShape(), i) {
        this._shapeId = i;
        let s = this._context.scene.find(i);
        (s == null ? void 0 : s.data) && (s.attachedPaths.add(this), t = (_a2 = s.geometry.userData) == null ? void 0 : _a2.shape), t || this._context.scene.addPendingCommand(() => this.updateShape());
      }
    } else {
      let i;
      switch (e.type) {
        case "Rectangle":
          i = gl;
          break;
        case "Ellipse":
          i = Yn;
          break;
        case "Polygon":
          i = yl;
          break;
        case "Star":
          i = xl;
          break;
        default:
          throw new Error(`Unknown shape type: ${e.type}`);
      }
      t = i.create({ parameters: e }).userData.shape;
    }
    let o = this.geometry;
    t && o.inputs && (o.inputs.shapeData = t, o.build(), this.attachedSurfaceCloners.forEach((i) => i.update()));
  }
  detachShape() {
    var _a2;
    this._shapeId !== null && ((_a2 = this._context.scene.find(this._shapeId)) == null ? void 0 : _a2.attachedPaths.delete(this));
  }
  createGeometryDelayed(e) {
    this.geometryCreateDeleyed = e.shared, this.updateShape(), this.refreshAttachedPaths(e);
  }
  updateTransformState(e) {
    return super.updateTransformState(e);
  }
  updateGeometryInteractions(e, t) {
    super.updateGeometryInteractions(e, t), this.updateShape();
  }
  updateEntityBoxSize(e, t) {
    let o = this.geometry.getAttribute("position");
    o !== void 0 ? Ss(o, this.geometry.drawRange.start, this.geometry.drawRange.count < 1 / 0 ? this.geometry.drawRange.count : o.count, e, t) : super.updateEntityBoxSize(e, t);
  }
};
var Qr = class extends vo(Group, bo) {
  constructor(e, t, o) {
    super();
    t.type === "Instance" && typeof e == "string" && (t = this.transformAssignData(t, o)), this.super_Entity(e, t), this.objectHelper.update();
  }
  get isComponentRoot() {
    return this.data.type === "Component" && typeof this.identity == "string";
  }
  get isInstanceRoot() {
    return this.data.type === "Instance" && typeof this.identity == "string";
  }
  transformAssignData(e, t) {
    let o = t.scene.data.objects.get(e.component);
    if (o) {
      let i, s;
      for (let l of uo.rootOverrideProps)
        e[l] === void 0 ? (i === void 0 && (i = { ...e }), i[l] = o.data[l]) : (s === void 0 && (s = {}), s[l] = e[l]);
      return this.overrideData = s, i ?? e;
    }
    return e;
  }
  updateByOp(e, t, o, i) {
    let s;
    if (this.isInstanceRoot && !i && (t = this.transformAssignData(t, o), e.type === 0 && e.path.length === 0 && this.component))
      for (let l of uo.rootOverrideProps)
        l in e.props && e.props[l] === void 0 && (s === void 0 && (s = { ...e, props: { ...e.props } }), s.props[l] = this.component.data[l]);
    super.updateByOp(s ?? e, t, o, i);
  }
  updateState(e, t) {
    this.updateState_Entity(e, t);
  }
  expandInstanceChildren(e) {
    let t = this.data;
    if (this.component === void 0) {
      this.component = e.scene.find(t.component) ?? null;
      let o = false;
      if (this.component !== this.oldComponent) {
        if (this.oldComponent) {
          let i = 0;
          for (let s of this.children)
            if (Ie.is(s))
              e.scene.disposeAndUnregisterEntityRecursivelyIfNotReregistered(s), Yl(s), i += 1;
            else
              break;
          this.children.splice(0, i);
        }
        o = true;
      }
      this.component && Gg(e, [this.uuid], t.overrides, this, this.component, this.component, 0, o), this.oldComponent = this.component;
    }
  }
};
function Yl(n) {
  if (n.component) {
    let r = n.component.instances.indexOf(n);
    r >= 0 && n.component.instances.splice(r, 1);
    for (let e of n.children)
      Ie.is(e) && Yl(e);
  }
}
function Dg(n, r, e, t) {
  return n.component === r && Ui(n.identity, t) ? n.overrideData === e ? 2 : 1 : 0;
}
function Gg(n, r, e, t, o, i, s, l) {
  if (s > 50)
    return false;
  if (t.component !== o) {
    if (t.component) {
      let u = t.component.instances.indexOf(t);
      u >= 0 && t.component.instances.splice(u, 1);
    }
    o.instances.push(t), t.component = o;
  }
  o instanceof Qr && o.isInstanceRoot && o.expandInstanceChildren(n);
  let c = 0;
  for (let u of o.children)
    if (Ie.is(u)) {
      let a = [...r, ...typeof u.identity == "string" ? [u.identity] : u.identity], d = Ln.resolve(e, a, 1), p = null, f;
      if (!l) {
        let m = t.children[c];
        if (p = Ie.is(m) ? m : null, p !== null) {
          let h = Dg(p, u, d, a);
          f = h >= 1 ? p.stateSelection : void 0, h !== 2 && (p = null);
        }
        if (p === null && (p = n.scene.findInstance(a) ?? null, p !== null)) {
          let h = Dg(p, u, d, a);
          if (f = h >= 1 ? p.stateSelection : void 0, h !== 2)
            p = null;
          else {
            let y = p.parent.children.indexOf(p);
            p.parent.children.splice(y, 1), t.children.splice(c, 0, p), p.parent === t ? (y <= c && console.error("not possible"), void 0) : (p.parent = t, p.matrixWorldNeedsUpdate = true, p.resetBBoxNeedsUpdate(), p.updateVisible(), n.pendingDeletes.delete(p), void 0);
          }
        }
      }
      if (p === null) {
        let m = d ? Hr.apply(u.data, d) : u.data;
        Qt.is(m.type) && (m = { ...m, type: "Empty" }), p = tr.createEntity(a, m, n), p.overrideData = d, t.add(p), t.children.splice(t.children.length - 1, 1), t.children.splice(c, 0, p), p.updateState(p.data, n), f && p.changeSelectedState(f, n), n.scene.registerInstanceAndSetUuid(p);
      }
      c += 1, Gg(n, r, e, p, u, i, s + 1, l);
    }
  if (!l) {
    let u = c;
    for (; ; ) {
      let a = t.children[c];
      if (Ie.is(a))
        n.pendingDeletes.add(a);
      else
        break;
      c += 1;
    }
    t.children.splice(u, c - u);
  }
  return true;
}
function LA(n, r, e) {
  let t;
  return r.geometry.type === "TextGeometry" ? new Ci(n, r, e) : (r.geometry.type === "SubdivGeometry" ? t = new Ho(n, r, e) : r.geometry.type === "PathGeometry" ? t = new Vi(n, r, e) : r.geometry.type === "VectorGeometry" ? t = new $l(n, r, e) : r.geometry.type === "BooleanGeometry" ? t = new Kt(n, r, e) : t = new ft(n, r, e), t);
}
function Xl(n, r, e) {
  return r.type === "Mesh" ? LA(n, r, e) : r.type === "Empty" ? new Vs(n, r) : r.type === "PointLight" ? new ql(n, r, e) : r.type === "SpotLight" ? new Wl(n, r, e) : r.type === "DirectionalLight" ? new Ul(n, r, e) : r.type === "Component" || r.type === "Instance" ? new Qr(n, r, e) : Qt.is(r.type) ? new Gr(n, r) : (console.error(r), new Vs(n, r));
}
tr.createEntity = Xl;
function BA(n, r, e) {
  let t = Xl(n.identity, r, e), o = n.children, i = n.attachedPaths, s = n.parent, l = n.component, c = n.instances, u = n.overrideData, a = n.uuid, d = n.stateSelection;
  n.dispose();
  for (let p of Object.keys(n))
    delete n[p];
  Object.setPrototypeOf(n, Object.getPrototypeOf(t));
  for (let p of Object.keys(t))
    n[p] = t[p];
  n.children = [...n.children, ...o], n.attachedPaths = i, n.parent = s, n.component = l, n.instances = c, n.uuid = a, n.overrideData = u, n.updateState(n.data, e), d && n.changeSelectedState(d, e), n.resetBBoxNeedsUpdate();
}
tr.changeEntityProptotype = BA;
tr.Cloner = Mi;
function Rg(n, r, e, t) {
  n.updateByOp(r, e, t, false);
}
function Vg(n, r) {
  let e = false, t = r.getLayersOfType("transmission"), o = r.getLayersOfType("outline");
  return o.length > 0 && (n.layers.set(8), t.length > 0 && n.layers.enable(3), e = true, Ai(n), Oi(n)), t.length === 0 && o.length === 0 && n.layers.set(0), n instanceof $t && n.needsAO && n.layers.enable(5), e;
}
function zg(n, r) {
  if (!r.layers)
    return false;
  let e = false, t = r.getLayersOfType("transmission").filter((i) => i.data.visible), o = r.getLayersOfType("outline").filter((i) => i.data.visible);
  return t.length > 0 && (n.layers.set(3), o.length > 0 && n.layers.enable(8), e = true), t.length === 0 && o.length === 0 && n.layers.set(0), n.needsAO && n.layers.enable(5), e;
}
function jg(n) {
  let r = false;
  return n.traverseEntity((e) => {
    if (e instanceof $t)
      if (Array.isArray(e.material))
        for (let t = 0; t < e.material.length; t++)
          Vg(e, e.material[t]) && (r = true);
      else
        Vg(e, e.material) && (r = true);
  }), r;
}
function Fg(n) {
  let r = false;
  return n.traverseEntity((e) => {
    if (e instanceof $t)
      if (Array.isArray(e.material))
        for (let t = 0; t < e.material.length; t++)
          zg(e, e.material[t]) && (r = true);
      else
        zg(e, e.material) && (r = true);
  }), r;
}
var jA = new Raycaster();
var FA = new Matrix4();
var kA = new Ray();
function yu(n, r, e, t = false) {
  let o = n.cloner;
  if (o)
    for (let i of o.children) {
      let s = FA.copy(i.matrixWorld).invert(), l = kA.copy(r.ray).applyMatrix4(s), c = n.matrixWorld;
      l.applyMatrix4(c);
      let u = jA;
      u.set(l.origin, l.direction), u.near = r.near, u.far = r.far;
      let a = u.intersectObject(n, false);
      a.length > 0 && e.push({ ...a[0], object: t ? i : n });
    }
}
var Kl = class {
  constructor() {
    this._constraints = /* @__PURE__ */ new Map();
  }
  setConstraint(r, e) {
    e === null ? this._constraints.delete(r) : this._constraints.set(r, e);
  }
  removeDependencies(r) {
    this._constraints.delete(r);
  }
  applyConstraints(r) {
    let e = /* @__PURE__ */ new Set();
    this._constraints.forEach((t, o) => {
      let i = [o, t], s = t;
      for (; this._constraints.has(s); )
        s = this._constraints.get(s), e.has(s) || i.push(s);
      for (let l = i.length - 2; l >= 0; l--)
        if (!e.has(i[l])) {
          let c = r.find(i[l]);
          c ? c.applyPathSnapping(r) : console.warn(`missing entity ${i[l]}`), e.add(i[l]);
        }
    });
  }
  findDependency(r, e) {
    let t = r;
    for (; this._constraints.has(t); )
      if (t = this._constraints.get(t), t === e)
        return true;
    return false;
  }
};
var XA = new MeshBasicMaterial();
XA.wireframe = true;
var kg = new Vector3();
var gu = class extends Scene {
  constructor(e, t) {
    super();
    this.data = e;
    this.backupFog = new Fog(16777215, 0.1, 2e3);
    this.fogUseBGColor = false;
    this.enableHelpers = false;
    this.wireframeState = false;
    this.needsTransmissionDirty = true;
    this.needsNormalDirty = true;
    this._needsTransmission = false;
    this._needsNormal = false;
    this.occlusion = false;
    this.aoFullRes = false;
    this.radius = 128;
    this.bias = 0.5;
    this.aoColor = { r: 0, g: 0, b: 0 };
    this.geometryCacheChanged = false;
    this.bgColor = new Ke(1, 1, 1, 1);
    this.entityByUuid = {};
    this.entityIdentityToEntity = {};
    this.toExpandCloner = /* @__PURE__ */ new Set();
    this.toUpdateCloner = /* @__PURE__ */ new Set();
    this.pendingCommands = [];
    this.pathConstraints = new Kl();
    this.needsRecomputeInstances = false;
    this.ambientLight = new HemisphereLight(13882323, 8553090, 0.75), this.ambientLight.name = "Default Ambient Light", this.ambientLight.layers.enable(3), this.personalCamera = this.createPersonalCamera(), this.activeCamera = this.personalCamera, this.postprocessing = e.postprocessing, this.init(e, t), this.matrixAutoUpdate = false;
  }
  markGeometryCacheDirty() {
    this.geometryCacheChanged = true;
  }
  markNeedsUpdateRendererDirty() {
    this.needsTransmissionDirty = true, this.needsNormalDirty = true;
  }
  needsTransmission() {
    return this.needsTransmissionDirty && (this._needsTransmission = Fg(this), this.needsTransmissionDirty = false), this._needsTransmission;
  }
  needsNormal() {
    return this.needsNormalDirty && (this._needsNormal = jg(this), this.needsNormalDirty = false), this._needsNormal;
  }
  registerInstanceAndSetUuid(e) {
    let t = e.identity.join("-"), o = this.entityIdentityToEntity[t];
    o && (e.uuid = o.uuid), this.entityIdentityToEntity[t] = e, this.entityByUuid[e.uuid] = e;
  }
  findInstance(e) {
    return this.entityIdentityToEntity[e.join("-")];
  }
  getWithSortKey(e) {
    let t = this.find(e);
    if (t === void 0)
      return;
    let o = [], i = t;
    for (; i !== this; ) {
      let s = i;
      i = i.parent;
      let l = i.children.indexOf(s);
      o.splice(0, 0, l);
    }
    return { entity: t, sortKey: o };
  }
  getAllSorted(e) {
    let t = [];
    for (let o of e) {
      let i = this.getWithSortKey(o.id);
      i !== void 0 && t.push(i);
    }
    return t.sort((o, i) => wu(o.sortKey, i.sortKey)), t.map((o) => o.entity);
  }
  nonExistOrDescendantOf(e, t) {
    let o = this.find(e);
    if (o === void 0)
      return true;
    for (; o; ) {
      if (o.uuid === t)
        return true;
      o = o.parent;
    }
    return false;
  }
  find(e) {
    if (e === "" || e === void 0)
      return;
    let t = this.entityByUuid[e];
    return t === void 0 ? this.getObjectByProperty("uuid", e) : t;
  }
  debugEnsureEntity(e) {
    let t = this.find(e);
    if (t) {
      if (Array.isArray(t.identity) && this.findInstance(t.identity) === void 0) {
        console.error("not found instance");
        debugger;
      }
    } else {
      console.error("not found");
      debugger;
    }
  }
  addPendingExpandCloner(e) {
    this.toExpandCloner.add(e);
  }
  addPendingUpdateCloner(e) {
    this.toUpdateCloner.add(e);
  }
  markToExpandCloner(e) {
    this.toExpandCloner.add(e), e.traverseEntityAncestors((t) => {
      this.toExpandCloner.add(t);
    });
  }
  doPendingExpandCloner() {
    this.toExpandCloner.forEach((e) => {
      e.expandCloner(this);
    }), this.toExpandCloner.clear();
  }
  doPendingUpdateCloner() {
    this.toUpdateCloner.forEach((e) => {
      var _a2;
      (_a2 = e.cloner) == null ? void 0 : _a2.update();
    }), this.toUpdateCloner.clear();
  }
  doPendingUpdates() {
    this.doPendingExpandCloner(), this.doPendingUpdateCloner(), this.applyPendingCommands();
  }
  addPendingCommand(e) {
    this.pendingCommands.push(e);
  }
  applyPendingCommands() {
    this.pendingCommands.forEach((e) => e()), this.pendingCommands.length = 0;
  }
  updateTreeByOp(e, t) {
    var _a2;
    if (e.path.length === 0 && e.type === 7) {
      let o = e.parent === null ? this : this.find(e.parent);
      if (o === void 0)
        throw new Error("unexpected");
      let i = this.createObject(e.id, e.data, e.children, o, e.localIndex, t);
      i.updateVisible(), i.resetBBoxNeedsUpdate(), Di(i) && Rs(i.parent) && (i.invalidateUpstreamBooleanData(), i.parent.invalidateDownstreamBooleanData().recomputeBoolean()), this.markNeedsRecomputeInstancesForAncessors(o), this.markNeedsRecomputeInstancesForChildren(i), this.markToExpandCloner(i);
    } else if (e.path.length === 0 && e.type === 8) {
      let o = this.find(e.id);
      if (o === void 0)
        throw new Error("unexpected");
      this.markToExpandCloner(o), o.resetBBoxNeedsUpdate(), this.unregisterObject(o);
      let i = o.parent;
      this.markNeedsRecomputeInstancesForAncessors(i), this.markNeedsRecomputeInstancesForChildren(o), o.parent.remove(o), Rs(o.parent) && (o.parent.invalidateUpstreamBooleanData(), o.parent.invalidateDownstreamBooleanData().recomputeBoolean()), Di(o) && (o.freeBooleanPointer(), i instanceof Kt && i.invalidateDownstreamBooleanData().recomputeBoolean()), o instanceof Vi && o.detachShape(), this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(o), this.pathConstraints.removeDependencies(o.uuid);
    } else if (e.path.length === 0 && e.type === 9) {
      let o = this.find(e.id);
      if (o === void 0)
        throw new Error("unexpected");
      this.markNeedsRecomputeInstancesForChildren(o);
      let i = o.parent;
      this.markNeedsRecomputeInstancesForAncessors(i), (_a2 = o.cloner) == null ? void 0 : _a2.resetOnMove(), this.markToExpandCloner(o);
      let s = e.parent === null ? this : this.find(e.parent);
      if (s === void 0)
        throw new Error("unexpected");
      s.add(o), this.markNeedsRecomputeInstancesForAncessors(s), this.markToExpandCloner(o), o.invalidateClonerTransform(o), o.updateVisible(), o.resetBBoxNeedsUpdate();
      let l = e.localIndex;
      s.children.splice(l, 0, s.children.pop()), Di(o) && (o.invalidateUpstreamBooleanData(), Rs(o.parent) ? o.parent.invalidateDownstreamBooleanData().recomputeBoolean() : i instanceof Kt && i.invalidateDownstreamBooleanData().recomputeBoolean());
    }
    this.markNeedsUpdateRendererDirty(), this.markGeometryCacheDirty();
  }
  updateEntityByOp(e, t, o, i) {
    if (t.type === 0) {
      if (("overrides" in t.props || "component" in t.props) && this.markNeedsRecomputeInstances(), t.path.includes("overrides") && "states" in t.props) {
        let { rest: l } = t.props;
        t = { ...t, props: l }, this.markNeedsRecomputeInstances();
      }
      t.path[0] === "pathSnapping" && t.props.pathId !== void 0 && this.pathConstraints.setConstraint(e, t.props.pathId);
    }
    let s = this.find(e);
    if (s)
      try {
        Rg(s, t, o, { scene: this, shared: i }), s instanceof ft && s.updateGeometryGroupsIfNeeded();
      } catch (l) {
        console.error(l);
      }
  }
  get enableFog() {
    return this.fog !== null;
  }
  set enableFog(e) {
    this.fog = e === true ? this.backupFog : null;
  }
  init(e, t) {
    if (this.createChildrenObjects(e.objects, this, t), this.personalCamera.removeFromParent(), this.add(this.personalCamera), this.ambientLight.removeFromParent(), this.add(this.ambientLight), this.setBackgroundColor(st(e.backgroundColor, t)), this.updateFog(e.fog, t), this.updateAmbientLight(e.environment.ambientLight, t), this.activeCamera = this.personalCamera, e.publish.playCamera !== null) {
      let o = this.find(e.publish.playCamera);
      o instanceof Gr && this.switchActiveCamera(o);
    }
    this.expandInstances(t, true), this.traverseEntity((o) => {
      Rs(o) && o.recomputeBoolean(), o instanceof Gr && o.updateUp();
    }), this.doPendingExpandCloner(), this.applyPendingCommands();
  }
  markNeedsRecomputeInstances() {
    this.needsRecomputeInstances = true;
  }
  markNeedsRecomputeInstancesForChildren(e) {
    e.traverseEntity((t) => {
      (t.data.type === "Component" || t.data.type === "Instance") && this.markNeedsRecomputeInstances();
    });
  }
  markNeedsRecomputeInstancesForAncessors(e) {
    Ie.is(e) && (e.data.type === "Component" && this.markNeedsRecomputeInstances(), e.traverseAncestors((t) => {
      Ie.is(t) && t.data.type === "Component" && this.markNeedsRecomputeInstances();
    }));
  }
  relativeizeInner(e, t, o, i, s, l, c) {
    e && e !== i.uuid && i.find(e) && s.forInstancesRec((a) => {
      a.isInstanceRoot || (a.data = On(a.data, (d) => {
        let p = d.events.data(c.id), f = a.goUp(l);
        if (f) {
          let m = [...$s(f.identity), e].join("-"), h = this.entityIdentityToEntity[m];
          if (h) {
            let y = h.uuid;
            yt.zoom(p, t)[o] = y;
          } else {
            if (false)
              debugger;
            console.warn("cannot find instance");
          }
        }
      }).data);
    });
  }
  rewriteEventsBeforeGoToPlayMode() {
    this.traverseEntity((e) => {
      if (e instanceof Qr && typeof e.identity == "string" && e.data.type === "Component")
        return e.traverseEntity((t, o) => {
          t.data.events.forEach((i) => {
            i.data.type === "GameControl" ? t.forInstancesRec((s) => {
              s.isInstanceRoot || (s.data = On(s.data, (l) => {
                l.events.delete(i.id);
              }).data);
            }) : i.data.type === "Conditional" ? (i.data.condition.type === "Distance" ? (this.relativeizeInner(i.data.condition.fromObject, ["condition"], "fromObject", e, t, o, i), this.relativeizeInner(i.data.condition.toObject, ["condition"], "toObject", e, t, o, i)) : i.data.condition.type === "State" ? this.relativeizeInner(i.data.condition.object, ["condition"], "object", e, t, o, i) : i.data.condition.type === "Comparison" && (i.data.condition.lOperand.type === "Property" && this.relativeizeInner(i.data.condition.lOperand.value[0], ["condition", "lOperand", "value"], 0, e, t, o, i), i.data.condition.rOperand.type === "Property" && this.relativeizeInner(i.data.condition.rOperand.value[0], ["condition", "rOperand", "value"], 0, e, t, o, i)), i.data.inActions.forEach((s) => {
              s.data.type === "Transition" && this.relativeizeInner(s.data.object, ["inActions", s.id], "object", e, t, o, i);
            }), i.data.outActions.forEach((s) => {
              s.data.type === "Transition" && this.relativeizeInner(s.data.object, ["outActions", s.id], "object", e, t, o, i);
            })) : "actions" in i.data && i.data.actions.forEach((s) => {
              s.data.type === "Transition" && this.relativeizeInner(s.data.object, ["actions", s.id], "object", e, t, o, i);
            });
          });
        }), true;
    });
  }
  expandInstances(e, t) {
    let o = /* @__PURE__ */ new Set();
    this.traverseEntity((i) => {
      if (i instanceof Qr && i.isInstanceRoot)
        return i.expandInstanceChildren({ scene: this, shared: e, pendingDeletes: o }), t || i.resetBBoxNeedsUpdate(), true;
    });
    for (let i of o)
      this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(i), Yl(i);
  }
  recomputeInstances(e) {
    this.needsRecomputeInstances && (this.needsRecomputeInstances = false, this.traverseEntity((t) => {
      t instanceof Qr && t.isInstanceRoot && (t.component = void 0);
    }), this.expandInstances(e, false));
  }
  disposeAndUnregisterEntityRecursivelyIfNotReregistered(e) {
    e.traverseEntity((t) => {
      let o = typeof t.identity == "string" ? t.identity : t.identity.join("-");
      this.entityIdentityToEntity[o] === t && (delete this.entityByUuid[t.uuid], delete this.entityIdentityToEntity[o]), t.dispose();
    });
  }
  clearScene() {
    for (let e of this.children)
      Ie.is(e) && e.disposeRecursively();
    this.children.length = 0;
  }
  resetAfterClear(e, t) {
    this.init(e, t);
  }
  createPersonalCamera() {
    let e = new Gr(gu.PERSONAL_CAMERA_ID, { ...En.defaultData, name: "Personal Camera" });
    return e.objectHelper.visible = false, this.registerObjectCreatedInLegacy(e), e;
  }
  raycast(e) {
    let t = [], o = (i) => {
      for (let s of i.children) {
        let l = s.cloner;
        Ie.is(s) && !s.raycastLock && (s.visible || (l == null ? void 0 : l.object.data.visible)) && ((Di(s) || hu(s) && this.enableHelpers && s.objectHelper.visible) && (e.intersectObject(s, false, t), yu(s, e, t)), o(s));
      }
    };
    return o(this), t;
  }
  raycastWithClones(e) {
    let t = [], o = (i) => {
      for (let s of i.children) {
        let l = s.cloner;
        Ie.is(s) && (s.visible || (l == null ? void 0 : l.object.data.visible)) && ((Di(s) || hu(s) && this.enableHelpers && s.objectHelper.visible) && (e.intersectObject(s, false, t), yu(s, e, t, true)), o(s));
      }
    };
    return o(this), t;
  }
  forEachEntity(e) {
    for (let t of this.children)
      Ie.is(t) && e(t);
  }
  traverseEntity(e) {
    for (let t of this.children)
      Ie.is(t) && t.traverseEntity(e);
  }
  traverseObject(e) {
    for (let t of this.children)
      rs.is(t) && t.traverseObject(e);
  }
  traverseVisibleEntity(e) {
    for (let t of this.children)
      Ie.is(t) && t.visible && t.traverseVisibleEntity(e);
  }
  updateFog(e, t) {
    this.enableFog = e.enabled, this.fogUseBGColor = e.useBackgroundColor, e.useBackgroundColor ? this.backupFog.color.set(this.bgColor) : this.backupFog.color = st(e.color, t), this.backupFog.near = e.near, this.backupFog.far = e.far;
  }
  dispose() {
    this.clearScene();
  }
  updateAmbientLight(e, t) {
    e.color !== void 0 && (this.ambientLight.color = st(e.color, t)), e.intensity !== void 0 && (this.ambientLight.intensity = e.intensity), e.groundColor !== void 0 && (this.ambientLight.groundColor = st(e.groundColor, t)), e.enabled !== void 0 && (this.ambientLight.visible = e.enabled), e.occlusion !== void 0 && (this.occlusion = e.occlusion), e.aoFullRes !== void 0 && (this.aoFullRes = e.aoFullRes), e.radius !== void 0 && (this.radius = e.radius), e.bias !== void 0 && (this.bias = e.bias), e.aoColor !== void 0 && (this.aoColor = st(e.aoColor, t));
  }
  switchActiveCamera(e) {
    this.activeCamera !== this.personalCamera && (this.activeCamera.objectHelper.visible = true), this.activeCamera = e, e.objectHelper.visible = false;
  }
  setBackgroundColor(e) {
    this.bgColor = e, this.fogUseBGColor === true && (this.backupFog.color = e);
  }
  createChildrenObjects(e, t, o) {
    let i = 0;
    for (let s of e)
      this.createObject(s.id, s.data, s.children, t, i, o), i += 1;
  }
  registerObjectCreatedInLegacy(e) {
    this.entityByUuid[e.uuid] = e;
  }
  unregisterObject(e) {
    delete this.entityByUuid[e.uuid];
    for (let t of e.children)
      this.unregisterObject(t);
  }
  createObject(e, t, o, i, s, l) {
    var _a2;
    let c = { scene: this, shared: l }, u = Xl(e, t, c);
    return u && (this.entityByUuid[e] = u, i.add(u), i.children.splice(s, 0, i.children.pop()), o.length > 0 && (u.isInstanceRoot ? console.error("instance should not have children!") : this.createChildrenObjects(o, u, l)), u.updateState(t, c), u instanceof ft && u.updateGeometryGroupsIfNeeded(), u.updateVisible(), u.cloner && this.toExpandCloner.add(u), ((_a2 = t.pathSnapping) == null ? void 0 : _a2.pathId) && this.pathConstraints.setConstraint(e, t.pathSnapping.pathId)), u;
  }
  getCenter(e) {
    let t = [];
    for (let i = 0, s = e.length; i < s; ++i) {
      let { id: l, recursive: c } = e[i], u = this.find(l), a = c ? u.recursiveBBox : u.singleBBox;
      t.push(...a.vertices);
    }
    let o = new Box3();
    return o.setFromPoints(t), o.getCenter(kg), kg;
  }
  copyMatrixWorld(e, t) {
    if (e === null) {
      t.identity();
      return;
    }
    let o = this.find(e);
    o ? t.copy(o.matrixWorld) : t.identity();
  }
  copyParentMatrixWorld(e, t) {
    var _a2;
    if (e === null) {
      t.identity();
      return;
    }
    let o = (_a2 = this.find(e)) == null ? void 0 : _a2.parent;
    o ? t.copy(o.matrixWorld) : t.identity();
  }
  traverseMaterial(e) {
    this.traverseEntity((t) => {
      if (t instanceof dt)
        if (Array.isArray(t.material))
          for (let o = 0; o < t.material.length; o++)
            t.material[o] instanceof It && e(t.material[o]);
        else
          t.material instanceof It && e(t.material);
    });
  }
  updateCanvasSize(e, t) {
    this.activeCamera.setViewplaneSize(e, t);
    let o, i;
    e >= t ? (o = t / e, i = 1) : (o = 1, i = e / t), this.traverseMaterial((s) => {
      s.getLayersOfType("transmission").forEach((c) => {
        c.uniforms[`f${c.id}_aspectRatio`].value.x = o, c.uniforms[`f${c.id}_aspectRatio`].value.y = i;
      });
    });
  }
};
var zi = gu;
zi.PERSONAL_CAMERA_ID = "f23858d0-4a3b-4bd8-8173-66ed0af7f6fb-personalCamera", zi.PERSONAL_CAMERA_EXPORT_ID = "f23858d0-4a3b-4bd8-8173-66ed0af7f6fb-personalCameraExport";
var So;
function ZA() {
  return So || (So = new DRACOLoader(), So.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.2/").preload()), So.decoderPending;
}
async function QA(n) {
  if (So) {
    let r = { attributeIDs: So.defaultAttributeIDs, attributeTypes: So.defaultAttributeTypes, useUniqueIDs: false }, e;
    try {
      e = await So.decodeGeometry(new Int8Array(n).buffer, r);
    } catch (t) {
      console.error(t);
    }
    if (e)
      return { index: e.index ? { array: e.index.array } : void 0, attributes: Object.entries(e.attributes).map(([t, o]) => ({ name: t, itemSize: o.itemSize, array: o.array })) };
  }
  return null;
}
async function Ug(n, r) {
  let [e, t] = dc(Da.deserialize(new Uint8Array(n)));
  Ym(e);
  let o = [];
  e.scene.objects.traverse((i, s) => {
    s.type === "Mesh" && s.geometry.type === "NonParametricGeometry" && s.geometry.data.draco !== void 0 && o.push(s);
  }), o.length && await ZA();
  for (let i of o) {
    let s = await QA(Qe(i.geometry.data.draco));
    if (s) {
      s.index && (i.geometry.data.index = { array: s.index.array, itemSize: 1, normalized: false, type: "Uint32Array" });
      let l = {};
      s.attributes.forEach(({ name: c, array: u, itemSize: a }) => {
        l[c] = { array: u, itemSize: a, type: "Float32Array", normalized: false };
      }), i.geometry.data.attributes = l, i.geometry.data.draco = void 0;
    }
  }
  return r && r(e), t.result().data;
}
function Hg(n) {
  let r;
  if (!!n.index)
    for (let e = 0; e < n.index.array.length; e += 3)
      r = n.index.array[e], n.index.array[e] = n.index.array[e + 2], n.index.array[e + 2] = r;
}
function Wg(n) {
  let r = /* @__PURE__ */ new Set();
  return n.traverse((e) => {
    if (e instanceof $t)
      if (Ve(e.material))
        e.material.forEach((t) => {
          let o = t;
          r.has(o) || r.add(o);
        });
      else {
        let t = e.material;
        r.has(t) || r.add(t);
      }
  }), r.forEach((e) => {
    if (e instanceof Array)
      return;
    let t = e.onBeforeCompile.bind(e);
    if (eN(e)) {
      Object.assign(e, { isMeshStandardMaterial: true, isMeshPhysicalMaterial: true, transmission: 1, attenuationColor: new Color(), specularColor: new Color() });
      let o = 0;
      e.onBeforeCompile = (i, s) => {
        t && t(i, s), i.uniforms = Object.assign({}, ShaderLib.physical.uniforms, i.uniforms), e.getLayersOfType("transmission").forEach((l) => {
          if (i.uniforms.transmissionSamplerMap.value) {
            let c = l.color;
            c && (c.transmissionSamplerMap.value = i.uniforms.transmissionSamplerMap.value, c.transmissionSamplerSize.value = i.uniforms.transmissionSamplerSize.value);
          } else
            o++, o < 2 && (e.needsUpdate = true);
        });
      };
    } else
      tN(e) || (e.onBeforeCompile = (o, i) => {
        t && t(o, i), e.transparent = false;
      });
  }), n;
}
function eN(n) {
  return n.getLayersOfType("transmission").length > 0;
}
function tN(n) {
  let r = 0;
  return n.layers.forEach((e) => {
    if (e.type !== "light" && e.type !== "fresnel") {
      let t = e.uniforms["f" + e.id + "_alpha"];
      t && (r += (1 - r) * t.value);
    }
  }), r < 1;
}
function $g(n) {
  return n.traverse((r) => {
    if (r.type === "Camera") {
      let e = r;
      e.type = e.cameraType;
    }
  }), n;
}
function Yg(n) {
  let r = [], e = (t, o = 0) => {
    let i = o > 0 ? t + o : t;
    return r.includes(i) ? e(t, o + 1) : i;
  };
  return n.traverse((t) => {
    if (r.includes(t.name)) {
      let o = t.name, i = e(t.name);
      if (t.name = i, t.isMesh) {
        let s = t;
        s.material instanceof Array ? s.material.forEach((l) => {
          l.name = l.name.replace(o, i);
        }) : s.material.isAsset || (s.material.name = s.material.name.replace(o, i));
      }
    }
    r.push(t.name);
  }), n;
}
function Xg(n) {
  let r = [];
  return n.traverse((e) => {
    e instanceof Mi && r.push(e);
  }), r.forEach((e) => {
    let t = e.object, s = [...e.children.map((l) => {
      l.updateMatrix();
      let c;
      if (l.geometry !== void 0)
        try {
          c = l.geometry.clone().applyMatrix4(l.matrix);
        } catch (u) {
          console.error(u);
        }
      return c !== void 0 && l.matrix.determinant() < 0 && Hg(c), c;
    }).filter((l) => l !== void 0)];
    if (!e.parameters.hideBase && t instanceof dt && s.unshift(t.geometry), s.length) {
      let l = mergeBufferGeometries(s);
      t instanceof dt && (t.geometry = l);
    }
    e.removeFromParent(), t.setFromClonerState(null, { scene: n, shared: Qy });
  }), n;
}
function Kg(n) {
  return n.traverse((r) => {
    r.matrixAutoUpdate = true;
  }), n;
}
function Zg(n) {
  Object.values(n.shared.materials).forEach((r) => {
    xu(r);
  }), n.scene.objects.traverse((r, e) => {
    "material" in e ? xu(e.material) : "materials" in e && e.materials.forEach((t) => {
      xu(t);
    });
  });
}
function xu(n) {
  if (typeof n == "string")
    return;
  let r = [];
  n.layers.forEach((e, t) => {
    e.type === "outline" && r.push(t);
  }), r.reverse().forEach((e) => {
    n.layers.delete(e);
  }), r.length && console.warn("The Spline Loader currently does not support the outline layer.");
}
var r0 = Ws(Jg(), 1);
function e0(n) {
  return n.traverseMaterial((r) => {
    r.needsJitter = false;
  }), n;
}
var t0 = "The SplineLoader only accepts .splinecode files that are generated from Spline export panel.";
var vu = class extends Loader {
  load(r, e, t, o = console.error) {
    let i = new FileLoader(this.manager);
    i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), r.endsWith(".spline") ? console.warn(t0 + " The .spline files are only meant to be used by the Editor.") : r.endsWith(".splinecode") || console.warn(t0), i.load(r, async (s) => {
      try {
        if (typeof s == "string")
          throw new Error("The .spline file is not binary!");
        let l = await this.parse(s);
        e(l);
      } catch (l) {
        o(l);
      }
    }, t, o);
  }
  async parse(r) {
    let e = await Ug(r, Zg);
    e.version && (0, r0.default)(e.version, "0.9.374") > 0 && console.warn("Your .splinecode file is more recent than the library. Please upgrade @splinetool/loader to the latest version."), await Promise.all([tg(e) && hy(), pg(e) && Ky()].filter(Boolean));
    let t = new Uo(e.shared);
    Object.values(t.getMaterials()).forEach((s) => Object.assign(s, { isAsset: true }));
    let o = new zi(e.scene, t);
    o.remove(o.personalCamera), e.scene.environment.ambientLight.enabled || o.remove(o.ambientLight);
    let i = e.scene.publish.playCamera;
    if (i) {
      let s = o.find(i);
      s && Ag(s) && Object.assign(s, { makeDefault: true });
    }
    return o = Xg(o), o = Wg(o), o = $g(o), o = Yg(o), o = Kg(o), o = e0(o), o;
  }
};

// node_modules/@splinetool/r3f-spline/dist/useSpline.es.js
function useSpline(url) {
  const scene = useLoader(vu, url);
  return useGraph(scene);
}
export {
  useSpline as default
};
//# sourceMappingURL=@splinetool_r3f-spline.js.map
